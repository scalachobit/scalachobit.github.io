<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCALA 手账</title>
  
  <subtitle>scala</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scala.chobit.org/"/>
  <updated>2018-05-29T13:54:16.021Z</updated>
  <id>http://scala.chobit.org/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>a26-traitSelectiveMixedIn</title>
    <link href="http://scala.chobit.org/wiki/20180529/a26-traitSelectiveMixedIn/"/>
    <id>http://scala.chobit.org/wiki/20180529/a26-traitSelectiveMixedIn/</id>
    <published>2018-05-29T13:54:15.000Z</published>
    <updated>2018-05-29T13:54:16.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Trait</title>
    <link href="http://scala.chobit.org/wiki/20180528/a25-traitSummary/"/>
    <id>http://scala.chobit.org/wiki/20180528/a25-traitSummary/</id>
    <published>2018-05-28T14:26:54.000Z</published>
    <updated>2018-05-29T13:51:17.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不知道大家对java的接口是如何理解的。在我刚接触到接口这个概念的时候，我将接口理解为一系列规则的集合，认为接口是对类的行为的规范。现在想来，将接口理解为是对类的规范多少有些偏颇，更恰当些的观点应该是：相对于类来说，接口是更深层次的抽象，虽然同时接口也起到了规定类的行为的作用。  </p><p>和java的接口比起来，scala的trait可能更具体一些。正如trait这个单词的本意一样，它指的是一种特质：如果认为类有某种特质就混入对应的trait好了。在scala中，类是对现实某一类事务的建模，而Trait则是对已有模型的补充。  </p><p>我自己以为，trait这个概念理解起来要比接口更容易一些。</p><p>看个例子吧：狗是人类的好朋友，它在我们孤单的时候默默地陪伴。用scala可以这样定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span></span></span><br></pre></td></tr></table></figure><p>我们先定义了一个名为人类的朋友（HumanFriend）的trait，朋友的主要特征就是陪伴，所以在这个trait里面定义了一个方法accompany并做了实现。Dog（狗）具有人类的好朋友这个特质，所以可以混入trait HumanFriend。在scala中继承某个trait，通常也称为混入某个trait。</p><p>在trait HumanFriend中定义了一个val变量name。这个name没有默认值，我们可以认为它是抽象的，可以等到其他类混入这个trait时再为其赋值。</p><p>混入trait的类可以直接调用trait的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>).accompany()</span><br></pre></td></tr></table></figure></p><p>一个类混入trait后，我们可以认为其实例就是trait的引用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tom: <span class="type">HumanFriend</span>= <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>)</span><br></pre></td></tr></table></figure></p><p>一个trait会被编译为一个接口和一个抽象类。trait中定义的未赋值的val变量会被表示为一个抽象方法。</p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>混入trait的类可以重写trait的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span> accompany with me."</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写时需要使用override关键字。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>一个类混入trait的数量是任意的。用关键字<strong>with</strong>就可以混入更多的trait。比如，狗除了是人类的好朋友，还是忠诚的卫士，会保护我们：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Guard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">guard</span></span>() = println(<span class="string">s" <span class="subst">$name</span> guards me!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> <span class="keyword">with</span> <span class="title">Guard</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> tom = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>)</span><br><span class="line"></span><br><span class="line">  tom.accompany()</span><br><span class="line"></span><br><span class="line">  tom.guard()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog类同时混入了HumanFriend和Guard两个trait，所以它可以调用这两个trait的方法。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>前面提过，scala中的trait可以理解为是java中接口和抽象类的组合。那么在接口中定义抽象类也是可以的了。现在我们将HumanFriend中的accompany方法改为抽象方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span> accompanies with me."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象方法需要在子类中提供实现。子类实现抽象方法时override关键字是可选的，但是建议最好加上。</p><h2 id="构造顺序"><a href="#构造顺序" class="headerlink" title="构造顺序"></a>构造顺序</h2><p>在网上看到了这段关于trait的构造顺序的描述，觉得有点儿意思就顺路转了过来。</p><p>trait也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该trait的对象在构造时都会被执行。</p><p>构造器的执行顺序：</p><ol><li>调用超类的构造器；</li><li>trait构造器在超类构造器之后、类构造器之前执行；</li><li>trait由左到右被构造；</li><li>每个trait当中，父trait先被构造；</li><li>如果多个trait共有一个父trait，父trait不会被重复构造</li><li>所有trait被构造完毕，子类被构造。</li></ol><p>构造器的顺序是类的线性化的反向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;不知道大家对java的接口是如何理解的。在我刚接触到接口这个概念的时候，我将接口理解为一系列规则的集合，认为接口是对类的行为的规范。现在想来
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://scala.chobit.org/wiki/20180527/a24-array/"/>
    <id>http://scala.chobit.org/wiki/20180527/a24-array/</id>
    <published>2018-05-27T14:04:05.000Z</published>
    <updated>2018-05-28T14:20:31.915Z</updated>
    
    <content type="html"><![CDATA[<p>简单说下scala中的数组。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>声明数组的语法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>]\(<span class="number">3</span>\)</span><br></pre></td></tr></table></figure></p><p>声明数组时必须指定数组的长度。数组的类型可以不指定，但是不指定的话，数组就是无用的，因为此时数组元素的类型是Nothing。</p><p>这样声明的数组其元素初始为字符串的默认值，即null。可以这样调整数组元素的值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr(<span class="number">0</span>) = <span class="string">"com"</span></span><br><span class="line">arr(<span class="number">1</span>) = <span class="string">"zhyea"</span></span><br><span class="line">arr(<span class="number">2</span>) = <span class="string">"robin"</span></span><br></pre></td></tr></table></figure></p><p>可以看到scala中获取数组元素的方法是：数组名 + 小括号 + 索引值。这里究其根本还是调用了Array类的apply(i:Int)方法，因此索引值也可以是一个表达式，比如arr(4/2)。</p><p>也可以在创建数组时完成初始化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>[<span class="type">String</span>](<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>调用object Array的ofDim方法可以创建一维到五维的数组。如下是一个创建二维数组的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matrix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>值的一提的是，在scala中本质上也是没有多维数组的。同java一样，所谓的多维数组其实质也是一维数组的嵌套（或者说是数组的数组）。这在object Array的二维数组的实现中可以很明显地看出来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ofDim</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]] = (<span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]](n1): <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]])</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n1) arr(i) = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](n2)</span><br><span class="line">  arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>这里说的变长数组就是ArrayBuffer。ArrayBuffer更应该被归类到集合里面，但是既然看到了就一起写出来好了。在使用方式上ArrayBuffer有些类似于java里的ArrayList，但是要更灵活一些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">  arr += <span class="number">1</span> <span class="comment">//尾端添加一个元素</span></span><br><span class="line"></span><br><span class="line">  arr ++= <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//尾端添加一个数组</span></span><br><span class="line"></span><br><span class="line">  arr += (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">// 尾端添加多个元素</span></span><br><span class="line"></span><br><span class="line">  println(arr.mkString(<span class="string">", "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5, 6, 7</span><br></pre></td></tr></table></figure></p><p>ArrayBuffer和Array可以互相转换，只需分别调用toArray()和toBuffer()方法即可。</p><h2 id="数组应用"><a href="#数组应用" class="headerlink" title="数组应用"></a>数组应用</h2><p>关于数组觉得比较有趣的一个应用是在和变量一起的使用的时候，比如下面：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(a, b, c) = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">println(a)</span><br><span class="line">println(b)</span><br><span class="line">println(c)</span><br></pre></td></tr></table></figure></p><p>代码中通过一个数组完成了a、b、c三个变量的赋值。</p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>至于数组其他的应用，如循环、拼接、copy等操作，在使用的时候可以翻看一下API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单说下scala中的数组。&lt;/p&gt;
&lt;h2 id=&quot;声明数组&quot;&gt;&lt;a href=&quot;#声明数组&quot; class=&quot;headerlink&quot; title=&quot;声明数组&quot;&gt;&lt;/a&gt;声明数组&lt;/h2&gt;&lt;p&gt;声明数组的语法：&lt;br&gt;&lt;figure class=&quot;highlight sca
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数组" scheme="http://scala.chobit.org/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://scala.chobit.org/wiki/20180521/a23-closure/"/>
    <id>http://scala.chobit.org/wiki/20180521/a23-closure/</id>
    <published>2018-05-21T14:36:43.000Z</published>
    <updated>2018-05-26T02:48:25.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于闭包的概念，我手边scala的书如是说：</p><blockquote><p>闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。  </p></blockquote><p>在维基百科中的说法是：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p></blockquote><p>前者说闭包是一个函数，后者说闭包是函数和自由变量一同构成的实体。我个人是比较倾向于后者的。不过细细思考下来，二者也没什么差别，都描述了闭包的几个特征：</p><ol><li>闭包中有一个特殊的<strong>函数</strong>；</li><li>存在一个<strong>封闭</strong>的作用域，函数就在这个封闭的作用域中；</li><li>在封闭作用域中存在一个函数作用域之外的变量（即<strong>自由变量</strong>）；</li><li>闭包函数<strong>绑定</strong>了这个自由变量。</li></ol><p>来看个关于闭包的程序：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line">println(func(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个方法foo()，方法foo中有一个局部变量i。正常情况下只有在执行foo方法的时候，局部变量i才会存在；foo方法执行完成后，局部变量i就会消失，不再有意义。不过现在在foo方法中定义了一个内部方法bar()，在bar方法中引用了foo方法的局部变量i，最后是将bar转为函数值作为foo方法的返回值。</p><p>这段代码中的bar函数绑定了它的作用域之外的变量i。按照前文的说明：bar函数和变量i共同构成了一个闭包。</p><p>现在想一下：<strong>调用foo方法返回的bar函数时，foo的局部变量i是否有效？</strong> 显然的，根据维基百科的解释，虽然foo方法已经执行结束，但是局部变量i仍然和函数bar一同存在，调用bar函数，i仍然有效。</p><p>执行这段代码看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(): Int =&gt; Int = &#123;</span><br><span class="line">     |     val i = 1</span><br><span class="line">     |</span><br><span class="line">     |     def bar(num: Int) = &#123;</span><br><span class="line">     |       i + num</span><br><span class="line">     |     &#125;</span><br><span class="line">     |</span><br><span class="line">     |     bar</span><br><span class="line">     |   &#125;</span><br><span class="line">foo: ()Int =&gt; Int</span><br><span class="line"></span><br><span class="line">scala&gt;  val func = foo()</span><br><span class="line">func: Int =&gt; Int = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; println(func(2))</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>代码的执行结果和前面的推论是一致的。</p><p>根据这段代码我们可以看到闭包的“闭”封闭的是函数的外部作用域。在这个例子中，封闭的就是bar函数外的foo方法的作用域。整个闭包只有一个对外的通道，即bar函数，我们可以通过bar函数来访问封闭的作用域的内容。  </p><p>再来说明下闭包定义中的<strong>绑定</strong>两个字。闭包中的绑定并不是获得闭包绑定自由变量的一份副本，而是直接绑定到变量本身。在闭包中对自由变量的调整会影响到闭包外部的自由变量；同样的，外部自由变量的变化，闭包也会受到影响。下面这个例子应该可以说明这一点：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): () =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line"></span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br></pre></td></tr></table></figure><p>在代码中定义了一个闭包。闭包中的自由变量是i，在函数bar中对自由变量i做了调整。在闭包外，三次调用了闭包函数。这段代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">对比输出结果我们可以看到：每次调用闭包函数bar都会对自由变量i产生影响；而自由变量i的变化，又会在下一次执行bar函数的时候发挥作用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 思考 - 对象和闭包</span><br><span class="line"></span><br><span class="line">看完了闭包的示例代码后，回过头来再思考一下闭包的概念：  </span><br><span class="line"></span><br><span class="line">&gt; 闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那根据这个概念，下面这段代码是不是闭包：</span><br><span class="line">```scala</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">  private val i = 1</span><br><span class="line"></span><br><span class="line">  def bar(num: Int): Int = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了，还是直接看这段代码吧：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">A</span>().bar(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里定义了一个类A，类A有一个私有变量i，这个变量i只能通过bar方法访问，换言之bar方法也是引用了一个它的作用域之外的变量i。那么class A这个结构应该也算是闭包喽！？</p><p>但是这里的bar方法需要通过类A的对象来调用，它本质上是类A的一个实例成员，而非是一个独立的函数；另外这里的bar方法引用的变量i是绑定在类A的对象上，而非绑定在bar方法上，所以从根本上这种形式就不满足闭包的定义，所以不是闭包！？</p><p>对于这样定义的类是否是闭包，以上是两种观点，也是我纠结之处。也查了些资料，然而各种说法莫衷一是。思考了一段时间后决定停止这种纠结，仅从一点出发：<strong>只在函数作为头等公民的语境中来讨论闭包</strong>。</p><p>对象和函数各有自己不同的使用场景。在scala这种既支持函数又面向对象的语言中，使用对象可以减少一些复杂度，使用函数可以提升一些灵活性。但是把函数的概念放到面向对象的语境中，或者反过来都是没有意义的事情。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前想到的关于的闭包的用法主要有两种：一种是将闭包作为返回值，就如前面的例子；另一种是将闭包作为参数，如下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(f: (<span class="type">Int</span>) =&gt; <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>)</span><br><span class="line">  arr.filter(f).foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bar = (num: <span class="type">Int</span>) =&gt; num &gt; max</span><br><span class="line"></span><br><span class="line">foo(bar)</span><br></pre></td></tr></table></figure></p><p>又想到了一个应用场景，比如在一些对于面向对象支持不是很好的语言，可以用闭包来构建对象（用scala来举这个例子，有些费力，懒得写了）。严格来说，这种用法也是将函数用作闭包的返回值。</p><p>另外scala的curry化也是闭包的一种应用。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在知乎上有各路大神对闭包进行了讨论，有兴趣可以看一下：<a href="https://www.zhihu.com/question/34210214" rel="external nofollow noopener noreferrer" target="_blank">什么是闭包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;关于闭包的概念，我手边scala的书如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://scala.chobit.org/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Executor Aroud模式</title>
    <link href="http://scala.chobit.org/wiki/20180520/a22-executorAroudMode/"/>
    <id>http://scala.chobit.org/wiki/20180520/a22-executorAroudMode/</id>
    <published>2018-05-19T23:15:02.000Z</published>
    <updated>2018-05-19T23:35:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。</p><p>在scala里可以用函数值实现这种模式。下面是一个示例，使用Resource类演示了事务的开启和释放：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"Starting transaction..."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">cleanUp</span></span>() &#123;</span><br><span class="line">    println(<span class="string">"Ending transaction..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op1</span> </span>= println(<span class="string">"Operation 1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op2</span> </span>= println(<span class="string">"Operation 2"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op3</span> </span>= println(<span class="string">"Operation 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(codeBlock: <span class="type">Resource</span> =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = <span class="keyword">new</span> <span class="type">Resource</span> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codeBlock(resource)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resource.cleanUp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里将Resource类的构造器标记为private，这样就只能在Resource类内部和它的伴生类中创建实例。因为只能在这两个地方创建实例，就可以保证按照确定的方式使用这个类的对象，即可以保证其行为是按照确定的方式执行。cleanUp()方法也被标记为private，确保不会被意外调用。Resource类第一行的print语句是具体事务操作的占位符。调用构造函数时，事务启动；调用cleanUp()函数时，事务终结。此外Resource类中还准备了一些实例方法，如op1()、op2()等。</p><p>在伴生对象里有一个默认public的方法use，它接收一个函数值作为参数。use()方法创建了一个Resource的实例，在try和finally块的保护之下，把这个实例传给了给定的函数值。在finally块里，调用了Resource私有实例方法cleanUp()。</p><p>看一下是如何使用Resource类的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span>.use &#123; resource =&gt;</span><br><span class="line">  resource.op1</span><br><span class="line">  resource.op2</span><br><span class="line">  resource.op3</span><br><span class="line">  resource.op1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting transaction...</span><br><span class="line">Operation 1</span><br><span class="line">Operation 2</span><br><span class="line">Operation 3</span><br><span class="line">Operation 1</span><br><span class="line">Ending transaction...</span><br></pre></td></tr></table></figure><p>调用Resource的伴生对象的use方法时，会自动创建一个Resource实例，等到传递的函数值执行结束后，会自动调用cleanUp方法释放占用的资源。</p><p>上面模式的一个变体是Loan（借贷）模式。如果想确保非内存资源得到确定性释放，就可以使用这个模式。可以这样认为：这种资源密集型的对象是借给你的，用过之后应该立即归还。</p><p>下面是一个Loan模式的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeToFile</span></span>(fileName: <span class="type">String</span>)(codeBlock: <span class="type">PrintWriter</span> =&gt; <span class="type">Unit</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(fileName))</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    codeBlock(writer)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调用writeToFile()将一些内容写入文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeToFile(<span class="string">"output.txt"</span>) &#123; writer =&gt; writer write <span class="string">"hello from Scala"</span> &#125;</span><br></pre></td></tr></table></figure><p>这行这段代码会创建一个名为output.txt的文件，并在文件中写入一行文字“hello from Scala”。</p><p>作为writeToFile()方法的使用者，我们不必操心文件的关闭。在代码块里，这个文件是借给我们用的。我们可以用得到的PrintWriter实例进行写操作，一旦从这个块返回，方法就会自动关闭文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。&lt;/p&gt;
&lt;p&gt;在scala里可
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线和参数</title>
    <link href="http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/"/>
    <id>http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/</id>
    <published>2018-05-19T14:01:50.000Z</published>
    <updated>2018-05-19T14:11:57.033Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123; (sum, elem) =&gt; sum + elem &#125;)</span><br></pre></td></tr></table></figure><p>上面的代码里使用了“/:”方法。这个方法的意思大致上是从数组的左侧开始迭代运算。这里是用来计算数组中所有元素的和。因为在函数值中sum和elem只用了一次，所以这个函数也可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123;_+_&#125; )</span><br></pre></td></tr></table></figure><p>其中第一个“<em>”就是sum，即用来迭代运算的值；第二个“</em>”表示的是数组中的元素。这里是一处让人比较纠结的地方，这样做会让代码过于简洁，有时甚至让人费解。如果能在不失可读性又足够简洁的地方使用就最好了，来看一下下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> negativeNumberExists = arr.exists &#123; _ &lt; <span class="number">0</span> &#125;</span><br><span class="line">println(<span class="string">"Array has negative number? "</span> + negativeNumberExists)</span><br></pre></td></tr></table></figure></p><p>这里的代码用来查找数组中是否有小于0的元素。</p><p>在某些有意义的地方，这种简洁还可以更进一步。比如说我们想从一个数组中找出最大值。从这个需求出发，我们会一步步地简化实现的函数。最开始是这个样子的，我们使用了“/:”方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    a</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; (large, ele) =&gt; max(large, ele) &#125;)</span><br></pre></td></tr></table></figure><p>用下划线表示函数值参数来做一次简化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max(_, _) &#125;)</span><br></pre></td></tr></table></figure><p>“_”不仅可以表示一个参数，还可以表示整个参数列表。所以可以继续简化成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max _ &#125;)</span><br></pre></td></tr></table></figure><p>在上面的代码里，“_”表示整个参数列表。如果只是把参数传递给下层的方法，甚至可以省下使用“_”。上面的代码可以最终简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max &#125;)</span><br></pre></td></tr></table></figure><p>可以看到，依赖类型推断，scala的简洁到了丧心病狂（无贬义）的程度。这也给开发者留下了一个难题：需要适当克制自己简化代码的欲望，留下适当的可读性，不让代码变成天书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="下划线" scheme="http://scala.chobit.org/tags/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Curry化</title>
    <link href="http://scala.chobit.org/wiki/20180518/a21-currying/"/>
    <id>http://scala.chobit.org/wiki/20180518/a21-currying/</id>
    <published>2018-05-17T23:11:16.000Z</published>
    <updated>2018-05-28T22:27:42.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。</p><p>scala里的curry化可以把函数从接收多个参数转换成接收多个参数列表。也就是说我们写的多参数函数不再只是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>) &#123;???&#125;</span><br></pre></td></tr></table></figure></p><p>而是可以这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>或者这样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>甚至是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>来看个实例好了，下面的代码中定义了一个inject方法。inject方法有三个参数，两个Int型的参数，一个函数值参数。方法体中通过传入的函数对前两个Int型参数进行运算：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>, (a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure></p><p>在代码的最后一行还写了调用inject方法的一个示例。</p><p>有的时候可能会觉得把普通参数和函数值参数放在一起有点儿怪怪的。现在用curry化的方法将函数值参数独立开来：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>)(op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>) &#123; (a, b) =&gt; a + b &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到不管是在定义方式还是在使用方式上，代码都清爽了许多。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从方法的角度来看，Curry化只是一个语法糖，对方法的功能没有任何影响。    </p><p>将方法转为函数使用时，Curry化的影响就出现了。在scala解释器里看一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def inject(a: Int, b: Int, op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int, op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br></pre></td></tr></table></figure></p><p>我们在解释器里def了没有做Curry化的inject方法，并用“_”将inject方法转为函数。此时inject方法转成的函数是一个有三个参数的普通函数。  </p><p>再来看看Curry化后的inject方法转成的函数是怎样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;   def inject(a: Int, b: Int)(op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int)(op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>将两次生成的函数值对象res0和res1放在一起比较一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curry化之前： res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br><span class="line">Curry化之后： res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>inject方法Curry化之前转成的函数res0是一个三参数函数，继承自trait Function3；Curry化之后转成的函数res1是一个双参数函数，继承自trait Function2。  </p><p>用ABC来表示下inject方法的参数也许更直观些。inject方法最初为：inject(A, B, C)； curry化以后的结构是为：inject(A, B)(C)。inject方法curry化以后对应的函数res1为：</p><blockquote><p>(A, B)=&gt; (C)=&gt; Int</p></blockquote><p>可以看到res1实质上是被分解多个函数，inject方法的每个参数列表都对应一个函数，几个函数按参数列表顺序从右到左逐层嵌套，最左侧的参数列表即为最外侧的函数的参数。  </p><p>以上的内容说的是对方法进行Curry化。Scala也支持对函数进行Curry化。scala的多参数函数trait，包括Function2 ~ FuntionN都有一个curried方法，用来将函数的每个参数进行curry化。下面的代码是Function3的curried方法的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curried</span></span>: <span class="type">T1</span> =&gt; <span class="type">T2</span> =&gt; <span class="type">T3</span> =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">  (x1: <span class="type">T1</span>) =&gt; (x2: <span class="type">T2</span>) =&gt; (x3: <span class="type">T3</span>) =&gt; apply(x1, x2, x3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在curried方法中，Function3的每个参数都被拆分成一个独立的参数列表，每个参数列表对应的函数逐层嵌套形成了新的函数。</p><p>调用下前面的函数res1的curried方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res1.curried</span><br><span class="line">res2: Int =&gt; (Int =&gt; (((Int, Int) =&gt; Int) =&gt; Int)) = &lt;function1&gt;</span><br></pre></td></tr></table></figure></p><p>res1调用curried方法后生成的新函数res2类型为Function1，并且函数体又多了一层嵌套。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Curry化的本质是将多参数函数转为多个单参数函数的级联，以便于进行lambda运算——这是官方的说法。  </p><p>说下自己的理解：Curry化更多的情况下是一种语法糖而已，和部分应用函数一样，在scala中并不是一种支撑性的角色。我们可以将多个单参数函数组合在一起，也可以使用函数递归来解决一些特定的问题，但是不必要将这种用法称为curry化。当然，这只是我的一偏之见。如有不同意见，欢迎一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。&lt;/p&gt;
&lt;p&gt;scala里的curry化可以把函数从接收
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="柯里化" scheme="http://scala.chobit.org/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
      <category term="Curry化" scheme="http://scala.chobit.org/tags/Curry%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180516/c01-particialFuncion/"/>
    <id>http://scala.chobit.org/wiki/20180516/c01-particialFuncion/</id>
    <published>2018-05-15T23:01:16.000Z</published>
    <updated>2018-05-15T23:12:52.038Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><p>至于为什么会抛出这个异常，因为scala的语言太过简洁，有必要看一下对这个类的字节码文件反编译后的结果，其中主要是看一下偏函数find的实现。使用scalac完成编译后，可以看到生成了三个字节码文件：</p><blockquote><p>MyFunc$$anonfun$1.class<br>MyFunc$.class<br>MyFunc.class</p></blockquote><p>使用jd-gui打开MyFunc$.class可以看到find的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.find = <span class="keyword">new</span> AbstractPartialFunction.mcLI.sp() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;A1, B1&gt; <span class="function">B1 <span class="title">applyOrElse</span><span class="params">(A1 x1, Function1&lt;A1, B1&gt; <span class="keyword">default</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        Object localObject;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) localObject = <span class="string">"It's Target."</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            localObject = <span class="keyword">default</span>.apply(BoxesRunTime.boxToInteger(x1));</span><br><span class="line">        <span class="keyword">return</span> localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDefinedAt</span><span class="params">(<span class="keyword">int</span> x1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        <span class="keyword">boolean</span> bool;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) bool = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/yuanguangyu1221/article/details/71307664" rel="external nofollow noopener noreferrer" target="_blank">偏函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/20832218?refer=insight" rel="external nofollow noopener noreferrer" target="_blank">scala中的Partial Function</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是一个偏函数的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
      <category term="scala探索" scheme="http://scala.chobit.org/categories/scala%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180508/a20-partialFunction/"/>
    <id>http://scala.chobit.org/wiki/20180508/a20-partialFunction/</id>
    <published>2018-05-07T22:46:47.000Z</published>
    <updated>2018-05-17T15:14:18.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>scala的部分应用函数英文名为Partial Apply Function。此外，还有一个英文名为Partial Function的概念，即偏函数。</p><p>普通的函数会处理输入参数的全量的值，而偏函数只会处理输入参数中部分特定的值。  </p><p>偏函数在实现上有如下特征：  </p><ul><li>需要显示声明类型，类型为PartialFunction[-A, +B]，其中A为输入类型，B为输出类型；</li><li>输入参数只有一个，且输入类型已在PartialFunction的类型声明中指出，所以在声明偏函数的时候不需要像声明普通函数一样指明参数列表；</li><li>通常由包围在花括号中的一个或多个case语句构成，且花括号不可省略。</li></ul><p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><h2 id="组合运算"><a href="#组合运算" class="headerlink" title="组合运算"></a>组合运算</h2><p>scala提供了几个组合方法可以将两个偏函数组合在一起使用。常用的组合方法有：orElse、andThen和compose，现在分别看一下。</p><h3 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h3><p>orElse方法是在trait PartialFunction中定义的方法。使用orElse方法，可以在无法匹配一个偏函数的时候继续尝试匹配下一个。下面是一个使用orElse组合偏函数判断奇偶的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is odd."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findEven: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> check = findEven orElse findOdd</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(check(<span class="number">9</span>))</span><br><span class="line">    print(check(<span class="number">10</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个偏函数使用orElse方法组合后形成一个新的偏函数，并赋值给变量check。</p><p>代码中的check函数的作用等同于如下的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">  num <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>) =&gt; <span class="string">s"<span class="subst">$num</span> is odd."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序的执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 is odd.</span><br><span class="line">10 is even.</span><br></pre></td></tr></table></figure></p><p>使用orElse方法还可以直接组合case语句：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd orElse &#123;</span><br><span class="line">  <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的case语句被scala直接包装为偏函数来处理了。</p><h3 id="andThen"><a href="#andThen" class="headerlink" title="andThen"></a>andThen</h3><p>如果说orElse方法是将两个偏函数并联在一起，那么andThen方法就是将两个偏函数串联在了一起。经过andThen串联后，上一个函数的输出内容即是下一个函数的输入内容。最初的输入参数必须能够匹配所有被andThen串联在一起的偏函数，否则就会报scala.MatchError错误。</p><p>来看一个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findGreaterThanTen: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">10</span> =&gt; <span class="string">s"<span class="subst">$num</span> is greater than 10."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd andThen findGreaterThanTen</span><br><span class="line"></span><br><span class="line">  println(check(<span class="number">17</span>))</span><br><span class="line">  println(check(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中的两个偏函数被andThen方法串联起来构成了check函数，check函数要求输入的整型数值满足findOdd即为奇数，且满足findGreaterThanTen即大于10。  </p><p>在验证部分输入了两个数值17和7。为check函数输入17可以正常执行，输入7则会在执行到findGreaterThanTen时报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17 is odd.</span><br><span class="line">17 is greater than 10.</span><br><span class="line">7 is odd.</span><br><span class="line">scala.MatchError: 7 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$2.applyOrElse(MyFunc.scala:9)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$2.applyOrElse(MyFunc.scala:9)</span><br></pre></td></tr></table></figure></p><p>andThen方法并不是只在trait PartialFunction中定义了，而是继承自trait Function1并重写的。所以也可以使用andThen方法串联一个普通函数——只要输入类型匹配即可。看个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = (num: <span class="type">Int</span>) =&gt; <span class="string">s"<span class="subst">$num</span> hasn't been checked."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd andThen func</span><br><span class="line"></span><br><span class="line">println(check(<span class="number">17</span>))</span><br><span class="line">println(check(<span class="number">7</span>))</span><br></pre></td></tr></table></figure></p><p>执行后输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17 is odd.</span><br><span class="line">17 hasn&apos;t been checked.</span><br><span class="line">7 is odd.</span><br><span class="line">7 hasn&apos;t been checked.</span><br></pre></td></tr></table></figure></p><p>同样的andThen也可以组合case语句。不过懒得再写了， 有兴趣的话可以自己试试看。</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>compose方法也是trait PartialFunction继承自Function1的。PartialFunction甚至没有override这个方法。  </p><p>compose方法的作用的也是将两个偏函数串联在一起。不过compose串联的方向和andThen串联的方向相反。  </p><p>再用compose串联一下前面创建的findOdd和findGreaterThanTen两个偏函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findGreaterThanTen: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">10</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is greater than 10."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd compose findGreaterThanTen</span><br><span class="line"></span><br><span class="line">  println(check(<span class="number">17</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17 is greater than 10.</span><br><span class="line">17 is odd.</span><br><span class="line">17</span><br></pre></td></tr></table></figure></p><p>通过结果可以看出来使用compose组合后，先执行的是findGreaterThanTen函数。使用andThen组合时，先执行的则是findOdd函数。从trait Function1的定义中可以很清楚地看清这两个方法的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>](g: <span class="type">A</span> =&gt; <span class="type">T1</span>): <span class="type">A</span> =&gt; <span class="type">R</span> = &#123; x =&gt; apply(g(x)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">A</span>](g: <span class="type">R</span> =&gt; <span class="type">A</span>): <span class="type">T1</span> =&gt; <span class="type">A</span> = &#123; x =&gt; g(apply(x)) &#125;</span><br></pre></td></tr></table></figure></p><p>一个是apply(g(x))、一个是g(apply(x))，正好是相反的。</p><p>因为compose是在trait Function1实现的，所以它也可以用来组合普通函数。同样因为PartialFunction继承自Function1，所以compose也可以组合case语句。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单说下我对偏函数的理解：如果说普通函数是一个细粒度的操作，那么偏函数又对一个操作做了更细粒度的切分——将一个操作的不同分支切分了出来。   </p><p>示例中使用的几个函数都比较简单，所以使用组合方法组合显得有些意义不大。但是假想一个函数的业务比较复杂时，而又存在多个分支，如果这些分支的业务都写在一个函数内，那就不如使用偏函数恰当了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;scala的部分应用函数英文名为Partial Apply Function。此外，还有一个英文名为Partial Function的概念，
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>部分应用函数</title>
    <link href="http://scala.chobit.org/wiki/20180507/a19-partialApplyFunction/"/>
    <id>http://scala.chobit.org/wiki/20180507/a19-partialApplyFunction/</id>
    <published>2018-05-06T22:50:33.000Z</published>
    <updated>2018-05-08T23:01:33.288Z</updated>
    
    <content type="html"><![CDATA[<p>scala的部分应用函数（也可以成为偏应用函数），是一种特殊的表达式。使用部分应用函数让我们在调用一个方法时可以不必提供全部的参数，只需要提供部分参数，或者完全不提供参数。</p><p>先来看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialApplyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">    log(date, <span class="string">"message1"</span>)</span><br><span class="line">    log(date, <span class="string">"message2"</span>)</span><br><span class="line">    log(date, <span class="string">"message2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$date</span> : <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段代码中，连续调用了log方法三次，每次传入的参数中date是相同的，message是不同的。<br>要避免每次都输入这个相同的参数date可以考虑使用部分应用函数。部分应用函数要解决的问题就是：在一个比较小的作用域内连续调用一个已有方法或函数时，避免重复输入相同的参数。  </p><p>用部分应用函数重构下刚才的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialApplyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logWithDateBound = log(date, _: <span class="type">String</span>) <span class="comment">//需要提供的参数必须使用通配符，不可用参数名</span></span><br><span class="line"></span><br><span class="line">    logWithDateBound(<span class="string">"message1"</span>)</span><br><span class="line">    logWithDateBound(<span class="string">"message2"</span>)</span><br><span class="line">    logWithDateBound(<span class="string">"message2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$date</span> : <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重构后的代码中定义了一个logWithDateBound函数，并为这个函数绑定了第一个date参数，然后用下划线(_)替换缺失的参数列表。</p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mon May 07 07:29:05 CST 2018 : message1</span><br><span class="line">Mon May 07 07:29:05 CST 2018 : message2</span><br><span class="line">Mon May 07 07:29:05 CST 2018 : message2</span><br></pre></td></tr></table></figure></p><p>通过反编译后的代码查看下logWithBound的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function1 logWithDateBound = <span class="keyword">new</span> AbstractFunction1() &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date date$<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String x$<span class="number">1</span>)</span> </span>&#123; PartiallyFunc..MODULE$.log(<span class="keyword">this</span>.date$<span class="number">1</span>, x$<span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在反编译后的代码中看到logWithDateBound的类型是Function1，apply方法参数类型为String，可知logWithDateBound函数是一个类型为(String)=&gt;Unit函数值。</p><p>再来总结一次：部分应用函数是在已有函数的基础上，提供部分默认参数，未提供默认参数的地方使用“_”替代，从而创建出一个函数值，在使用这个函数值（部分应用函数）的时候，只需提供“_”部分对应的参数即可。</p><p>关于部分应用函数还可以多想想的一点就是与在函数或方法中指定参数默认值的区别。</p><p>部分应用函数的作用就体现在“部分”两个子上。定义部分应用函数时，提供全部参数或者是不提供任何参数都有画蛇添足的嫌疑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的部分应用函数（也可以成为偏应用函数），是一种特殊的表达式。使用部分应用函数让我们在调用一个方法时可以不必提供全部的参数，只需要提供部分参数，或者完全不提供参数。&lt;/p&gt;
&lt;p&gt;先来看一段代码：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala字符串插值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b012-stringInterpolation/"/>
    <id>http://scala.chobit.org/wiki/20180506/b012-stringInterpolation/</id>
    <published>2018-05-06T11:02:07.000Z</published>
    <updated>2018-05-06T23:11:10.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符中。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>在上例中， s”Hello,$name” 是待处理字符串字面，编译器会对它做额外的工作。待处理字符串字面通过“号前的字符来标示（例如：上例中是s）。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Scala 提供了三种创新的字符串插值方法：s,f 和 raw.</p><h3 id="s-字符串插值器"><a href="#s-字符串插值器" class="headerlink" title="s 字符串插值器"></a>s 字符串插值器</h3><p>在任何字符串前加上s，就可以直接在串中使用变量了。你已经见过这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>此例中，$name嵌套在一个将被s字符串插值器处理的字符串中。插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。  </p><p>字符串插值器也可以处理任意的表达式。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">s"1+1=<span class="subst">$&#123;1+1&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>将会输出字符串1+1=2。任何表达式都可以嵌入到${}中。</p><h3 id="f-插值器"><a href="#f-插值器" class="headerlink" title="f 插值器"></a>f 插值器</h3><p>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数。当使用 f 插值器的时候，所有的变量引用都应当后跟一个printf-style格式的字符串，如%d。看下面这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">f"<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall"</span>)<span class="comment">//James is 1.90 meters tall</span></span><br></pre></td></tr></table></figure></p><p>f 插值器是类型安全的。如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val height:Double=1.9d</span><br><span class="line"></span><br><span class="line">scala&gt;f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">&lt;console&gt;:9: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found : Double</span><br><span class="line"> required: Int</span><br><span class="line">           f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">              ^ f</span><br></pre></td></tr></table></figure><p>插值器利用了java中的字符串数据格式。这种以%开头的格式在 [Formatter javadoc] 中有相关概述。如果在具体变量后没有%，则格式化程序默认使用 %s（串型）格式。</p><h3 id="raw-插值器"><a href="#raw-插值器" class="headerlink" title="raw 插值器"></a>raw 插值器</h3><p>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的。如下是个被处理过的字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;s<span class="string">"a\nb"</span></span><br><span class="line">res0:String=</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><p>这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;raw<span class="string">"a\nb"</span></span><br><span class="line">res1:String=a\nb</span><br></pre></td></tr></table></figure></p><p>当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。  </p><p>除了以上三种字符串插值器外，使用者可以自定义插值器。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>在Scala中，所有处理过的字符串字面值都进行了简单编码转换。任何时候编译器遇到一个如下形式的字符串字面值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">id"string content"</span></span><br></pre></td></tr></table></figure></p><p>它都会被转换成一个StringContext实例的call(id)方法。这个方法在隐式范围内仍可用。只需要简单得建立一个隐类，给StringContext实例增加一个新方法，便可以定义我们自己的字符串插值器。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：为了避免运行时实例化，我们从AnyVal中继承。</span></span><br><span class="line"><span class="comment">//更多信息请见值类的说明</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=sys.error(<span class="string">"TODO-IMPLEMENT"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveMeSomeJson</span></span>(x:<span class="type">JSONObject</span>):<span class="type">Unit</span>=...</span><br><span class="line"></span><br><span class="line">giveMeSomeJson(<span class="string">json"&#123;name:<span class="subst">$name</span>,id:<span class="subst">$id</span>&#125;"</span>)</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们试图通过字符串插值生成一个JSON文本语法。隐类JsonHelper作用域内使用该语法，且这个JSON方法需要一个完整的实现。只不过，字符串字面值格式化的结果不是一个字符串，而是一个JSON对象。<br>当编译器遇到“{name:\$name, id:\$id”}”，它将会被重写成如下表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>).json(name,id)</span><br></pre></td></tr></table></figure></p><p>隐类则被重写成如下形式<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">JsonHelper</span>(<span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>)).json(name,id)</span><br></pre></td></tr></table></figure></p><p>所以，JSON方法可以访问字符串的原生片段而每个表达式都是一个值。这个方法的一个简单但又令人迷惑的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=&#123;</span><br><span class="line">    <span class="keyword">val</span> strings=sc.parts.iterator</span><br><span class="line">    <span class="keyword">val</span> expressions=args.iterator</span><br><span class="line">    <span class="keyword">var</span> buf=<span class="keyword">new</span> <span class="type">StringBuffer</span>(strings.next)</span><br><span class="line">    <span class="keyword">while</span>(strings.hasNext)&#123;</span><br><span class="line">      buf append expressions.next</span><br><span class="line">      buf append strings.next</span><br><span class="line">    &#125;</span><br><span class="line">    parseJson(buf)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被处理过的字符串的每部分都是StringContext的成员。每个表达式的值都将传入到JSON方法的args参数。JSON方法接受这些值并合成一个大字符串，然后再解析成JSON格式。有一种更复杂的实现可以避免合成字符串的操作，它只是简单的直接通过原生字符串和表达式值构建JSON。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>字符串插值目前对模式匹配语句不适用。此特性将在2.11版本中生效。</p><p>本文转载自：<a href="https://docs.scala-lang.org/zh-cn/overviews/core/string-interpolation.html" rel="external nofollow noopener noreferrer" target="_blank">字符串插值</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>带名称的参数值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b011-namedParam/"/>
    <id>http://scala.chobit.org/wiki/20180506/b011-namedParam/</id>
    <published>2018-05-06T11:00:40.000Z</published>
    <updated>2018-05-06T11:14:06.543Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一段代码，看看执行后会输出什么：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">showValue</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"x is <span class="subst">$x</span>"</span>)</span><br><span class="line">    println(<span class="string">s"y is <span class="subst">$y</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  showValue(y = <span class="number">3</span>, x = <span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码看了以后第一反应是会报错。我将最后一行“showValue(y = 3, x = 6)”中的“y=3”和“x=3”看做简单赋值语句了。scala中赋值语句返回值为Unit，所以执行代码会报类型不匹配的错误。</p><p>然而我错了。  </p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x is 6</span><br><span class="line">y is 3</span><br></pre></td></tr></table></figure></p><p>最后一行代码中的“y=3”和“x=3”的确是赋值语句，更准确的说法是根据参数名称显式赋值。传递给方法的值就是赋给参数的值，而非Unit。  </p><p>一般情况下调用方法或函数，就按照函数定义时的参数顺序一个个传递。但是也可以通过指定参数名赋值，并且不需要按照定义时的顺序向函数传递参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看一段代码，看看执行后会输出什么：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数默认值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b010-defaultParamValue/"/>
    <id>http://scala.chobit.org/wiki/20180506/b010-defaultParamValue/</id>
    <published>2018-05-06T10:45:01.000Z</published>
    <updated>2018-05-06T10:56:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>Scala可以为方法参数指定默认值。<br>使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。</p><p>举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no</span></span>(no: <span class="type">Int</span> = <span class="number">1</span>) = no</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Default No. is "</span> + no())</span><br><span class="line"></span><br><span class="line">println(<span class="string">"This No. is "</span> + no(<span class="number">9</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Default No. is 1</span><br><span class="line">This No. is 9</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala可以为方法参数指定默认值。&lt;br&gt;使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数中的 =&gt;U 和 ()=&gt;U</title>
    <link href="http://scala.chobit.org/wiki/20180506/b009-callByNameAndFunctionValue/"/>
    <id>http://scala.chobit.org/wiki/20180506/b009-callByNameAndFunctionValue/</id>
    <published>2018-05-06T10:06:30.000Z</published>
    <updated>2018-05-06T11:23:54.888Z</updated>
    
    <content type="html"><![CDATA[<p>在scala参数中会遇到=&gt;U 或者 ()=&gt;U。U表示返回值类型。简单说下二者的区别。  </p><p>=&gt;U是一个传名参数，表示一个无参方法。  </p><p>()=&gt;U则是一个函数。</p><p>举个例子，看一下二者的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mTime</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> fTime = ()=&gt;<span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t1: =&gt; <span class="type">Long</span>, t2: ()=&gt;<span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t1</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$&#123;t2()&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(mTime, fTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于方法和函数的关系可以参考<a href="/wiki/20180501/a15-methodVsFunction/">之前的一篇文</a>。  </p><p>还有篇关于传名参数的文：<a href="/wiki/20180506/a18-callByName/">传名参数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala参数中会遇到=&amp;gt;U 或者 ()=&amp;gt;U。U表示返回值类型。简单说下二者的区别。  &lt;/p&gt;
&lt;p&gt;=&amp;gt;U是一个传名参数，表示一个无参方法。  &lt;/p&gt;
&lt;p&gt;()=&amp;gt;U则是一个函数。&lt;/p&gt;
&lt;p&gt;举个例子，看一下二者的区别：&lt;br&gt;&lt;fi
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>传名参数 =&gt;Unit</title>
    <link href="http://scala.chobit.org/wiki/20180506/a18-callByName/"/>
    <id>http://scala.chobit.org/wiki/20180506/a18-callByName/</id>
    <published>2018-05-05T23:09:35.000Z</published>
    <updated>2018-05-06T10:59:30.758Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的解释器在解析函数参数(function arguments)时有两种方式：</p><ul><li>传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；</li><li>传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部。</li></ul><p>以上是比较严谨的说法。简单解释下，传值调用就是我们常见的方法调用方式，将一个值作为参数传递给方法或函数。java中的方法都是传值调用。传名调用，则是将一个方法作为参数传递给其他方法或函数。</p><p>传名调用的参数是方法而非函数，且要求作为参数的方法的参数为空。</p><p>来看一个传名参数的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">time</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t: =&gt; <span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$t</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结下传名参数的优势：</p><ul><li>进行实时运算；</li><li>如果没有被用到，就可以不必进行运算。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala的解释器在解析函数参数(function arguments)时有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；&lt;/li&gt;
&lt;li&gt;传名调用（call-by-name）：将未计算的参数表达式直
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于import</title>
    <link href="http://scala.chobit.org/wiki/20180505/a17-aboutImport/"/>
    <id>http://scala.chobit.org/wiki/20180505/a17-aboutImport/</id>
    <published>2018-05-05T14:56:26.000Z</published>
    <updated>2018-05-05T15:02:11.940Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几个import相关的特性</p><ul><li><p>特性一: 用import com.zhyea._这种格式，可以导入包下所有的成员</p></li><li><p>特性二: 与java不同，scala在任何地方都可以使用import，比如类内、方法内：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">import</span> com.zhyea.service._</span><br><span class="line">        <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">MyService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处在于，可以在一定作用域范围内使用导入</p><ul><li><p>特性三: 选择器、重命名、隐藏</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> &#125; \\仅仅导入com.zhyea.service包下的<span class="type">MyService</span>类，其它不导入</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> =&gt; <span class="type">MyServiceImpl</span> &#125; \\将导入的类进行重命名</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> =&gt; _, _ &#125; \\导入com.zhyea.service包下所有的类，但是隐藏掉<span class="type">MyService</span>类</span><br></pre></td></tr></table></figure></li></ul><ul><li>特性四: 隐式导入</li></ul><p>每个scala程序默认都会隐式导入以下几个包下所有的成员</p><blockquote><p>import java.lang._<br>import scala._<br>import Predef._</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍几个import相关的特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特性一: 用import com.zhyea._这种格式，可以导入包下所有的成员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特性二: 与java不同，scala在任何地方都可以使用import，比如类内、方法内：&lt;/p
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线的作用</title>
    <link href="http://scala.chobit.org/wiki/20180505/b008-usageOfUnderscore/"/>
    <id>http://scala.chobit.org/wiki/20180505/b008-usageOfUnderscore/</id>
    <published>2018-05-05T10:22:46.000Z</published>
    <updated>2018-05-05T11:31:33.231Z</updated>
    
    <content type="html"><![CDATA[<p>相关概念暂未能了解，提供两个参考文档：</p><blockquote><p><a href="https://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala" rel="external nofollow noopener noreferrer" target="_blank">Usage of Underscore In Scala</a><br><a href="https://www.zhihu.com/question/21622725" rel="external nofollow noopener noreferrer" target="_blank">Scala中下划线的应用场景</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相关概念暂未能了解，提供两个参考文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-sc
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>package的使用</title>
    <link href="http://scala.chobit.org/wiki/20180505/a16-usingOfPackage/"/>
    <id>http://scala.chobit.org/wiki/20180505/a16-usingOfPackage/</id>
    <published>2018-05-05T10:16:34.000Z</published>
    <updated>2018-05-05T15:12:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>这一节介绍一些关于package的内容。本来不想写关于package的内容的，因为一开始觉得没啥好写的。这次写因为发现了点儿可以写的内容。</p><h2 id="package定义"><a href="#package定义" class="headerlink" title="package定义"></a>package定义</h2><p>scala中package定义有如下几种方式：</p><h3 id="在文件顶部定义。"><a href="#在文件顶部定义。" class="headerlink" title="在文件顶部定义。"></a>在文件顶部定义。</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea.robin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br></pre></td></tr></table></figure><p>这种方式和java相同。  </p><h3 id="多层级package定义"><a href="#多层级package定义" class="headerlink" title="多层级package定义"></a>多层级package定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com&#123;</span><br><span class="line">    <span class="keyword">package</span> zhyea&#123;</span><br><span class="line">        <span class="keyword">package</span> robin&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这种定义方式比较繁琐，通常都不会采用。</p><h3 id="串联式package定义"><a href="#串联式package定义" class="headerlink" title="串联式package定义"></a>串联式package定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea&#123;</span><br><span class="line">    <span class="keyword">package</span> robin&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">package</span> <span class="title">tom</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方式算是上一种方式的优化版。  </p><p>有的时候我们需要定义几个结构比较简单的class，又不可以将之放在同一个package下，就可以采用这种方案。</p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h3><p>定义package的时候还可以把第一种方式和第二或第三种方式组合起来使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> robin&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">tom</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="package特性"><a href="#package特性" class="headerlink" title="package特性"></a>package特性</h2><p>比较起Java来，scala的package定义有许多特别的地方：</p><ol><li>scala的包定义不受源文件所在目录结构的限制；</li><li>同一个包的定义是可以在不同的源文件中的；</li><li>同一个源文件中是可以存在多个包的。</li></ol><p>java的包声明和文件系统关联比较紧密，比如java的一个public类com.zhyea.Test，我们就可以判断出这个类的源文件是在类路径的com/zhyea路径下。</p><p>scala的包声明不受文件系统的限制，比如一个位于com/zhyea路径下的scala源文件，其顶端的包声明完全可以是“package org.chobit”。另外scala也并不要求源文件的名称要与类名相同。</p><p>根据前面说到的第三种和第四种包定义方式，一个文件中存在多个包是没有问题的。另外一个源文件中定义的多个包可以互相没有任何关系，比如下面这样的定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">org</span>.<span class="title">chobit</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这里定义的两个package不必一定要有相同的父级包。</p><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><p>先来看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> scala &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">      <span class="keyword">val</span> list = <span class="keyword">new</span> scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] <span class="comment">//会在此处报错，使用了相对路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码会在标明的位置报错。因为scala默认会在当前位置向上的相对路径中去找相关的类。在标明会报错的那一行的父级包正好是scala，所以实际上声明的list是这样的类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> com.zhyea.scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure></p><p>编译器会从com.zhyea.scala中去找声明的类，找不到自然就会报错。</p><p>在编程的时候应当尽量避免出现问题。如果是在无法避免可以使用“_root_”声明通过绝对路径去寻找相关的类。如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> scala &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">      <span class="keyword">val</span> list = <span class="keyword">new</span> _root_.scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] <span class="comment">//通过绝对路径查找，不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Scala 定义<em>root</em>包为用户可创建的包之外的包，也就是说任何顶层包都被当作是<em>root</em>包的成员。</p><h2 id="package可见性"><a href="#package可见性" class="headerlink" title="package可见性"></a>package可见性</h2><p>关于scala可见性的内容<a href="wiki/20180429/a11-accessModifier/">前面的一篇文</a>已经说了许多了。<br>这里仅提一点：scala子包中的类可以访问父包中的类。</p><p>不多说，直接看个例子好了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">male</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(fruit: <span class="type">Fruit</span>) = println(<span class="string">s"<span class="subst">$name</span> is eating <span class="subst">$&#123;fruit.name&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="package对象"><a href="#package对象" class="headerlink" title="package对象"></a>package对象</h2><p>package对象或者说package object是一种特殊的object。它的定义方式为：</p><blockquote><p>package object packageName{<br>    valueOrVariant<br>    methods<br>}</p></blockquote><p>package对象的名称需要与package的名称一致，否则就没有意义。package下面的类和对象可以直接访问同名package对象中定义的值或方法。</p><p>看个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> job: <span class="type">String</span> = <span class="string">"Student"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duty</span></span>: <span class="type">String</span> = <span class="string">"Study"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> student &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span>'s job is <span class="subst">$job</span>, and his/her duty is <span class="subst">$&#123;duty&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    println(<span class="keyword">new</span> student.<span class="type">Student</span>(<span class="string">"robin"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过例子可以看出，scala通过package对象在package这一层对功能又做了一次聚合。通过package对象，scala可以解决一些功能增强及版本兼容相关的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节介绍一些关于package的内容。本来不想写关于package的内容的，因为一开始觉得没啥好写的。这次写因为发现了点儿可以写的内容。&lt;/p&gt;
&lt;h2 id=&quot;package定义&quot;&gt;&lt;a href=&quot;#package定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>方法的点和括号是可选的</title>
    <link href="http://scala.chobit.org/wiki/20180503/b007-pointlessMethod/"/>
    <id>http://scala.chobit.org/wiki/20180503/b007-pointlessMethod/</id>
    <published>2018-05-03T14:04:13.000Z</published>
    <updated>2018-05-05T02:38:36.572Z</updated>
    
    <content type="html"><![CDATA[<p>在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。   </p><p>比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。  </p><p>这样做的优势也很明显：代码读起来更加自然，在展现上不至于显得杂乱。</p><p>下面是一段示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(subject: <span class="type">String</span>) = println(<span class="string">s"<span class="subst">$name</span> teaches <span class="subst">$subject</span>."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(subject: <span class="type">String</span>, student: <span class="type">String</span>*) = println(<span class="string">s"<span class="subst">$name</span> teaches <span class="subst">$&#123;student.mkString(",")&#125;</span> to learn <span class="subst">$subject</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>(<span class="string">"Mr.Chang"</span>)</span><br><span class="line"></span><br><span class="line">teacher teach <span class="string">"Mathematics"</span></span><br><span class="line"></span><br><span class="line">teacher teach (<span class="string">"Mathematics"</span>, <span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mr.Chang teaches Mathematics.</span><br><span class="line">Mr.Chang teaches robin to learn Mathematics</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。   &lt;/p&gt;
&lt;p&gt;比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。  &lt;/p&gt;
&lt;p&gt;这样做的优势也很明显：代码读起来更加自然，在展现
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>可变长度参数</title>
    <link href="http://scala.chobit.org/wiki/20180502/b006-variableLengthParams/"/>
    <id>http://scala.chobit.org/wiki/20180502/b006-variableLengthParams/</id>
    <published>2018-05-02T13:53:46.000Z</published>
    <updated>2018-05-05T04:50:18.868Z</updated>
    
    <content type="html"><![CDATA[<p>scala支持可变长度参数。在scala中，可变长度参数的特征如下：</p><ul><li>在参数列表中处于最后面；</li><li>标识方法为在参数类型后放一个星号。</li></ul><p>在scala解释器中写了一个示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(str:String*) = str.foreach&#123;println&#125;</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)</span><br><span class="line">com</span><br><span class="line">zhyea</span><br><span class="line">robin</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个foo方法，它的参数长度就是可变的，方法体的定义是逐行输出每个参数。在随后的验证代码中可以看到结果和预期是一致的。  </p><p>我们知道，在java中，变长参数是被作为数组来处理的。至于在scala中是否也是一样，则需要进行验证。  </p><p>对刚才的示例代码做了些调整来进行验证：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(str: String*) = println(str.getClass)</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"zhyea"</span>)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofRef</span></span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofRef</span></span><br><span class="line"></span><br><span class="line">scala&gt; def foo(nums:Int*) = println(nums.getClass)</span><br><span class="line">foo: (nums: Int*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(1, 2, 3)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofInt</span></span><br></pre></td></tr></table></figure></p><p>可以看到，在scala中变长参数的类型是scala.collection.mutable.WrappedArray的ofXXX子类，并不是一个数组结构。</p><p>再来看看给变长参数的方法传递一个数组结构会有什么样的反应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  def foo(str: String*) = println(str.getClass)</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(Array(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>))</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Array[String]</span><br><span class="line"> required: String</span><br><span class="line">       foo(Array(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>))</span><br></pre></td></tr></table></figure></p><p>可以看到报错了：类型不匹配，需要的是String，传递是String数组。  </p><p>如果我们确实需要把一个类型匹配的数组传递给这个方法，此时我们可以使用“:_<em>”标识符。“:_</em>”作为一个整体，告诉编译器你希望将某个参数当作参数序列处理。  </p><p>看下演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(nums:Int*) = nums.foreach(println)</span><br><span class="line">foo: (nums: Int*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(Array(1,2,3) :_*)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>注意一下，“:_*”不只是能标识数组，还可以标识其他的集合，比如List、Seq、Range等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; foo(1 to 3 :_\*)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>“1 to 3”是一个Range结果，使用“:_*”标识后依然可以被变长参数方法调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala支持可变长度参数。在scala中，可变长度参数的特征如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在参数列表中处于最后面；&lt;/li&gt;
&lt;li&gt;标识方法为在参数类型后放一个星号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在scala解释器中写了一个示例：&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
