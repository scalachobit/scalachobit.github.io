<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCALA 手账</title>
  
  <subtitle>scala</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scala.chobit.com/"/>
  <updated>2018-04-30T23:12:43.382Z</updated>
  <id>http://scala.chobit.com/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>循环和循环控制</title>
    <link href="http://scala.chobit.com/wiki/20180429/a12-loopAndLoopControl/"/>
    <id>http://scala.chobit.com/wiki/20180429/a12-loopAndLoopControl/</id>
    <published>2018-04-29T01:40:46.000Z</published>
    <updated>2018-04-30T23:12:43.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>scala中的循环类型和java差不多，大体上有三种：  </p><ul><li>while循环</li><li>do{}while循环</li><li>for循环</li></ul><p>每样循环都写一段示例代码来看一下。  </p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 0</span><br><span class="line">Value of i: 1</span><br><span class="line">Value of i: 2</span><br><span class="line">Value of i: 3</span><br><span class="line">Value of i: 4</span><br><span class="line">Value of i: 5</span><br></pre></td></tr></table></figure></p><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do{}while循环"></a>do{}while循环</h3><p>代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">  println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 0</span><br><span class="line">Value of i: 1</span><br><span class="line">Value of i: 2</span><br><span class="line">Value of i: 3</span><br><span class="line">Value of i: 4</span><br><span class="line">Value of i: 5</span><br></pre></td></tr></table></figure></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>看一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">5</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Value of i <span class="subst">$i</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value of i 1</span><br><span class="line">Value of i 2</span><br><span class="line">Value of i 3</span><br><span class="line">Value of i 4</span><br><span class="line">Value of i 5</span><br></pre></td></tr></table></figure></p><p>在上面代码中的循环结构里，箭头（&lt;-）左侧是一个val（注意不是var）变量，右侧是一个生成器表达式。和java中的循环不同，在这里的每次循环中都会创建一个新的val变量i（而非是给i赋值），用生成器表达式产生出来的连续值进行初始化。  </p><p>生成器表达式“1 to 3”生成的连续值包含了下界[1]和上界[3]，如果用until方法替换to方法后，就可以排除上界。to和until都是scala的RichInt类的方法。</p><p>这里使用1 to 3等价于1.to(3)，即数字1调用了整型的to方法。在scala中，如果方法有0或1个参数，点和括号是可以丢掉的。如果方法的参数多于一个，那么就必须保留括号，但是点仍是可选的。以一个非常常见的表达式为例：1 + 2在scala中实际上就是1.+(2)，+也是一个方法而非是简单的符号。</p><p>我们已经知道1 to 3返回的使一个连续值(Range)，那么也可以考虑使用Range的foreach方法来实现循环。代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">3</span>).foreach(i =&gt; println(<span class="string">s"Value of i <span class="subst">$i</span>"</span>))</span><br></pre></td></tr></table></figure></p><p>for循环的功能非常丰富，值得多多解释一下，所以会另写一篇进行说明。</p><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>通常的循环控制语句就是<strong>continue</strong>和<strong>break</strong>。但是这两个关键字在scala中是不存在的。不过我们可以使用一些技巧来实现这两种控制语句。  </p><p>先来看一个Java的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Value of i:"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码要做的事情非常简单，不需要多做解释。  </p><p>要用scala实现这个逻辑，简单点儿的思路是用if判断句来替换continue，用一个bool变量控制循环来替换break。代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">break</span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">6</span> &amp;&amp; !<span class="keyword">break</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码实现了前面那段Java代码的功能。期间我们还是使用了两个var变量。这两个var变量一个用来提供循环值，一个用来实现break功能中止循环。scala不鼓励使用var变量。我们尝试去掉这两个var变量。  </p><p>要去掉循环值变量可以考虑将所有的循环值放入一个集合，然后使用for循环来处理。<br>要去掉break控制变量，可以考虑主动抛出异常来中止当前代码块。</p><p>根据这个思路来做一下实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123;</span><br><span class="line">    i <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> =&gt;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在修改后的代码里使用模式匹配替换了if判断，并且演示了scala处理异常的方案。<br>这里用抛出异常来实现break的方式scala中有提供具体的实现方案，即在scala.util.control包中定义的break控制结构，用法如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b = <span class="keyword">new</span> scala.util.control.<span class="type">Breaks</span></span><br><span class="line"></span><br><span class="line">b.breakable &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123;</span><br><span class="line">    i <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> =&gt;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span> =&gt; b.<span class="keyword">break</span>()</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路还可以继续展开，比如用递归来替换循环：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myLoop</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">6</span>) ()</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) myLoop(i + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">4</span>) &#123;</span><br><span class="line">    println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>);</span><br><span class="line">    myLoop(i + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLoop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>在函数化编程中使用递归函数来实现循环是非常常见的一种方法，并且这样做很函数式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;循环类型&quot;&gt;&lt;a href=&quot;#循环类型&quot; class=&quot;headerlink&quot; title=&quot;循环类型&quot;&gt;&lt;/a&gt;循环类型&lt;/h2&gt;&lt;p&gt;scala中的循环类型和java差不多，大体上有三种：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;while循环&lt;/li&gt;
&lt;li&gt;do
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala等于符号“==”</title>
    <link href="http://scala.chobit.com/wiki/20180429/b003-equalitySymbol/"/>
    <id>http://scala.chobit.com/wiki/20180429/b003-equalitySymbol/</id>
    <published>2018-04-29T01:27:28.000Z</published>
    <updated>2018-04-29T07:17:21.350Z</updated>
    
    <content type="html"><![CDATA[<p>在java中，基本类型和引用类型对==运算有着不同的解释方式：</p><ul><li>对于基本类型来说，==运算比较的就是两边表达式的值；</li><li>对于引用类型来说，==运算比较的是两边对象的引用而非是对象的值；在Java中比较对象的值使用的是equals方法。</li></ul><p>在scala中没有对象，不论类型如何，==运算都是面向值的。这一点由scala的Any类（scala中所有的类都是由它派生而来）提供了保证：它将==()方法实现为final的方法。因此在scala中进行值的比较就可以简单使用==运算，如果还有一些特殊化的比较，就需要改写equals方法了。在scala中如果想执行对于引用的比较可以使用eq()方法。看一下下面这段程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> str2 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> str3 = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">println(str1 == str2) <span class="comment">// Equivalent to Java's str1.equals(str2)</span></span><br><span class="line">println(str1 eq str2) <span class="comment">// Equivalent to Java's str1 == str2</span></span><br><span class="line">println(str1 == str3)</span><br><span class="line">println(str1 eq str3)</span><br></pre></td></tr></table></figure><p>程序的执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>结果很清楚了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java中，基本类型和引用类型对==运算有着不同的解释方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于基本类型来说，==运算比较的就是两边表达式的值；&lt;/li&gt;
&lt;li&gt;对于引用类型来说，==运算比较的是两边对象的引用而非是对象的值；在Java中比较对象的值使用的是equals方法
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>scala赋值符号“=”</title>
    <link href="http://scala.chobit.com/wiki/20180429/b002-assignmentSymbol/"/>
    <id>http://scala.chobit.com/wiki/20180429/b002-assignmentSymbol/</id>
    <published>2018-04-29T01:15:04.000Z</published>
    <updated>2018-04-29T07:17:09.512Z</updated>
    
    <content type="html"><![CDATA[<p>scala的赋值运算和java的赋值运算有着很大的不同。如a=b这样的赋值运算，在Java中的返回值是a的值，在scala中返回的则是Unit。Unit是值类型，全局只存在唯一的值，即()，通常Unit只用来声明函数或方法的返回值，其他场景基本是没有意义的。这样就很容易导致一些错误地使用，比如a=b=c这样的赋值运算在java中是绝对可以的，但是在scala中使用就会报错。  </p><p>看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span></span><br><span class="line">a =  b=c</span><br><span class="line">println(a)</span><br></pre></td></tr></table></figure></p><p>上面这段代码还没有执行就在IDE中提示错误了，勉强执行下看看会报什么错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error:(6, 9) type mismatch;</span><br><span class="line"> found   : Unit</span><br><span class="line"> required: Int</span><br><span class="line">  a = b = c</span><br></pre></td></tr></table></figure><p>报了类型不匹配的错误，因为在第一行代码中scala推断出a是一个Int型的变量，后又将b=c的运算结果——一个Unit值——赋值给它，所以会报错了。</p><p>即使只在scala中看赋值运算符“=”号也是一个比较奇怪的东西：scala中的大部分运算符都是方法，但“=”不是方法，在默认情况下不可以这样使用：a.=(1)。对于这个问题，有心人可以深究下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的赋值运算和java的赋值运算有着很大的不同。如a=b这样的赋值运算，在Java中的返回值是a的值，在scala中返回的则是Unit。Unit是值类型，全局只存在唯一的值，即()，通常Unit只用来声明函数或方法的返回值，其他场景基本是没有意义的。这样就很容易导致
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>访问修饰符</title>
    <link href="http://scala.chobit.com/wiki/20180429/a11-accessModifier/"/>
    <id>http://scala.chobit.com/wiki/20180429/a11-accessModifier/</id>
    <published>2018-04-28T22:38:56.000Z</published>
    <updated>2018-04-29T01:12:35.993Z</updated>
    
    <content type="html"><![CDATA[<p>先简单介绍下scala访问修饰符的几个特性，稍后再详细解释：  </p><ul><li>如果不指定访问修饰符，默认为public；</li><li>较之Java，scala对protected的定义更加严格；</li><li>scala可以对可见性进行细粒度的控制。</li></ul><h2 id="默认访问修饰符"><a href="#默认访问修饰符" class="headerlink" title="默认访问修饰符"></a>默认访问修饰符</h2><p>如果没有修饰符，scala会默认把类、字段、方法的访问修饰符当做public。如果要将之调整为private或protected，只需在前面添加对应的修饰符关键字即可。就如下面的程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Microwave</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() = println(<span class="string">"started"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>() = println(<span class="string">"stopped"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">turnTable</span></span>() = println(<span class="string">"turning table"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> microwave = <span class="keyword">new</span> <span class="type">Microwave</span></span><br><span class="line">microwave.start()</span><br><span class="line"></span><br><span class="line">microwave.turnTable()<span class="comment">//这里错了</span></span><br></pre></td></tr></table></figure><p>在上面的代码里start和stop两个方法默认为public类型，可以通过任意Microwave实例访问。turnTable被显示定义为private，这样就不能在Microwave类外部访问它。执行这段代码，就会如注释处声明的一样，会在该处报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method turnTable in class Microwave cannot be accessed in com.zhyea.MyApp.Microwave</span><br><span class="line"> microwave.turnTable()</span><br></pre></td></tr></table></figure></p><h2 id="protected修饰符"><a href="#protected修饰符" class="headerlink" title="protected修饰符"></a>protected修饰符</h2><p>在scala里，用protected修饰的成员只对本类和派生类可见，同一个包内的其他的类不可见。而且派生类只可以访问本类实例的protected成员。<br>可以通过一个例子看一下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea.auto</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">checkEngine</span></span>() = println(<span class="string">"checked engine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    checkEngine()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tow</span></span>(car: <span class="type">Car</span>) &#123;</span><br><span class="line">    car.checkEngine()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tow</span></span>(vehicle: <span class="type">Vehicle</span>) &#123;</span><br><span class="line">    vehicle.checkEngine() <span class="comment">//会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GasStation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fillGas</span></span>(vehicle: <span class="type">Vehicle</span>) &#123;</span><br><span class="line">    vehicle.checkEngine() <span class="comment">//会报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fillGas</span></span>(car: <span class="type">Car</span>) &#123;</span><br><span class="line">    car.checkEngine() <span class="comment">//会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，Vehicle的checkEngine()方法是protected型的，Car是Vehicle类的派生类。</p><p>根据scala对protected修饰符的要求：</p><ul><li>在Car类自定义方法start()中访问父类Vehicle的checkEngine()方法不会报错；</li><li>在Car类自定义方法tow()中通过Car类实例访问父类Vehicle的checkEngine()方法不会报错；</li><li>在Car类自定义方法tow()中通过Vehicle类实例访问Vehicle的checkEngine()方法会报错；</li><li>在同一个包内的GasStation类中通过Car或Vehicle实例访问checkEngine()方法会报错</li></ul><p>这些错误在编译期就会报出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Vehicle</span><br><span class="line"> Access to protected method checkEngine not permitted because </span><br><span class="line"> prefix type com.zhyea.auto.Vehicle does not conform to class Car in package auto where the access take place</span><br><span class="line">    vehicle.checkEngine() //会报错</span><br><span class="line">    </span><br><span class="line">method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Vehicle</span><br><span class="line"> Access to protected method checkEngine not permitted because</span><br><span class="line"> enclosing class GasStation in package auto is not a subclass of </span><br><span class="line"> class Vehicle in package auto where target is defined</span><br><span class="line">    vehicle.checkEngine() //会报错</span><br><span class="line"></span><br><span class="line">method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Car</span><br><span class="line"> Access to protected method checkEngine not permitted because</span><br><span class="line"> enclosing class GasStation in package auto is not a subclass of </span><br><span class="line"> class Vehicle in package auto where target is defined</span><br><span class="line">    car.checkEngine() //会报错</span><br></pre></td></tr></table></figure><h2 id="细粒度访问控制"><a href="#细粒度访问控制" class="headerlink" title="细粒度访问控制"></a>细粒度访问控制</h2><p>scala对待protected比Java更加严格，但另一方面它提供了更多的灵活性和更细粒度的访问规则。</p><p>使用private和protected时可以指定额外的参数，使用方式如：private[AccessQualifier]。AccessQualifier可以是this，也可以是其它的类名或包名。<br>对于修饰符private[AccessQualifier]可以这样理解：除了自己和AccessQualifier所表示范围内的类，该修饰符修饰的成员对其他所有类的可见性都是private。并且这个概念也是可以递推的，也就是说，如果AccessQualifier是一个类，那么private成员对于AccessQualifier的AccessQualifier也是可见的。</p><p>看一个细粒度访问控制的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> society &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> professional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span>[professional] <span class="keyword">var</span> workDetails = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">private</span>[society] <span class="keyword">var</span> friends = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> secret = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">help</span></span>(another: <span class="type">Executive</span>) &#123;</span><br><span class="line">        println(another.workDetails)</span><br><span class="line">        println(<span class="keyword">this</span>.secret)</span><br><span class="line">        println(another.secret) <span class="comment">//会报错</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> social &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acquaintance</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">socialize</span></span>(person: professional.<span class="type">Executive</span>) &#123;</span><br><span class="line">        println(person.friends)</span><br><span class="line">        println(person.workDetails) <span class="comment">//会报错</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码里面有一个嵌套包的使用：可以看到，在society包里又声明了professional和social两个包。而且使用包的方式也和常见的不一样：一般的包声明是点号分隔，文件头声明的方式。</p><p>在类Executive的定义中，三个私有成员变量有着不同的作用范围。workDetails对包professional内的类可见，friends对society包内的类可见，而secret只对当前实例可见。</p><p>所以编译这段代码，在标记报错的地方会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value secret is not a member of com.zhyea.society.professional.Executive</span><br><span class="line">        println(another.secret) //会报错</span><br><span class="line"></span><br><span class="line">value workDetails in class Executive cannot be accessed in com.zhyea.society.professional.Executive</span><br><span class="line">        println(person.workDetails) //会报错</span><br></pre></td></tr></table></figure></p><p>Executive的成员secret只对当前实例（this）可见，对Executive的其他实例不可见。workDetails对包professional内的类可见，对society包内的类不可见。因此会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先简单介绍下scala访问修饰符的几个特性，稍后再详细解释：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不指定访问修饰符，默认为public；&lt;/li&gt;
&lt;li&gt;较之Java，scala对protected的定义更加严格；&lt;/li&gt;
&lt;li&gt;scala可以对可见性进行细粒度的控制。
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用变长参数</title>
    <link href="http://scala.chobit.com/wiki/20180428/b001-useVeriableArguments/"/>
    <id>http://scala.chobit.com/wiki/20180428/b001-useVeriableArguments/</id>
    <published>2018-04-28T13:37:35.000Z</published>
    <updated>2018-04-29T07:16:57.718Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中是可以使用变长参数的，如下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String tmp : args) &#123;</span><br><span class="line">        System.out.println(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在scala中也可以使用变长参数。和java一样，也是只有最后一个参数可以接收可变长度的参数。使用方式是在参数类型后使用特殊符号“*”，如下面的max()方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(values: <span class="type">Int</span>*) = values.foldLeft(<span class="number">0</span>) &#123;</span><br><span class="line">    java.lang.<span class="type">Math</span>.max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>foldLeft是TraversableOnce类的方法。上面的代码实现了一个从一组整型数值中获取最大值的方法。  </p><p>不过和java不同的是，我们不能将一个数组中的元素当做变长参数直接传递给方法，来个测试案例看看：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def max(values: Int*) = values.foldLeft(0) &#123;Math.max&#125;</span><br><span class="line">max: (values: Int*)Int</span><br><span class="line"></span><br><span class="line">scala&gt; println(max(2, 5, 3, 7, 1, 6))</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">scala&gt; println(max( Array(2, 5, 3, 7, 1, 6)))</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Array[Int]</span><br><span class="line"> required: Int</span><br><span class="line">       println(max( Array(2, 5, 3, 7, 1, 6)))</span><br></pre></td></tr></table></figure><p>可以看到在给max方法传递多个整型值作为参数时可以正常执行。但是将一个整型数组作为参数就报错了。  </p><p>如果想使用数组中的元素作为变长参数，可以将数组展开成为离散值：这里需要使用“:_*”符号组合。测试看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; println(max( Array(2, 5, 3, 7, 1, 6):_*))</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p><p>这次执行成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java中是可以使用变长参数的，如下面的方法：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>使用yield关键字</title>
    <link href="http://scala.chobit.com/wiki/20180428/b000-useYield/"/>
    <id>http://scala.chobit.com/wiki/20180428/b000-useYield/</id>
    <published>2018-04-28T13:36:56.000Z</published>
    <updated>2018-04-29T07:16:45.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>使用yield关键字可以存储for循环返回值。每次循环时，返回值都会存储到一个结构中。在循环完成后，会将结构中的所有值一起返回。存储返回值的结构，和循环值的结构一致。也就是说如果循环的是一个数组返回的就是数组，循环的是一个List返回的就是一个List，循环的是一个Map返回的就是Map。  </p><p>来看一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val result = <span class="keyword">for</span> &#123;i &lt;- List(1, 2, 3, 4)&#125; yield i</span><br><span class="line">result: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; val result = <span class="keyword">for</span> &#123;i &lt;- Array(1, 2, 3, 4)&#125; yield i</span><br><span class="line">result: Array[Int] = Array(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p>在示例中，我们先后循环了一个List和一个整型数组。循环的返回值也分别是List和整型数组。  </p><p>使用yield关键字还可以对返回值做进一步的加工：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val result = <span class="keyword">for</span> &#123;i &lt;- Array(1, 2, 3, 4)&#125; yield i*2</span><br><span class="line">result: Array[Int] = Array(2, 4, 6, 8)</span><br></pre></td></tr></table></figure></p><p>在使用yield关键字的同时，对每个返回值都做了乘以2的处理。所以最后返回的数组中的每个值都是循环值的2倍。</p><p>使用yield关键字还可以修改集合中值的类型，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val result = <span class="keyword">for</span> &#123;i &lt;- Array(1, 2, 3, 4)&#125; yield i*2.0</span><br><span class="line">result: Array[Double] = Array(2.0, 4.0, 6.0, 8.0)</span><br></pre></td></tr></table></figure></p><p>原来循环的是一个整型数值数组，返回的则是Double值数组。  </p><p>这里yield的用法有些类似于集合的map方法，所不同的是map方法是修改集合的原始值，yield则是返回一个新集合。  </p><h2 id="结合卫述语句"><a href="#结合卫述语句" class="headerlink" title="结合卫述语句"></a>结合卫述语句</h2><p>在scala中if语句常被作为卫述语句。卫述语句是指被用来检查关键的先决条件的合法性并在检查未通过的情况下立即终止当前代码块的执行的语句。</p><p>yield结合卫述语句可以对循环值进行过滤处理。看一下示例代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val result = <span class="keyword">for</span> &#123;i &lt;- Array(1, 2, 3, 4) <span class="keyword">if</span>(i%2==0)&#125; yield i</span><br><span class="line">result: Array[Int] = Array(2, 4)</span><br></pre></td></tr></table></figure></p><p>这里使用if语句筛选出了循环的数组中所有的偶数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础用法&quot;&gt;&lt;a href=&quot;#基础用法&quot; class=&quot;headerlink&quot; title=&quot;基础用法&quot;&gt;&lt;/a&gt;基础用法&lt;/h2&gt;&lt;p&gt;使用yield关键字可以存储for循环返回值。每次循环时，返回值都会存储到一个结构中。在循环完成后，会将结构中的所有值一起返
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>单例、独立对象和伴生对象</title>
    <link href="http://scala.chobit.com/wiki/20180427/a10-independentAndCompanionObject/"/>
    <id>http://scala.chobit.com/wiki/20180427/a10-independentAndCompanionObject/</id>
    <published>2018-04-27T13:37:43.000Z</published>
    <updated>2018-04-28T13:34:51.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scala单例"><a href="#scala单例" class="headerlink" title="scala单例"></a>scala单例</h2><p>单例模式大家都很熟悉了，简单地说就是使用单例模式的类一个类只能有一个实例。  </p><p>在scala中创建单例对象非常简单，创建类时使用object关键字替换class即可。使用object声明的单例类无法初始化，所以不能向它的主构造函数传递参数。  </p><p>使用object的时候可以直接用“object名.方法名”这样的形式来调用object中定义的方法。因此感觉着scala的单例类从某种意义上更像Java中只提供静态方法的工具类。  </p><p>再来用Scala实现一个工具类Math，在这个类中提供一个计算绝对值的方法abs()：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) -num <span class="keyword">else</span> num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用时确实很像java的静态方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Math</span>.abs(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p><p>接下来将这个Math类生成的class文件转译为Java类，看看否和猜想的一样：对应的Java类是一个只提供静态方法的类。</p><p>编译Math类后看到生成了两个文件Math$.class和Math.class。看样子scala一个object类对应着两个Java类。<br>用jd-gui反编译查看生成的Math$.class：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span>$</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  MODULE$;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &lt; <span class="number">0</span> ? -num : num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Math$()&#123;</span><br><span class="line">    MODULE$ = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出这里就是一个常见的单例类的定义。<br>再来看看Math.class反编译出来的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> paramInt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math..MODULE$.abs(paramInt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里倒是一个工具类了，在这个工具类中是调用了Math$类的单例提供具体方法的实现。  </p><p>从反编译出来的内容看来：scala的object中包含了一个单例对象，而不仅仅是一个提供了静态方法的工具类定义。  </p><p>既然提到了静态方法就不妨多说两句：scala中没有静态方法和静态成员，静态成员会破坏scala所支持的完整的面向对象模型；static也不是scala中的关键字。所以在scala中定义一个名为static的变量是完全没问题的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val static:Int=1</span><br><span class="line">static: Int = 1</span><br></pre></td></tr></table></figure></p><h2 id="独立对象"><a href="#独立对象" class="headerlink" title="独立对象"></a>独立对象</h2><p>前面我们演示的scala object对象Math，无需绑定其他类就可以独立使用，所以这样定义的object也被称为独立对象。  </p><p>注意，这里说的是无需绑定其他类，而不是无需引用（import）其他类。绑定的概念产生在伴生对象中。  </p><p>换句话说就是scala使用object声明的对象分为两种：独立对象和伴生对象。  </p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>scala伴生对象是绑定到指定类上的对象。伴生对象和绑定的类共享同一个名字，绑定的类也被称为伴生类。在scala里，伴生类和伴生对象没有界限，它们互相可以访问彼此的private 方法和private 属性。    </p><p>每个类都可以有伴生对象。伴生对象和伴生类写在同一个文件中，伴生对象在scala中很常见，它们提供了在类一级进行操作的便捷方法。从某种方面来说，伴生对象还可以作为scala缺少静态成员的变通措施。</p><p>下面用伴生对象的概念修改下前面定义的Math类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) -num <span class="keyword">else</span> num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">Math</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(num: <span class="type">Int</span>) = m.abs(num)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在修改后的代码中有同时名为Math的一个类和一个object。为了保证Math类的单例特性，还使用private修饰了Math类的主构造函数，这样只能由伴生对象创建Math类的实例（不使用private来修饰主构造函数也可以，这里只是为了保证单例的严密性）。   </p><p>使用伴生对象还有另外一点好处：可以不使用new关键字就能创建伴生类的实例。再来修改Math类来看看：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) -num <span class="keyword">else</span> num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="keyword">new</span> <span class="type">Math</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Math</span>().abs(<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Client的main方法中使用“Math()”这样的方式创建了一个Math类的对象。这里主要依赖了apply方法，它是scala提供的语法糖。上面的代码在调用Math()的时候，其实就是在调用object Math.apply()方法。通过这种方式可以让实例的创建和获取更加容易。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scala单例&quot;&gt;&lt;a href=&quot;#scala单例&quot; class=&quot;headerlink&quot; title=&quot;scala单例&quot;&gt;&lt;/a&gt;scala单例&lt;/h2&gt;&lt;p&gt;单例模式大家都很熟悉了，简单地说就是使用单例模式的类一个类只能有一个实例。  &lt;/p&gt;
&lt;p&gt;在sc
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>类继承</title>
    <link href="http://scala.chobit.com/wiki/20180427/a09-classExtends/"/>
    <id>http://scala.chobit.com/wiki/20180427/a09-classExtends/</id>
    <published>2018-04-26T21:57:16.000Z</published>
    <updated>2018-04-26T22:01:30.575Z</updated>
    
    <content type="html"><![CDATA[<p>在scala里，类继承有两点限制：  </p><ul><li>重写方法需要使用override关键字；</li><li>只有主构造函数才能往父类构造函数中传参数。</li></ul><p>在java1.5中引入了override注解，但不强制使用。不过在scala中要想重写方法必须使用override关键字。如果确实重写了父类的方法又不使用override关键字的话，则会在编译时报错，提示没有使用override修饰符。</p><p>scala的副构造函数必须调用主构造函数或是另一个副构造函数。只有在主构造函数中才能向父类的构造函数中传递数据。可以看出来主构造函数如同父类和子类中间的一道关卡：它既负责完成子类的初始化，也负责与父类的沟通。  </p><p>下面的这段代码演示了下上述内容：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>(<span class="params">val id: <span class="type">Int</span>, val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">"ID: "</span> + id + <span class="string">" Year: "</span> + year</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">override val id: <span class="type">Int</span>, override val year: <span class="type">Int</span>, var fuelLevel: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Vehicle</span>(<span class="params">id, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="keyword">super</span>.toString() + <span class="string">" Fuel Level: "</span> + fuelLevel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中定义了两个类：Vehicle和Car。Car继承了Vehicle。<br>在继承的时候要向父类传递参数，所以Car类主构造函数的一部分必须能匹配父类的构造函数。<br>Car类构造函数中的id和year两个成员变量源自父类Vehicle，所以需要使用override关键字修饰。<br>此外，这两个类都重写了java.lang.Object的toString方法，所以需要使用override关键字修饰toString方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala里，类继承有两点限制：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重写方法需要使用override关键字；&lt;/li&gt;
&lt;li&gt;只有主构造函数才能往父类构造函数中传参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在java1.5中引入了override注解，但不强制使用。不过在scala
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>类定义和构造器</title>
    <link href="http://scala.chobit.com/wiki/20180426/a08-classDefine/"/>
    <id>http://scala.chobit.com/wiki/20180426/a08-classDefine/</id>
    <published>2018-04-25T22:05:15.000Z</published>
    <updated>2018-04-27T13:15:45.655Z</updated>
    
    <content type="html"><![CDATA[<p>这次会通过与Java比较的方式来说明scala是如何创建类的。</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>假设我们要定义一个学生类，先来看一下使用Java是如何定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很基础的一个Bean定义，大概用了27行代码。  </p><p>再来看一下如何用scala定义这个学生类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure></p><p>是的，只用一行就完成了类的定义，连大括号都不需要。并且在类定义的时候就完成了类构造器的创建。这里和类定义一起实现的构造器也叫作主构造器。  </p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>除了主构造器，我们也可以在类的内部添加新的构造器。  </p><p>现在我们为Student类新增一个类成员变量gender，并添加一个新的构造函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> gender: <span class="type">Short</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">Short</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>(name, age)</span><br><span class="line">    <span class="keyword">this</span>.gender = gender</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别于主构造函数，在类内部新定义的构造函数被称为副构造函数。  </p><p>稍稍关注下副构造函数的实现：如果有主构造函数的话，那么副构造函数的第一行必须是主构造函数或者其它副构造函数的调用。这一点和java继承父类时有点相似。  </p><p>此外还值得注意的就是成员变量gender的声明，把这一行单独拎出来看看吧：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gender: <span class="type">Short</span> = _</span><br></pre></td></tr></table></figure></p><p>这里比较有趣的是初始化赋值，赋的值是一个“_”——下划线。在这里“_”代表相应类型的默认值。对于Int，它的值是0；对于Double，它的值是0.0；对于String，它的值就是null。通过使用“_”，可以很方便地为var成员变量设置初始默认值。  </p><p>不过不能为val成员使用“_”，因为val成员不允许修改，所以必须显式指定初始值。  </p><p>如果构造器中的成员变量没有使用var或val修饰，将被视为类内部私有的val变量。  </p><p>另外，放到类定义中的所有可执行语句或表达式都会被视为类的构造器的组成部分。如下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"Create a new student instance."</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"robin"</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></p><p>这段代码在定义Student类以后，又创建了一个Student实例。看下执行结果：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Create</span> a <span class="keyword">new</span> student instance.</span><br><span class="line"></span><br><span class="line"><span class="type">Process</span> finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>在创建实例的时候输出了类定义中的print语句，因为这段print语句是构造器的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次会通过与Java比较的方式来说明scala是如何创建类的。&lt;/p&gt;
&lt;h2 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; title=&quot;类定义&quot;&gt;&lt;/a&gt;类定义&lt;/h2&gt;&lt;p&gt;假设我们要定义一个学生类，先来看一下使用Java是如何
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串和多行字符串</title>
    <link href="http://scala.chobit.com/wiki/20180425/a07-stringAndMultiLineString/"/>
    <id>http://scala.chobit.com/wiki/20180425/a07-stringAndMultiLineString/</id>
    <published>2018-04-24T22:38:43.000Z</published>
    <updated>2018-04-24T23:05:11.322Z</updated>
    
    <content type="html"><![CDATA[<p>scala中的字符串类就是java中的java.lang.String类。不过scala也为String提供了一个富封装类：scala.runtime.RichString。  </p><p>scala可以将java.lang.String类自动转换为scala.runtime.RichString类。这样就可以非常方便地使用capitalize()、lines()和reverse()等方法相对较便捷的方法。  </p><p>在scala里，对于字符串的支持中最显著的一个特性是对于heredoc的支持，也就是对多行文本的支持。在scala里创建多行字符串非常容易，只要将多行字符串放在三个双引号里就行。在下面的代码里创建了一个四行的字符串：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info =</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">     这里是robin的信息：</span></span><br><span class="line"><span class="string">          robin的姓名：robin zhang；</span></span><br><span class="line"><span class="string">          robin的年龄：29；</span></span><br><span class="line"><span class="string">          robin的个人主页：zhyea.com</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">println(info)</span><br></pre></td></tr></table></figure></p><p>scala会将三个双引号间的内容保持原样输出。所以这样声明的字符串也被称为原始字符串。需要注意一点：在原始字符串中使用转义字符也不会被转义，仍然会原样输出。在scala解释器中演示一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val info =</span><br><span class="line">     | <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">     |    My name is "</span>robin<span class="string">" \n</span></span><br><span class="line"><span class="string">     | Hello World!</span></span><br><span class="line"><span class="string">     | "</span><span class="string">""</span></span><br><span class="line">info: String =</span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">   My name is "</span>robin<span class="string">" \n</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">scala&gt; println(info)</span><br><span class="line"></span><br><span class="line">   My name is <span class="string">"robin"</span> \n</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p><p>我在原始字符串中使用了空格缩进、双引号和转义字符“\n”，在输出的时候这些都原样保留下来了。  </p><p>RichString提供的方法中比较常用的是stripMargin。这个方法需要配合管道符“|”一起使用。如果管道符用在多行字符串每行的起始位置，stripMargin()方法会去掉先导管道符“|”前所有的空白或控制字符。如果出现在其他地方，而不是每行的开始，就会保留管道符。看个实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val info =</span><br><span class="line">     | <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">     |     |I'm trying to use method stripMargin.</span></span><br><span class="line"><span class="string">     | "</span><span class="string">""</span></span><br><span class="line">info: String =</span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">I'm trying to use method stripMargin.</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">scala&gt; println(info.stripMargin)</span><br><span class="line"></span><br><span class="line">I<span class="string">'m trying to use method stripMargin.</span></span><br></pre></td></tr></table></figure></p><p>如果出于某种原因，管道符号“|”有特殊的用途，可以用stripMargin的重载方法来选择其他字符作为每行字符串的先导字符</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala中的字符串类就是java中的java.lang.String类。不过scala也为String提供了一个富封装类：scala.runtime.RichString。  &lt;/p&gt;
&lt;p&gt;scala可以将java.lang.String类自动转换为scala.runt
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>var和val变量</title>
    <link href="http://scala.chobit.com/wiki/20180424/a06-varAndVal/"/>
    <id>http://scala.chobit.com/wiki/20180424/a06-varAndVal/</id>
    <published>2018-04-24T14:06:20.000Z</published>
    <updated>2018-04-24T22:35:58.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>前面我们提过，在scala中声明变量使用var和val都是可行的。  </p><p>用val声明的变量是不可变的，被初始化后值就固定下来，不可以再被修改（这类似于java中的final关键字）。用var声明的变量是可变的，可以任意修改。  </p><p>在scala解释器中声明变量实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var myVar:String = <span class="string">"my var string"</span></span><br><span class="line">myVar: String = my var string</span><br><span class="line"></span><br><span class="line">scala&gt; myVar = <span class="string">"update my var"</span></span><br><span class="line">myVar: String = update my var</span><br><span class="line"></span><br><span class="line">scala&gt; val myVal:String = <span class="string">"my val string"</span></span><br><span class="line">myVal: String = my val string</span><br><span class="line"></span><br><span class="line">scala&gt; myVal = <span class="string">"update my val"</span></span><br><span class="line">&lt;console&gt;:12: error: reassignment to val</span><br><span class="line">       myVal = <span class="string">"update my val"</span></span><br></pre></td></tr></table></figure><p>可以看到修改var变量是没有问题的。修改val变量时报错了，因为val变量是不可变的。  </p><p>仍然要注意这里说的不可变是针对变量本身而言，而非变量所指向的实例。比如说如果定义了一个StringBuffer的val变量如val buffer = new StringBuffer()，那么变量buffer再执行诸如buffer.append(“robin”)这样的操作来修改buffer实例也是可行的。  </p><p>在scala编程中应尽量优先使用val。这可以提升不变性和函数式风格。</p><h2 id="变量类型声明"><a href="#变量类型声明" class="headerlink" title="变量类型声明"></a>变量类型声明</h2><p>前面我们在声明变量时都指定了变量类型：  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal:<span class="type">String</span> = <span class="string">"my val string"</span></span><br></pre></td></tr></table></figure><p>不过在声明变量时，变量类型不是必需要指定的，像下面这样的写法也是完全没问题的：  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal = <span class="string">"my val string"</span></span><br><span class="line"><span class="keyword">var</span> myInt = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>声明变量时，如没有指定变量类型，scala也可以根据变量的初始值来推断出变量的类型。因此，声明变量时如没有指定变量类型，就必须为其指定初始值，不然就会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var myVar;</span><br><span class="line">&lt;console&gt;:1: error: <span class="string">'='</span> expected but <span class="string">';'</span> found.</span><br><span class="line">var myVar;</span><br></pre></td></tr></table></figure><h2 id="声明多个变量"><a href="#声明多个变量" class="headerlink" title="声明多个变量"></a>声明多个变量</h2><p>scala也支持一次声明多个变量，像下面这样：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> a, b = <span class="number">100</span></span><br><span class="line">a: <span class="type">Int</span> = <span class="number">100</span></span><br><span class="line">b: <span class="type">Int</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure></p><p>示例代码中同时声明了a， b两个变量，并为这两个变量同时赋值为100。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot; class=&quot;headerlink&quot; title=&quot;变量声明&quot;&gt;&lt;/a&gt;变量声明&lt;/h2&gt;&lt;p&gt;前面我们提过，在scala中声明变量使用var和val都是可行的。  &lt;/p&gt;
&lt;p&gt;用val声明的变量是不可变的，被初始化
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>运算符和优先级</title>
    <link href="http://scala.chobit.com/wiki/20180423/a05-operatorsInScala/"/>
    <id>http://scala.chobit.com/wiki/20180423/a05-operatorsInScala/</id>
    <published>2018-04-23T13:42:01.000Z</published>
    <updated>2018-04-25T14:33:54.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>从语法上来说scala是没有运算符的。scala的运算符实际上是方法名，如1 + 2实际上就是1.+(2)。这些方法之所以能像运算符一样使用，是因为scala的一个特性：  </p><blockquote><p>如果方法的参数小于等于1个的话，那么“.”和括号就都是可选的  </p></blockquote><p>既然scala的运算符本质上是一个方法，那就说明我们可以自己实现或者重载这些所谓的运算符。下面的代码是一个复数做加法运算的示例，复数有实部和虚部，计算时需要分别处理：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">val real: <span class="type">Int</span>, val imaginary: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(operand: <span class="type">Complex</span>): <span class="type">Complex</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Complex</span>(real + operand.real, imaginary + operand.imaginary)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    real + (<span class="keyword">if</span> (imaginary &lt; <span class="number">0</span>) <span class="string">""</span> <span class="keyword">else</span> <span class="string">"+"</span>) + imaginary + <span class="string">"i"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">2</span>, <span class="number">-3</span>)</span><br><span class="line"><span class="keyword">val</span> sum = c1 + c2</span><br><span class="line"></span><br><span class="line">println(<span class="string">"("</span> + c1+ <span class="string">")+ ("</span> + c2 + <span class="string">")="</span> + sum)</span><br></pre></td></tr></table></figure></p><p>在代码的第一行创建了一个名为Complex的类、定义了一个有两个参数的构造器。  </p><p>在+方法里创建了一个新的Complex实例作为计算结果。结果的实部和虚部分别对应两个运算数实部和虚部之和。计算时c1+c2实际上就是c1.+(c2)。</p><p>看下上面程序的执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1+2i)+ (2-3i)=3-1i</span><br></pre></td></tr></table></figure></p><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>既然scala中看起来像运算符的东西都是方法，那么和运算符相关的一些内容，比如算数优先级，scala是怎样处理的呢？  </p><p>scala中确实没有算数优先级、但是它定义了方法优先级：方法的优先级由方法名的第一个字符决定，如果表达式里有两个相同优先级的方法，那么左边的方法优先级更高。下面从低到高列出了scala中方法名首字符的优先级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">^</span><br><span class="line">&amp;</span><br><span class="line">&lt; &gt;</span><br><span class="line">=  !</span><br><span class="line">: </span><br><span class="line">+   - </span><br><span class="line">*  /  % </span><br><span class="line">所有其他特殊字符</span><br></pre></td></tr></table></figure><p>我们在之前的Complex类中再添加一个乘法运算来演示下scala运算符的优先级：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(operand: <span class="type">Complex</span>): <span class="type">Complex</span> = &#123;</span><br><span class="line">  println(<span class="string">"Calling *"</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Complex</span>(real * operand.real - imaginary * operand.imaginary, real * operand.imaginary + imaginary * operand.real)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">2</span>, <span class="number">-3</span>)</span><br><span class="line"><span class="keyword">val</span> c3 = <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">println(c1 + c2 * c3)</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calling *</span><br><span class="line">Calling +</span><br><span class="line">11+2i</span><br></pre></td></tr></table></figure></p><p>可以看到*()方法先被执行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;运算符&quot;&gt;&lt;a href=&quot;#运算符&quot; class=&quot;headerlink&quot; title=&quot;运算符&quot;&gt;&lt;/a&gt;运算符&lt;/h2&gt;&lt;p&gt;从语法上来说scala是没有运算符的。scala的运算符实际上是方法名，如1 + 2实际上就是1.+(2)。这些方法之所以能像运算符
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>基本类型</title>
    <link href="http://scala.chobit.com/wiki/20180423/a04-basicType/"/>
    <id>http://scala.chobit.com/wiki/20180423/a04-basicType/</id>
    <published>2018-04-22T22:46:39.000Z</published>
    <updated>2018-04-23T22:54:53.737Z</updated>
    
    <content type="html"><![CDATA[<p>先声明一点，scala中是没有基本数据类型的。在scala中一切都是对象。  </p><p>在Java中数据类型分为基本类型和引用类型。虽然在JDK1.5以后引入了自动装箱和自动拆箱机制，简化了一些基本类型和引用类型的转换问题。但是我们仍然会遇到一些问题：</p><ul><li>默认值的问题，“Intege i”和“int i”声明的整型数值的默认值是不同的；</li><li>泛型的问题，List&lt;int&gt;这样的写法在Java中是不允许的；</li><li>直接量是不可以调用对象方法的，如1.toString()在Java中就会报错。 </li></ul><p>在scala中不会有这样的问题。一开始就提过了：在scala中一切都是对象。比如1.toString()这样的写法在scala中是完全可以的。对应着Java的每个基本类型，scala都有一个封装类，包括Byte、Char、Short、Int、Long、Float、Double和Boolean。scala的封装类和Java的基本类型是可以直接转换的，比如下面这段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaInt</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playWithInt</span></span>() &#123;</span><br><span class="line"><span class="keyword">val</span> capacity: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> java.util.<span class="type">ArrayList</span>[<span class="type">String</span>]  </span><br><span class="line">list.ensureCapacity(capacity)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段代码中首先声明了一个scala.Int类型的值capacity，而后调用java API创建了一个ArrayList实例。ArrayList实例的ensureCapacity方法参数类型是一个Java的整型值。但是，我们直接将scala.Int类型的值capacity传递过去也并没有报错。在这里scala.Int变量capacity被隐式转换为java直接类型的变量。  </p><p>值得一提的是，在封装类之外，scala还有一种富封装类。比如，稍后我们用到循环的时候，通常会有这样的写法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>&gt;)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码里有“1 to 3”或者说“1.to(3)”，其中的to方法不是scala.Int类型的方法，而是其对应的富封装类scala.runtime.RichInt中的方法。当scala推断出Int型的值1无法满足要求时就会调用它的intWrapper方法将其转为scala.runtime.RichInt类型，而后再调用它的to方法。  </p><p>在scala中直接量的封装类提供了算术运算方法，富封装类则封装了一些更常用的方法以方便开发使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先声明一点，scala中是没有基本数据类型的。在scala中一切都是对象。  &lt;/p&gt;
&lt;p&gt;在Java中数据类型分为基本类型和引用类型。虽然在JDK1.5以后引入了自动装箱和自动拆箱机制，简化了一些基本类型和引用类型的转换问题。但是我们仍然会遇到一些问题：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用注释</title>
    <link href="http://scala.chobit.com/wiki/20180422/a03-comment/"/>
    <id>http://scala.chobit.com/wiki/20180422/a03-comment/</id>
    <published>2018-04-22T13:53:24.000Z</published>
    <updated>2018-04-22T14:16:37.662Z</updated>
    
    <content type="html"><![CDATA[<p>简单说下scala中的注释。scala的注释和java的注释是一样的，同样有多行注释和单行注释，使用方法也是一样的。  </p><p>这里是一段示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里是多行注释</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 这里是main方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 这里是单行注释</span></span><br><span class="line">    print(<span class="string">"Hello World!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是这样，没有什么需要解释的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单说下scala中的注释。scala的注释和java的注释是一样的，同样有多行注释和单行注释，使用方法也是一样的。  &lt;/p&gt;
&lt;p&gt;这里是一段示例代码：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>快速体验Scala - 交互式编程</title>
    <link href="http://scala.chobit.com/wiki/20180421/a02-ineractiveCoding/"/>
    <id>http://scala.chobit.com/wiki/20180421/a02-ineractiveCoding/</id>
    <published>2018-04-21T12:14:21.000Z</published>
    <updated>2018-04-21T14:05:46.953Z</updated>
    
    <content type="html"><![CDATA[<p>scala提供的交互式解释器也是一种快速体验scala的一种方式。  </p><h2 id="使用交互式解释器"><a href="#使用交互式解释器" class="headerlink" title="使用交互式解释器"></a>使用交互式解释器</h2><p>在安装好scala开发环境后，打开命令行工具，输入scala就可以进入scala解释器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robin@robin-PC MINGW64 ~</span><br><span class="line">$ scala</span><br><span class="line">Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_25).</span><br><span class="line">Type <span class="keyword">in</span> expressions <span class="keyword">for</span> evaluation. Or try :<span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure></p><p>输入“:quit”或“:q”可以退出scala解释器。<br>接下来我们使用scala的交互式解释器来了解一些scala的基础概念。  </p><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>scala的变量有两种类型：var和val。其中，val变量也可以称为常量，val定义的变量赋值后不可修改，类似于Java中final标记的变量。var变量可以随意赋值修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val msg = <span class="string">"Hello World!"</span></span><br><span class="line">msg: String = Hello World!</span><br></pre></td></tr></table></figure></p><p>代码中声明了一个val变量msg。声明变量时没有显式指明类型，但是解释器也没有报错。scala是可以根据变量的值推断出变量的类型的。<br>当然也可以显式指明变量类型，像下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val msg:String = <span class="string">"Hello World!"</span></span><br><span class="line">msg: String = Hello World!</span><br></pre></td></tr></table></figure></p><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在上一节我们已经在HelloWorld类中定义过一个main方法了，现在我们在交互式解释器中再定义一个新的函数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def hello(name:String)&#123;</span><br><span class="line">     | println(s<span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">     | println(<span class="string">"End"</span>)</span><br><span class="line">     | &#125;</span><br></pre></td></tr></table></figure></p><p>这里是在上一节定义的main函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = println(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure></p><p>我们比较一下这两个函数，可以看出scala函数定义的一些规则：  </p><ul><li>scala函数以def关键字定义</li><li>函数的参数列表中，参数名称和参数类型以“:”分隔 </li><li>方法体需要用花括号括起来，但是只有一行时，可以不使用花括号  </li><li>方法的返回类型可以不必声明</li><li>等号不是必需的</li></ul><p>大体上就是这样。scala函数定义的规则还有很多，这里只是管中窥豹，简单说下。  </p><p>另外，在上面的代码中我们可以看到每一行语句末尾都没有使用分号，这是scala和java一个很大的不同。在scala中，分号是可选的。若一行中只有一个语句，分号可以不填；若一行中有多个语句，分号则是必填。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala提供的交互式解释器也是一种快速体验scala的一种方式。  &lt;/p&gt;
&lt;h2 id=&quot;使用交互式解释器&quot;&gt;&lt;a href=&quot;#使用交互式解释器&quot; class=&quot;headerlink&quot; title=&quot;使用交互式解释器&quot;&gt;&lt;/a&gt;使用交互式解释器&lt;/h2&gt;&lt;p&gt;在安装
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>快速体验Scala - Scasite</title>
    <link href="http://scala.chobit.com/wiki/20180421/a01-quickStart/"/>
    <id>http://scala.chobit.com/wiki/20180421/a01-quickStart/</id>
    <published>2018-04-21T08:06:42.000Z</published>
    <updated>2018-04-21T13:45:47.498Z</updated>
    
    <content type="html"><![CDATA[<p>前面一节简略说了Scala开发环境的准备工作。如果还没有安装Scala的开发环境，也可以快速在<a href="https://scastie.scala-lang.org" title="Scasite" rel="external nofollow noopener noreferrer" target="_blank">Scasite</a>上快速体验一下。  </p><p>还是按传统，来一个HelloWorld：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;  </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中我们使用object关键字声明了一个结构：HelloWorld。之所以用“结构”这个词，是因为在没有上下文的情况下要描述清楚scala的object需要费些力气。不过可以用Java的一些概念来勉强描述下：scala的object相当于Java中的一个没有构造器，只有静态方法的final类。</p><p>再来看一下这个object里定义方法的形式：声明方法使用了def关键字，然后是方法名，方法名之后的括号中是参数列表，参数列表后一个等号紧跟着方法体。因为方法体只有一行，所以就没有用花括号括起来。参数列表中参数名和参数类型用冒号分隔，参数名在前。</p><p>打开<a href="https://scastie.scala-lang.org" title="Scasite" rel="external nofollow noopener noreferrer" target="_blank">Scasite</a>。将这段代码放在Scasite的编辑框里，点击Run按钮执行。可以看到在下方的Console中输出了Hello Word！。<br>不过同时还出现了一行提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You don&apos;t need a main method (or extends Scastie) in Worksheet Mode</span><br></pre></td></tr></table></figure></p><p>说实话，我不太清楚Scasite的Worksheet Mode是什么意思。不过这提醒我了：Scala也是一种脚本语言。所以我们可以直接在Scasite的编辑框里输入下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure></p><p>点击Run按钮执行，结果与之前一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一节简略说了Scala开发环境的准备工作。如果还没有安装Scala的开发环境，也可以快速在&lt;a href=&quot;https://scastie.scala-lang.org&quot; title=&quot;Scasite&quot; rel=&quot;external nofollow noopener n
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala手账 - 主页</title>
    <link href="http://scala.chobit.com/wiki/20180421/index/"/>
    <id>http://scala.chobit.com/wiki/20180421/index/</id>
    <published>2018-04-21T03:45:57.000Z</published>
    <updated>2018-04-30T23:13:36.016Z</updated>
    
    <content type="html"><![CDATA[<p>scala学习：</p><ol><li><a href="https://scala.chobit.org/wiki/20180419/a00-prepareEnv/" target="_blank" rel="noopener">准备开发环境</a>  </li><li><a href="https://scala.chobit.org/wiki/20180421/a01-quickStart/" target="_blank" rel="noopener">快速体验scala - Scasite</a></li><li><a href="https://scala.chobit.org/wiki/20180421/a02-ineractiveCoding/" target="_blank" rel="noopener">快速体验scala - 交互式编程</a></li><li><a href="https://scala.chobit.org/wiki/20180422/a03-comment/" target="_blank" rel="noopener">使用注释</a></li><li><a href="https://scala.chobit.org/wiki/20180423/a04-basicType/" target="_blank" rel="noopener">基本类型</a></li><li><a href="https://scala.chobit.org/wiki/20180423/a05-operatorsInScala/" target="_blank" rel="noopener">运算符和优先级</a></li><li><a href="https://scala.chobit.org/wiki/20180424/a06-varAndVal/" target="_blank" rel="noopener">val和var变量</a></li><li><a href="https://scala.chobit.org/wiki/20180424/a07-stringAndMultiLineString/" target="_blank" rel="noopener">字符串和多行字符串</a></li><li><a href="https://scala.chobit.org/wiki/20180426/a08-classDefine/" target="_blank" rel="noopener">类定义和构造器</a></li><li><a href="https://scala.chobit.org/wiki/20180427/a09-classExtends/" target="_blank" rel="noopener">类继承</a></li><li><a href="https://scala.chobit.org/wiki/20180427/a10-independentAndCompanionObject/" target="_blank" rel="noopener">单例、独立对象和伴生对象</a>  </li><li><a href="https://scala.chobit.org/wiki/20180429/a11-accessModifier/" target="_blank" rel="noopener">访问修饰符</a></li><li><a href="https://scala.chobit.org/wiki/20180429/a12-loopAndLoopControl/" target="_blank" rel="noopener">循环和循环控制</a></li></ol><p>scala杂技：  </p><ol><li><a href="https://scala.chobit.org/wiki/20180428/b000-useYield/" target="_blank" rel="noopener">使用yield关键字</a></li><li><a href="https://scala.chobit.org/wiki/20180428/b001-useVeriableArguments/" target="_blank" rel="noopener">使用变长参数</a></li><li><a href="https://scala.chobit.org/wiki/20180429/b002-assignmentSymbol/" target="_blank" rel="noopener">scala赋值符号“=”</a></li><li><a href="https://scala.chobit.org/wiki/20180429/b003-equalitySymbol/" target="_blank" rel="noopener">scala等于符号“==”</a></li></ol><p>This is Home Page.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala学习：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://scala.chobit.org/wiki/20180419/a00-prepareEnv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;准备开发环境&lt;/a&gt;  &lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="scala学习" scheme="http://scala.chobit.com/tags/scala%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>准备开发环境</title>
    <link href="http://scala.chobit.com/wiki/20180419/a00-prepareEnv/"/>
    <id>http://scala.chobit.com/wiki/20180419/a00-prepareEnv/</id>
    <published>2018-04-19T14:04:33.000Z</published>
    <updated>2018-04-21T13:46:09.577Z</updated>
    
    <content type="html"><![CDATA[<p>Scala开发环境准备步骤如下：  </p><ul><li>安装JDK环境，建议选择JDK8版本</li><li>安装Scala开发环境，选择最新版就行</li></ul><p>聊作解释：建议JDK选择1.8是因为稍后会用到Gradle，Gradle对JDK9的兼容性目前并不好。不过，稍后许有调整也未可知。  </p><p>IDE可以选择IntelliJ Idea， Eclipse的Scala IDE也未尝不可。我是颜控党，所以选择了IDEA。  </p><p>关于环境就简单说这点儿。简单说下这次的学习计划：争取每天学习一个Scala的特性，间或会引入一些java的内容。  </p><p>在这里立一个Flag。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala开发环境准备步骤如下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装JDK环境，建议选择JDK8版本&lt;/li&gt;
&lt;li&gt;安装Scala开发环境，选择最新版就行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聊作解释：建议JDK选择1.8是因为稍后会用到Gradle，Gradle对JDK9的兼
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="准备" scheme="http://scala.chobit.com/tags/%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
</feed>
