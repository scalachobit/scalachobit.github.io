<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCALA 手账</title>
  
  <subtitle>scala</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scala.chobit.org/"/>
  <updated>2018-06-28T23:13:23.497Z</updated>
  <id>http://scala.chobit.org/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>case表达式里的模式变量和常量</title>
    <link href="http://scala.chobit.org/wiki/20180628/a32-caseConstant/"/>
    <id>http://scala.chobit.org/wiki/20180628/a32-caseConstant/</id>
    <published>2018-06-28T14:18:32.000Z</published>
    <updated>2018-06-28T23:13:23.497Z</updated>
    
    <content type="html"><![CDATA[<p>在进行模式匹配时可以使用模式常量和模式变量。</p><p>模式匹配中的占位符即为模式变量。</p><p>关于模式常量可以看下下面的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MIN</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(input: <span class="type">Int</span>) &#123;</span><br><span class="line">    input <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MIN</span> =&gt; println(<span class="string">"You matched min"</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unreachable!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Sample</span>().process(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="type">Sample</span>().process(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>代码中的“MIN”就是一个模式常量。执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You matched min</span><br><span class="line">Unreachable!!</span><br></pre></td></tr></table></figure><p>按照约定，Scala中模式变量要以小写字母开头，常量要以大写字母开头。所以这里一定要注意大小写，下面是一个错误的示范：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> max = <span class="number">100</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MIN</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(input: <span class="type">Int</span>) &#123;</span><br><span class="line">    input <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> max =&gt; println(<span class="string">"Don't try this"</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MIN</span> =&gt; println(<span class="string">"You matched min"</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unreachable!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Sample</span>().process(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="type">Sample</span>().process(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="type">Sample</span>().process(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在解释器里可以清楚地看到warning信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;   class Sample &#123;</span><br><span class="line">     |</span><br><span class="line">     |     val max = 100</span><br><span class="line">     |     val MIN = 0</span><br><span class="line">     |</span><br><span class="line">     |     def process(input: Int) &#123;</span><br><span class="line">     |       input match &#123;</span><br><span class="line">     |         <span class="keyword">case</span> max =&gt; println(<span class="string">"Don't try this"</span>)</span><br><span class="line">     |         <span class="keyword">case</span> MIN =&gt; println(<span class="string">"You matched min"</span>)</span><br><span class="line">     |         <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unreachable!!"</span>)</span><br><span class="line">     |       &#125;</span><br><span class="line">     |     &#125;</span><br><span class="line">     |   &#125;</span><br><span class="line">&lt;console&gt;:18: warning: patterns after a variable pattern cannot match (SLS 8.1.1)</span><br><span class="line">If you intended to match against value max <span class="keyword">in</span> class Sample, you must use backticks, like: <span class="keyword">case</span> `max` =&gt;</span><br><span class="line">               <span class="keyword">case</span> max =&gt; println(<span class="string">"Don't try this"</span>)</span><br><span class="line">                    ^</span><br><span class="line">&lt;console&gt;:19: warning: unreachable code due to variable pattern <span class="string">'max'</span> on line 18</span><br><span class="line">               <span class="keyword">case</span> MIN =&gt; println(<span class="string">"You matched min"</span>)</span><br><span class="line">                                  ^</span><br><span class="line">&lt;console&gt;:20: warning: unreachable code due to variable pattern <span class="string">'max'</span> on line 18</span><br><span class="line">               <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unreachable!!"</span>)</span><br><span class="line">                                ^</span><br><span class="line">&lt;console&gt;:19: warning: unreachable code</span><br><span class="line">               <span class="keyword">case</span> MIN =&gt; println(<span class="string">"You matched min"</span>)</span><br><span class="line">                                  ^</span><br><span class="line">defined class Sample</span><br></pre></td></tr></table></figure><p>警告信息提示因为错误的使用了模式值“max”，导致其后的匹配代码均不可达。看下执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;   new Sample().process(100)</span><br><span class="line">Don<span class="string">'t try this</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">scala&gt;   new Sample().process(0)</span></span><br><span class="line"><span class="string">Don'</span>t try this</span><br><span class="line"></span><br><span class="line">scala&gt;   new Sample().process(10)</span><br><span class="line">Don<span class="string">'t try this</span></span><br></pre></td></tr></table></figure><p>可以看到程序可以执行，但是无论我们输入什么值，都只会匹配到第一个匹配项“max”。</p><p>如果偏要使用这个值的话可以通过object或类的实例来引用这个变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> max = <span class="number">100</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MIN</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(input: <span class="type">Int</span>) &#123;</span><br><span class="line">    input <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">this</span>.max =&gt; println(<span class="string">"You matched max"</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MIN</span> =&gt; println(<span class="string">"You matched min"</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unreachable!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用class的实例this来引用了val变量max。这时执行代码结果是正常的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You matched max</span><br><span class="line">You matched min</span><br><span class="line">Unreachable!!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行模式匹配时可以使用模式常量和模式变量。&lt;/p&gt;
&lt;p&gt;模式匹配中的占位符即为模式变量。&lt;/p&gt;
&lt;p&gt;关于模式常量可以看下下面的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="模式变量" scheme="http://scala.chobit.org/tags/%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F/"/>
    
      <category term="模式常量" scheme="http://scala.chobit.org/tags/%E6%A8%A1%E5%BC%8F%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://scala.chobit.org/wiki/20180628/b019-tryCatchException/"/>
    <id>http://scala.chobit.org/wiki/20180628/b019-tryCatchException/</id>
    <published>2018-06-28T14:17:48.000Z</published>
    <updated>2018-06-28T23:25:41.409Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一段异常处理的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  println(<span class="string">"start...."</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> re: <span class="type">RuntimeException</span> =&gt; println(<span class="string">"this is RuntimeException"</span>)</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; println(<span class="string">"this is Exception"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scala中没有多重catch block。而是使用模式匹配来逐级匹配异常并进行处理。</p><p>看下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start....</span><br><span class="line">this is RuntimeException</span><br></pre></td></tr></table></figure><p>还可以catch Error：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  println(<span class="string">"start...."</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OutOfMemoryError</span>()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> re: <span class="type">RuntimeException</span> =&gt; println(<span class="string">"this is RuntimeException"</span>)</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; println(<span class="string">"this is Exception"</span>)</span><br><span class="line">  <span class="keyword">case</span> error: <span class="type">Error</span> =&gt; println(<span class="string">"this is an error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start....</span><br><span class="line">this is an error</span><br></pre></td></tr></table></figure><p>当然也可以捕捉Throwable，但是在模式匹配中使用通配符却是一个更好地选项：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  println(<span class="string">"start...."</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Throwable</span>()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> re: <span class="type">RuntimeException</span> =&gt; println(<span class="string">"this is RuntimeException"</span>)</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; println(<span class="string">"this is Exception"</span>)</span><br><span class="line">  <span class="keyword">case</span> error: <span class="type">Error</span> =&gt; println(<span class="string">"this is an error"</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"We catched something."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start....</span><br><span class="line">We catched something.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是一段异常处理的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="try" scheme="http://scala.chobit.org/tags/try/"/>
    
      <category term="catch" scheme="http://scala.chobit.org/tags/catch/"/>
    
      <category term="异常" scheme="http://scala.chobit.org/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>模式匹配</title>
    <link href="http://scala.chobit.org/wiki/20180620/a31-matchCase/"/>
    <id>http://scala.chobit.org/wiki/20180620/a31-matchCase/</id>
    <published>2018-06-20T13:45:14.000Z</published>
    <updated>2018-06-28T22:37:38.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在java中有switch/case这样的模式匹配语句，可以匹配的类型包括int,byte,char,short, enum，在java8又支持了字符串。</p><p>在scala中也有类似的模式匹配语句，即match-case。scala中的match-case匹配的类型更为广泛：它是对Any类型起作用的。</p><p>来看个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activity</span></span>(day: <span class="type">String</span>) &#123;</span><br><span class="line">  day <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Sunday"</span> =&gt; println(<span class="string">"Eat, sleep, repeat... "</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Saturday"</span> =&gt; println(<span class="string">"Hang out with friends... "</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Monday"</span> =&gt; println(<span class="string">"...code for fun..."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Friday"</span> =&gt; println(<span class="string">"...read a good book..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="string">"Monday"</span>, <span class="string">"Sunday"</span>, <span class="string">"Saturday"</span>).foreach &#123;</span><br><span class="line">  activity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...code for fun...</span><br><span class="line">Eat, sleep, repeat... </span><br><span class="line">Hang out with friends... </span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: Tuesday (of class java.lang.String)</span><br><span class="line">at com.zhyea.MyApp$.activity(MyApp.scala:7)</span><br><span class="line">at com.zhyea.MyApp$$anonfun$1.apply(MyApp.scala:16)</span><br><span class="line">at com.zhyea.MyApp$$anonfun$1.apply(MyApp.scala:16)</span><br></pre></td></tr></table></figure><p>有没有注意到，这里和java是有些不一样的，最大的区别是没有用到break关键字。但是在scala中默认是匹配上了后就不会继续匹配了。窃以为这是比java做得好的地方。</p><p>通过执行结果可以看到scala的模式匹配有一个需要注意的地方：没有匹配到会抛出异常。这一点在使用的时候要小心。</p><p>在Java的switch/case中，可以用<strong>default</strong>关键字来执行默认通用匹配处理。在scala中也有符号起到了类似的作用，就是“_”。继续修改下上面的代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def activity(<span class="built_in">day</span>: <span class="keyword">String</span>) &#123;</span><br><span class="line">  <span class="built_in">day</span> <span class="built_in">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Sunday"</span> =&gt; <span class="built_in">println</span>(<span class="string">"Eat, sleep, repeat... "</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Saturday"</span> =&gt; <span class="built_in">println</span>(<span class="string">"Hangout with friends... "</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Monday"</span> =&gt; <span class="built_in">println</span>(<span class="string">"...code for fun..."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Friday"</span> =&gt; <span class="built_in">println</span>(<span class="string">"...read a good book..."</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="built_in">println</span>(<span class="string">"...nothing..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List(<span class="string">"Monday"</span>, <span class="string">"Sunday"</span>, <span class="string">"Saturday"</span>, <span class="string">"Tuesday"</span>).foreach &#123;</span><br><span class="line">  activity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不贴执行结果了。</p><h2 id="多类型匹配"><a href="#多类型匹配" class="headerlink" title="多类型匹配"></a>多类型匹配</h2><p>case表达式并不限于在match语句里使用。这里，包含case表达式的代码块就是一个简单函数值。这一点在前面学习<a href="wiki/20180508/a20-partialFunction/">偏函数</a>的时候也有提到过。</p><p>刚才说过match-case支持的类型是Any。在java支持的基本类型、枚举和字符串之外，scala还支持支持其他任意类型的模式匹配，比如列表和元组：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processCoordinates</span></span>(input: <span class="type">Any</span>) &#123;</span><br><span class="line">  input <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (a, b) =&gt; printf(<span class="string">"Processing (%d, %d)... "</span>, a, b)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"white"</span>) =&gt; println(<span class="string">"Stars and Stripes..."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, _*) =&gt; println(<span class="string">"colors red, blue, ... "</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"done"</span> =&gt; println(<span class="string">"done"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processCoordinates((<span class="number">39</span>, <span class="number">-104</span>))</span><br><span class="line">processCoordinates(<span class="string">"done"</span>)</span><br><span class="line">processCoordinates(<span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>))</span><br><span class="line">processCoordinates(<span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"white"</span>))</span><br></pre></td></tr></table></figure><p>看下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Processing (39, -104)... done</span><br><span class="line">colors red, blue, ... </span><br><span class="line">Stars and Stripes...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="匹配时类型声明和卫述语句"><a href="#匹配时类型声明和卫述语句" class="headerlink" title="匹配时类型声明和卫述语句"></a>匹配时类型声明和卫述语句</h2><p>上面的代码还是有些不足之处，对元组的匹配还可以更细致些，比如针对不同类型的值可以做不同的处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(input: <span class="type">Any</span>) &#123;</span><br><span class="line">  input <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; println(<span class="string">"Processing (int, int)... "</span>)</span><br><span class="line">    <span class="keyword">case</span> (a: <span class="type">Double</span>, b: <span class="type">Double</span>) =&gt; println(<span class="string">"Processing (double, double)... "</span>)</span><br><span class="line">    <span class="keyword">case</span> msg: <span class="type">Int</span> <span class="keyword">if</span> (msg &gt; <span class="number">1000000</span>) =&gt; println(<span class="string">"Processing int &gt; 1000000"</span>)</span><br><span class="line">    <span class="keyword">case</span> msg: <span class="type">Int</span> =&gt; println(<span class="string">"Processing int... "</span>)</span><br><span class="line">    <span class="keyword">case</span> msg: <span class="type">String</span> =&gt; println(<span class="string">"Processing string... "</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; printf(<span class="string">"Can't handle %s... "</span>, input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process((<span class="number">34.2</span>, <span class="number">-159.3</span>))</span><br><span class="line">process(<span class="number">0</span>)</span><br><span class="line">process(<span class="number">1000001</span>)</span><br><span class="line">process(<span class="number">2.2</span>)</span><br></pre></td></tr></table></figure><p>代码中演示了在case语句里如何为单一的值和元组元素指定类型。除了类型之外，还可以使用卫述句（guard）。卫述句用if从句表示，在模式匹配里，对表达式求值前必须满足卫述句。</p><p>代码中用到了占位符，即：a, b, msg。通过占位符可以比较方便地调用进行匹配的值。</p><p>看下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Processing (double, double)... </span><br><span class="line">Processing int... </span><br><span class="line">Processing int &gt; 1000000</span><br><span class="line">Can&apos;t handle 2.2... </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>case的顺序很重要。Scala会自上而下地求值。所以，上面代码中的5和6两行是不能交换的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在java中有switch/case这样的模式匹配语句，可以匹配的类型包括int,byte,char,short, enum，在java8又
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="match" scheme="http://scala.chobit.org/tags/match/"/>
    
      <category term="case" scheme="http://scala.chobit.org/tags/case/"/>
    
      <category term="模式匹配" scheme="http://scala.chobit.org/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>unapply方法</title>
    <link href="http://scala.chobit.org/wiki/20180611/b016-unapplyMethod/"/>
    <id>http://scala.chobit.org/wiki/20180611/b016-unapplyMethod/</id>
    <published>2018-06-11T14:13:58.000Z</published>
    <updated>2018-06-17T13:30:07.361Z</updated>
    
    <content type="html"><![CDATA[<p>对于unapply方法，先来看一个实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(str: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> idx = str.indexOf(<span class="string">"-"</span>)</span><br><span class="line">    <span class="keyword">val</span> name = str.substring(<span class="number">0</span>, idx)</span><br><span class="line">    <span class="keyword">val</span> lang = str.substring(idx + <span class="number">1</span>)</span><br><span class="line">    <span class="type">Some</span>(<span class="string">s"<span class="subst">$name</span> is a <span class="subst">$lang</span> coder."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">Coder</span>(s) = <span class="string">"robin-scala"</span></span><br><span class="line"></span><br><span class="line">  println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这已经是一段完整的程序了。如下是执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robin is a scala coder.</span><br></pre></td></tr></table></figure></p><p>注意下程序的第14行（val Coder(s) = “robin-scala”），就是在这一行调用了unapply方法，其意义等价于如下代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="type">Coder</span>.unapply(<span class="string">"robin-scala"</span>).get</span><br></pre></td></tr></table></figure></p><p>unapply方法的使用在这里看起来怪怪的：“Coder(s)”的写法看起来像是调用构造器，但是实际上并不是调用构造方法，而是从一个字符串提取出一些信息。</p><p>我们再来看另一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Coder</span>(name, age)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(c: <span class="type">Coder</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Some</span>((c.name, c.age))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> robin = <span class="type">Coder</span>(<span class="string">"robin"</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">Coder</span>(name, age) = robin</span><br><span class="line"></span><br><span class="line">  println(<span class="string">s"<span class="subst">$name</span> is <span class="subst">$age</span> years old."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了Coder的伴生类和伴生对象。在伴生对象中创建了一个apply方法和一个unapply方法。在场景object MyApp中使用object Coder的apply方法创建了一个class Coder的实例robin，然后又通过Coder的unapply方法取出了实例robin的name和age两个属性。</p><p>大家应该能看出来，在scala中apply和unapply方法是有默认的特殊意义的：</p><ul><li>apply方法和unapply方法的作用在某种意义上是相反的；</li><li>apply方法通常用于创建实例；</li><li>unapply方法通常用于从实例中提取出实例的属性。</li></ul><p>从上面的两个例子，我们可以推断出unapply方法有如下特征：unapply通常需要定义在object中，作用是将实例的一些信息提取出来；其适用场景多发生在模式匹配中；因为模式匹配可能失败，所以unapply方法的返回值类型一般为Option[]。</p><p>来看一下unapply在模式匹配中的使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>(<span class="params">val name: <span class="type">String</span>, val lang: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(c: <span class="type">Coder</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">Some</span>((c.name, c.lang))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">Coder</span>(<span class="string">"robin"</span>, <span class="string">"scala"</span>)</span><br><span class="line"></span><br><span class="line">  c <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Coder</span>(name, <span class="string">"scala"</span>) =&gt; println(<span class="string">s"<span class="subst">$name</span> is a scala coder."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Coder</span>(name, <span class="string">"java"</span>) =&gt; println(<span class="string">s"<span class="subst">$name</span> is a java coder."</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Maybe this is a coder"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>unapply方法返回值也可以是Boolean类型。这种方式适用于只需要对属性进行检查，而不必提取的场景。来看一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IsElder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(age: <span class="type">Int</span>): <span class="type">Boolean</span> = age &gt; <span class="number">36</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> num = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  num <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> n @ <span class="type">IsElder</span>() =&gt; println(<span class="string">s"<span class="subst">$n</span> is greater than 36"</span>)</span><br><span class="line">    <span class="keyword">case</span> n =&gt; println(<span class="string">s"<span class="subst">$n</span> is lower than 36"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面的几个示例中unapply方法返回的值的长度都是固定的，不过某些情况下需要返回一些不固定长度的返回值，此时可以使用容器来存储返回值，但是更好的方案是使用unapplySeq方法。来看一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>(<span class="params">val name: <span class="type">String</span>, val langs: <span class="type">String</span>*</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapplySeq</span></span>(c: <span class="type">Coder</span>): <span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> buffer = <span class="type">ListBuffer</span>(c.name)</span><br><span class="line">    buffer ++= c.langs.toBuffer</span><br><span class="line">    <span class="type">Some</span>(buffer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> robin = <span class="keyword">new</span> <span class="type">Coder</span>(<span class="string">"robin"</span>, <span class="string">"java"</span>, <span class="string">"scala"</span>, <span class="string">"python"</span>)</span><br><span class="line">  <span class="keyword">val</span> tom = <span class="keyword">new</span> <span class="type">Coder</span>(<span class="string">"tom"</span>, <span class="string">"java"</span>, <span class="string">"scala"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(coder: <span class="type">Coder</span>) = coder <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Coder</span>(name, lang1, lang2, lang3) =&gt; println(<span class="string">s"<span class="subst">$name</span> works with 3 languages: <span class="subst">$lang1</span>, <span class="subst">$lang2</span>, <span class="subst">$lang3</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Coder</span>(name, lang1, lang2) =&gt; println(<span class="string">s"<span class="subst">$name</span> works with 2 languages: <span class="subst">$lang1</span>, <span class="subst">$lang2</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo(robin)</span><br><span class="line">  foo(tom)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于unapply方法和提取器暂时先了解这些内容好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于unapply方法，先来看一个实例：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="unapply" scheme="http://scala.chobit.org/tags/unapply/"/>
    
      <category term="提取器" scheme="http://scala.chobit.org/tags/%E6%8F%90%E5%8F%96%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>update方法</title>
    <link href="http://scala.chobit.org/wiki/20180611/b015-updateMethod/"/>
    <id>http://scala.chobit.org/wiki/20180611/b015-updateMethod/</id>
    <published>2018-06-11T14:13:57.000Z</published>
    <updated>2018-06-13T00:35:31.820Z</updated>
    
    <content type="html"><![CDATA[<p>之前有介绍过apply方法，比如下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(arg1, arg2, ...)</span><br></pre></td></tr></table></figure></p><p>如果foo不是一个函数或者方法, 那么这个表达式等同于调用apply方法。但是如果它出现在赋值语句的左侧, 即 foo(arg1, arg2, …) = value, 那么调用的就是update方法。</p><p>看个具体的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(key: <span class="type">String</span>, value: <span class="type">String</span>) = println(<span class="string">s"<span class="subst">$name</span>'s  <span class="subst">$key</span> is <span class="subst">$value</span>."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> robin = <span class="keyword">new</span> <span class="type">Coder</span>(<span class="string">"robin"</span>)</span><br><span class="line"></span><br><span class="line">robin(<span class="string">"job"</span>) = <span class="string">"coder"</span></span><br></pre></td></tr></table></figure><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robin&apos;s  job is coder.</span><br></pre></td></tr></table></figure></p><p>如示例中所示，update方法通常可用于键值对或“索引-&gt;值”的赋值与更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前有介绍过apply方法，比如下面的代码：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="update" scheme="http://scala.chobit.org/tags/update/"/>
    
  </entry>
  
  <entry>
    <title>一元操作符</title>
    <link href="http://scala.chobit.org/wiki/20180611/b017-unaryMethod/"/>
    <id>http://scala.chobit.org/wiki/20180611/b017-unaryMethod/</id>
    <published>2018-06-11T14:06:59.000Z</published>
    <updated>2018-06-11T14:12:12.392Z</updated>
    
    <content type="html"><![CDATA[<p>一元操作符是前置操作符，同“:”结尾的方法一样，也是以其后的实例为目标的。  </p><p>一元操作符包括+、-、！和~。  </p><p>在调用的时候一元操作符被转化为名为“unary_ + 操作符”的方法调用。看下下面的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>= println(<span class="string">"Called unary +"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unary_-</span> </span>= println(<span class="string">"called unary -"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unary_!</span> </span>= println(<span class="string">"called unary !"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unary_~</span> </span>= println(<span class="string">"called unary ~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sample = <span class="keyword">new</span> <span class="type">Sample</span></span><br><span class="line">+sample</span><br><span class="line">-sample</span><br><span class="line">!sample</span><br><span class="line">~sample</span><br></pre></td></tr></table></figure><p>Scala对方法名有规定，运算符不允许放在字母、数字这样的字符后面，除非这个运算符有下划线作为前缀。也就是说，一个方法不能被命名为jumpOver:()，只可以被命名为jumpOver_:()。</p><p>看下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Called unary +</span><br><span class="line">called unary -</span><br><span class="line">called unary !</span><br><span class="line">called unary ~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一元操作符是前置操作符，同“:”结尾的方法一样，也是以其后的实例为目标的。  &lt;/p&gt;
&lt;p&gt;一元操作符包括+、-、！和~。  &lt;/p&gt;
&lt;p&gt;在调用的时候一元操作符被转化为名为“unary_ + 操作符”的方法调用。看下下面的例子：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="操作符" scheme="http://scala.chobit.org/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>以冒号结尾的方法</title>
    <link href="http://scala.chobit.org/wiki/20180611/b018-methodsEndWithColon/"/>
    <id>http://scala.chobit.org/wiki/20180611/b018-methodsEndWithColon/</id>
    <published>2018-06-10T22:43:51.000Z</published>
    <updated>2018-06-28T13:35:05.525Z</updated>
    
    <content type="html"><![CDATA[<p>这里说的是一个命名约定：如果方法以冒号（:）结尾，则调用目标是运算符后面的实例。</p><p>比如下面这个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">^</span></span>(moon: <span class="type">Moon</span>) = println(<span class="string">"Cow jumped over the moon"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">^</span></span>:(cow: <span class="type">Cow</span>) = println(<span class="string">"This cow jumped over the moon too"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> cow = <span class="keyword">new</span> <span class="type">Cow</span></span><br><span class="line"><span class="keyword">val</span> moon = <span class="keyword">new</span> <span class="type">Moon</span></span><br><span class="line"></span><br><span class="line">cow ^ moon</span><br><span class="line">cow ^: moon</span><br></pre></td></tr></table></figure><p>看一下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cow jumped over the moon</span><br><span class="line">This cow jumped over the moon too</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里说的是一个命名约定：如果方法以冒号（:）结尾，则调用目标是运算符后面的实例。&lt;/p&gt;
&lt;p&gt;比如下面这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="colon" scheme="http://scala.chobit.org/tags/colon/"/>
    
      <category term="冒号" scheme="http://scala.chobit.org/tags/%E5%86%92%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>scala集合概述</title>
    <link href="http://scala.chobit.org/wiki/20180608/a30-collectionOverview/"/>
    <id>http://scala.chobit.org/wiki/20180608/a30-collectionOverview/</id>
    <published>2018-06-08T14:28:19.000Z</published>
    <updated>2018-06-09T04:00:31.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h2><p>scala的集合包括Set、List和Map。三种集合的特征和Java中的一样。scala为每种集合都提供了可变和不可变两种版本，分别位于scala.collection.mutable或scala.collection.immutable包下。scala建议使用尽量使用不可变集合，尤其是在多线程环境下。scala默认的集合就是不变的版本。</p><p>可变集合没什么好说的，java中的集合就是。来看一个不可变集合的实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>)</span><br><span class="line"><span class="keyword">var</span> c2 = c1</span><br><span class="line"></span><br><span class="line">c2 += <span class="string">"Black"</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"c2: "</span> + c2)</span><br><span class="line">println(<span class="string">"c1: "</span> + c1)</span><br></pre></td></tr></table></figure></p><p>代码中先创建了一个不可变的Set实例并将之赋给一个val变量c1。而后又将immutable Set实例通过c1赋给了var变量c2。c2调用了immutable Set的“+”方法，“+”方法的作用是在原集合的基础上添加元素并创建一个新的实例。所以现在c2是另一个Set实例了。看下程序输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c2: Set(Blue, Green, Red, Black)</span><br><span class="line">c1: Set(Blue, Green, Red)</span><br></pre></td></tr></table></figure></p><h2 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h2><p>主要是看一下集合的几个常用方法。至于其他的方法有机会再单独解释。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h4><p>filter()方法用来从Set中过滤获取含有指定特征的元素。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"><span class="keyword">val</span> filteredSet = colors1 filter (_ contains <span class="string">"l"</span>)</span><br><span class="line">println(filteredSet mkString <span class="string">","</span>)</span><br></pre></td></tr></table></figure><p>上面的代码从一个Set中过滤出了含有字符“l”的元素，而后调用mkString方法将过滤结果拼接打印出来。看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blue,yellow</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="++()方法"></a>++()方法</h4><p>++()方法用来拼接两个Set。示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"><span class="keyword">val</span> colors2 = <span class="type">Set</span>(<span class="string">"White"</span>, <span class="string">"Black"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> combinedSet = colors1 ++ colors2</span><br><span class="line">println(combinedSet mkString <span class="string">","</span>)</span><br></pre></td></tr></table></figure></p><p>看一下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Red,Blue,White,Black,Green,yellow</span><br></pre></td></tr></table></figure></p><h4 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h4><p>map()方法可以对Set的每个元素进行处理，最后返回一个新的集合。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> colorSet = colors1.map(<span class="string">"color is : "</span> + _)</span><br><span class="line"></span><br><span class="line">colorSet.foreach(println)</span><br></pre></td></tr></table></figure><p>这里打印Set元素时使用了内置的迭代器foreach。执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color is : Blue</span><br><span class="line">color is : Green</span><br><span class="line">color is : Red</span><br><span class="line">color is : yellow</span><br></pre></td></tr></table></figure></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="filterKeys-方法"><a href="#filterKeys-方法" class="headerlink" title="filterKeys()方法"></a>filterKeys()方法</h4><p>filterKeys()方法用来对Map的key进行过滤，示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line"><span class="keyword">val</span> filteredMap = roster.filterKeys.(_ contains (<span class="string">"Jac"</span>))</span><br><span class="line">println(<span class="string">"Filtered Size : "</span> + filteredMap.size)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filtered Size : 1</span><br></pre></td></tr></table></figure></p><h4 id="filter-方法-1"><a href="#filter-方法-1" class="headerlink" title="filter()方法"></a>filter()方法</h4><p>也可以使用filter()方法来执行过滤，不过filter()方法中的函数值操作的对象是Key-Value对。看一下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line"><span class="keyword">val</span> filteredMap = roster.filter &#123;</span><br><span class="line">  ele =&gt;</span><br><span class="line">    <span class="keyword">val</span> (k, v) = ele</span><br><span class="line">    k contains (<span class="string">"Jac"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Filtered Size : "</span> + filteredMap.size)</span><br></pre></td></tr></table></figure><p>执行结果和上面的filterKeys方法是一样的，就不重复贴了。</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get()方法用来从Map中取值，不过返回值的类型是Optional[T]，示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line">println(<span class="string">"Jack"</span> +  <span class="string">" is a "</span> + (roster.get(<span class="string">"Jack"</span>).get )</span><br></pre></td></tr></table></figure></p><p>说实话，我不太喜欢Optional，还好scala不需要让我忍受这个东西，它还提供了另一种更简洁的获取kv对的方式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line">println(<span class="string">"Jack"</span> +  <span class="string">" is a "</span> + roster(<span class="string">"Jack"</span>) )</span><br></pre></td></tr></table></figure></p><p>在上面的代码里我们直接在Map对象后面使用了一个括号来取值。这是使用了Map的一个工厂方法apply。</p><h4 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a>update()方法</h4><p>update()方法可以用来“更新”Map对象。因为我们用的Map是一个immutable Map的对象，它的“更新”并不会影响当前的对象，而是返回一个新的对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line"><span class="keyword">val</span> updatedRoster = roster.updated(<span class="string">"Jane"</span>, <span class="string">"Nurse"</span>)</span><br><span class="line">println(<span class="string">"Jane"</span> +  <span class="string">" is a "</span> + roster(<span class="string">"Jane"</span>) )</span><br><span class="line">println(<span class="string">"Jane"</span> +  <span class="string">" is a "</span> + updatedRoster(<span class="string">"Jane"</span>) )</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jane is a Teacher</span><br><span class="line">Jane is a Nurse</span><br></pre></td></tr></table></figure></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>在scala中Set和Map都有可变和不变两种实现，但是List只有不变的实现。scala中的List实现有些类似于java的LinkedList。scala的List的大部分操作都是围绕head和tail执行的。</p><p>如下是一个List使用的示例，我们要访问List示例的第一个元素可以使用list.head()方法也可以直接执行list(0)：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line">println(list1.head)</span><br><span class="line">println(list1(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Red</span><br><span class="line">Red</span><br></pre></td></tr></table></figure></p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="::()方法"></a>::()方法</h4><p>这个方法用于在List前添加元素。a :: list可以读作“在List前添加a”。示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="string">"Black"</span>::list1</span><br><span class="line">println(list1.mkString(<span class="string">","</span>))</span><br><span class="line">println(list2.mkString(<span class="string">","</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Red,Yellow,Blue</span><br><span class="line">Black,Red,Yellow,Blue</span><br></pre></td></tr></table></figure></p><h4 id="方法-2"><a href="#方法-2" class="headerlink" title=":::()方法"></a>:::()方法</h4><p>这个方法用于将一个List实例添加到另一个List实例前面。list ::: listA 可以读作“在listA前添加list”。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="string">"Black"</span> :: list1</span><br><span class="line"><span class="keyword">val</span> combinedList = list2 ::: list1</span><br><span class="line"></span><br><span class="line">println(list1.mkString(<span class="string">","</span>))</span><br><span class="line">println(list2.mkString(<span class="string">","</span>))</span><br><span class="line">println(combinedList.mkString(<span class="string">","</span>))</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Red,Yellow,Blue</span><br><span class="line">Black,Red,Yellow,Blue</span><br><span class="line">Black,Red,Yellow,Blue,Red,Yellow,Blue</span><br></pre></td></tr></table></figure><p>请注意：以上两个List的方法操作对象都是操作符后的List实例。</p><h4 id="forall-和exists"><a href="#forall-和exists" class="headerlink" title="forall()和exists()"></a>forall()和exists()</h4><p>用forall()方法可以检查是否所有元素都满足某一特定条件。而想了解是否存在某些元素满足特定条件，可以用exists()。示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line">println(list1 forall (_ contains (<span class="string">"R"</span>)))</span><br><span class="line">println(list1 exists (_ contains (<span class="string">"R"</span>)))</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可变与不可变&quot;&gt;&lt;a href=&quot;#可变与不可变&quot; class=&quot;headerlink&quot; title=&quot;可变与不可变&quot;&gt;&lt;/a&gt;可变与不可变&lt;/h2&gt;&lt;p&gt;scala的集合包括Set、List和Map。三种集合的特征和Java中的一样。scala为每种集合都提供了
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="集合" scheme="http://scala.chobit.org/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="List" scheme="http://scala.chobit.org/tags/List/"/>
    
      <category term="Set" scheme="http://scala.chobit.org/tags/Set/"/>
    
      <category term="Map" scheme="http://scala.chobit.org/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>apply方法</title>
    <link href="http://scala.chobit.org/wiki/20180607/b014-applyMethod/"/>
    <id>http://scala.chobit.org/wiki/20180607/b014-applyMethod/</id>
    <published>2018-06-07T14:37:03.000Z</published>
    <updated>2018-06-08T13:46:25.488Z</updated>
    
    <content type="html"><![CDATA[<p>scala的apply方法有一个特性：就是在调用apply方法的时候可以省略方法名，即可以用 “<strong>类名或实例名 + ([参数列表])</strong>”这样的形式来使用。</p><p>scala中数组的定义和使用就是apply方法的一个典型实例，来看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val arr = Array(1,3,5,7,9)</span><br><span class="line">arr: Array[Int] = Array(1, 3, 5, 7, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; arr(3)</span><br><span class="line">res0: Int = 7</span><br></pre></td></tr></table></figure><p>构建数组实例的时候调用了object Array的一个apply方法，通过索引获取数组元素的时候调用的是class Array的一个apply方法。调用这两apply方法的时候，方法名被省略掉了，但是在使用上却更直观了。</p><p>通过刚才这个数组的例子，我们了解到在scala中apply方法有两种，一种是object中的apply方法，一种是class中的apply方法。接下来我们会尝试自己定义使用这两种apply方法。</p><p>先来看下class中apply方法的使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = print(<span class="string">s"<span class="subst">$name</span> is a coder."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(job: <span class="type">String</span>) = println(<span class="string">s"<span class="subst">$name</span>'s job is <span class="subst">$job</span>."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">Coder</span>(<span class="string">"robin"</span>)</span><br><span class="line"></span><br><span class="line">  c()</span><br><span class="line">  c(<span class="string">"coding"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到class的apply方法的作用就是可以通过实例并省略方法名来调用。</p><p>再来看下object的apply方法，其实也是一样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Coder</span> = <span class="keyword">new</span> <span class="type">Coder</span>(name)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> c = <span class="type">Coder</span>(<span class="string">"robin"</span>)</span><br><span class="line">  <span class="type">Coder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply方法的作用就是这样：可以让开发者更简单的调用apply方法。</p><p>上面的例子我做了一个不好的示范：因为这几个apply方法大多定义得没有意义——除了伴生对象中的创建实例的那个。apply方法是如此特殊，在使用的时候也应慎重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的apply方法有一个特性：就是在调用apply方法的时候可以省略方法名，即可以用 “&lt;strong&gt;类名或实例名 + ([参数列表])&lt;/strong&gt;”这样的形式来使用。&lt;/p&gt;
&lt;p&gt;scala中数组的定义和使用就是apply方法的一个典型实例，来看一下：&lt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="apply" scheme="http://scala.chobit.org/tags/apply/"/>
    
  </entry>
  
  <entry>
    <title>implicit-scala隐式处理</title>
    <link href="http://scala.chobit.org/wiki/20180531/a29-implicit/"/>
    <id>http://scala.chobit.org/wiki/20180531/a29-implicit/</id>
    <published>2018-05-30T22:07:47.000Z</published>
    <updated>2018-06-09T03:02:01.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先来看看下面的内容：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> days “ago”</span><br><span class="line"><span class="number">5</span> days “from_now”</span><br></pre></td></tr></table></figure></p><p>这段内容大家怎么看。首先这确定是一段代码（不是代码也没有必要提了），但是也可以确定的是scala的整型是没有days这样的方法的——在Int、RichInt还有Java的Integer中都没有days方法。  </p><p>那么是怎样为整型值添加days方法的，或者说是如何扩展整型的方法的。  </p><p>在scala中我们可以使用隐式类型转换来扩展类的能力。关于隐式类型转换，我手边的教材是这样说的：</p><blockquote><p>隐式类型转换可以帮助我们扩展语言，创建“专用于特定应用和领域”的词汇或语法，也可以帮助我们创建属于自己的领域专用语言。</p></blockquote><p>这句话说明了隐式类型转换的主要作用。</p><p>再来看看隐式类型转换具体是怎样发挥作用的。还以最初的那段代码为例，看一下是怎样为整型添加days方法的。</p><p>首先，我们需要创建一个DateHelper类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">number: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">Date</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> date = <span class="type">Calendar</span>.getInstance()</span><br><span class="line">    when <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, -number)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, number)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; date</span><br><span class="line">    &#125;</span><br><span class="line">    date.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在DateHelper方法中定义了days方法。可以明确地说这个days方法就是一开始的示例中的days方法。DateHelper类还有一个整型值的构造器。那么怎样使用隐式类型转换让整型值可以调用DateHelper的days方法？我们需要使用<strong>implicit</strong>关键字，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(number: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(number)</span><br></pre></td></tr></table></figure></p><p>这段代码将一个整型值转为了DateHelper实例。此时再让整型值调用days方法就可以了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(number: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(number)</span><br><span class="line"></span><br><span class="line">println(<span class="number">1</span> days <span class="string">"ago"</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tue Jun 05 07:09:29 CST 2018</span><br></pre></td></tr></table></figure></p><h2 id="隐式转换函数"><a href="#隐式转换函数" class="headerlink" title="隐式转换函数"></a>隐式转换函数</h2><p>刚才的例子就是一个隐式转换函数的实例。在这个例子中定义的隐式转换函数为convertInt2DateHelper。通过这个函数我们可以将DateHelper类的能力提供给一个整型值。另外，需要啰嗦一下：隐式转换函数的名称对其功能没有任何影响，只要能表达其含义，具备可读性即可。</p><p>接下来我们尝试优化一下前面的实例中的隐式转换。每次需要进行隐式转换时就定义一个隐式转换函数并不是一个很好的做法。我们可以把这个隐式转换函数定义在某个位置（比如某个包或某个类），在需要的时候import过来即可。对于我们这个实例来说，一个比较理想的位置就是DateHelper类的伴生对象了。来看下调整后的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Calendar</span>, <span class="type">Date</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">number: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">Date</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> date = <span class="type">Calendar</span>.getInstance()</span><br><span class="line">    when <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, -number)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, number)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; date</span><br><span class="line">    &#125;</span><br><span class="line">    date.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(number: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DateHelper</span>._</span><br><span class="line"></span><br><span class="line">  println(<span class="number">1</span> days <span class="string">"ago"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MyApp类中我们通过“ import DateHelper._”调用了DateHelper object中的convertInt2DateHelper函数完成了隐式转换。如果应用场景类没有和DateHelper类在同一个包下，那么就可以在顶部引用中引入convertInt2DateHelper函数并进行使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhyea.<span class="type">DateHelper</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="number">1</span> days <span class="string">"ago"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p>一般定义的函数中，通常需要明确传入参数，如下例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s"Hello <span class="subst">$name</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(<span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure><p>但是如果函数的参数是隐式参数的话，则可以不必传入：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> gender: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  gender <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"male"</span> =&gt; println(<span class="string">s"Hello Mr <span class="subst">$name</span>!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"female"</span> =&gt; println(<span class="string">s"Hello Ms <span class="subst">$name</span>!"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Hello <span class="subst">$name</span>!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> gender: <span class="type">String</span> = <span class="string">"male"</span></span><br><span class="line"></span><br><span class="line">hello(<span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><p>声明函数时，隐式参数用implicit关键字声明，并以curry化形式使用。</p><p>调用含有隐式参数的函数时，可以不传入隐式参数，但是在调用隐式参数的上下文中，必须能找到可用的隐式参数。也就是说，在如下的情况下，调用hello函数也是OK的（因为隐式变量是在调用函数后提供的，执行结果是不一样的）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello(<span class="string">"robin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> g: <span class="type">String</span> = <span class="string">"male"</span></span><br></pre></td></tr></table></figure></p><p>但是如果不提供任何可用的隐式变量，就不能通过编译了。</p><h2 id="隐式处理规则"><a href="#隐式处理规则" class="headerlink" title="隐式处理规则"></a>隐式处理规则</h2><p>在scala中，隐式处理是普遍存在的，比如我们可以执行“1 to 7”这样的语句，就是因为Scala隐式地将1从Int类型转换为其富封装器RichInt类型。  </p><p>Int到RichInt的转换是定义在Predef对象中的（确切说是在Predef的超类LowPriorityImplicits中）。Predef对象中封装了一系列隐式类型转换函数定义。在我们每次执行scala程序时都会默认引用Predef对象，因此也默认引用了这些隐式转换函数。可以看几个Predef中定义的隐式转换函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">byte2Byte</span></span>(x: <span class="type">Byte</span>)           = java.lang.<span class="type">Byte</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">short2Short</span></span>(x: <span class="type">Short</span>)        = java.lang.<span class="type">Short</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">char2Character</span></span>(x: <span class="type">Char</span>)      = java.lang.<span class="type">Character</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Integer</span></span>(x: <span class="type">Int</span>)          = java.lang.<span class="type">Integer</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">long2Long</span></span>(x: <span class="type">Long</span>)           = java.lang.<span class="type">Long</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">float2Float</span></span>(x: <span class="type">Float</span>)        = java.lang.<span class="type">Float</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">double2Double</span></span>(x: <span class="type">Double</span>)     = java.lang.<span class="type">Double</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">boolean2Boolean</span></span>(x: <span class="type">Boolean</span>)  = java.lang.<span class="type">Boolean</span>.valueOf(x)</span><br></pre></td></tr></table></figure></p><p>上面是scala使用隐式转换处理Java基本类型自动装箱和自动拆箱的代码。</p><p>那么什么时候会进行隐式处理呢？根据我们前面的实例可以推测出大致有这几种情况：</p><ol><li>调用方法时使用的参数列表和定义的参数列表不一致时；</li><li>值的类型与预期类型不一致时；</li><li>调用类中不存在的方法或成员时。</li></ol><p>第二种情况前面没有提到过，用scala解释器演示下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def double2Int(i:Double)=i.toInt</span><br><span class="line">warning: there was one feature warning; re-run with -feature <span class="keyword">for</span> details</span><br><span class="line">double2Int: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; def foo(x:Int)=<span class="built_in">print</span>(x)</span><br><span class="line">foo: (x: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(3.14)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>这里演示的是调用方法时产生了隐式转换。也许像下面这样更直观一些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val i:Int = 3.14</span><br><span class="line">i: Int = 3</span><br></pre></td></tr></table></figure></p><p>需要Int值，却提供了一个浮点值。scala检查到当前上下文中存在整型值到浮点值的隐式转换函数，就调用隐式转换函数将浮点值转为了整型值。</p><p>简而言之：在当前范围内，如果发现通过类型转换有助于操作、方法调用或类型转换的成功完成，就会进行转换。</p><p>再看下不进行隐式处理的情况，大概有这么几种：</p><ol><li>如果没有隐式转换函数或隐式变量，编译也可以通过，说明不需要进行隐式处理；</li><li>如果存在二义性，则无法进行隐式处理；</li><li>隐式处理无法嵌套执行，一次至多只能应用一次隐式转换。</li></ol><p>解释下后两种情况。关于二义性，看下这个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def double2Int(i:Double)=i.toInt</span><br><span class="line">double2Int: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def doubleToInt(i:Double)=i.toInt</span><br><span class="line">doubleToInt: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; val i:Int = 3.14</span><br><span class="line">&lt;console&gt;:16: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Double(3.14)</span><br><span class="line"> required: Int</span><br><span class="line">Note that implicit conversions are not applicable because they are ambiguous:</span><br><span class="line"> both method double2Int of <span class="built_in">type</span> (i: Double)Int</span><br><span class="line"> and method doubleToInt of <span class="built_in">type</span> (i: Double)Int</span><br><span class="line"> are possible conversion <span class="built_in">functions</span> from Double(3.14) to Int</span><br><span class="line">       val i:Int = 3.14</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure></p><p>在解释器中定义了两个将整型转为浮点型的函数，两个函数的处理方式是一样的，只是名称略有不同，然而在编译时报错了，提示ambiguous，即存在二义性。</p><p>为了避免二义性，在同一个作用范围内，尽量不要出现相同类型的隐式变量和隐式函数。</p><p>至于第三点，可以看一下下面的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def double2Int(i:Double)=i.toInt</span><br><span class="line">double2Int: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def int2Boolean(i:Int)=i &gt; 2</span><br><span class="line">int2Boolean: (i: Int)Boolean</span><br><span class="line"></span><br><span class="line">scala&gt; val b:Boolean = 3.14</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Double(3.14)</span><br><span class="line"> required: Boolean</span><br><span class="line">       val b:Boolean = 3.14</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure></p><p>在解释器中尝试将一个浮点值赋值给一个boolean型的变量。这里期望先为这个浮点值调用double2Int函数隐式转换为整型值，然后在调用int2Boolean函数隐式转换为boolean类型。不过程序并没有按照预期的路线一个接一个的嵌套执行隐式转换，而是直接报错了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;先来看看下面的内容：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="implicit" scheme="http://scala.chobit.org/tags/implicit/"/>
    
  </entry>
  
  <entry>
    <title>trait和抽象类</title>
    <link href="http://scala.chobit.org/wiki/20180530/a28-traitAndAbstractClass/"/>
    <id>http://scala.chobit.org/wiki/20180530/a28-traitAndAbstractClass/</id>
    <published>2018-05-30T13:59:06.000Z</published>
    <updated>2018-06-06T13:49:00.766Z</updated>
    
    <content type="html"><![CDATA[<p>发现前面多次提到了抽象类，可是却从没有正式的介绍过抽象类这个概念。在这里一起说下。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>scala的抽象类的定义和Java的差不多。使用了关键词abstract声明的类叫作抽象类。如果一个类里包含了一个或多个抽象方法，该类就必须被定义为抽象类。抽象方法属于一种不完整的方法，抽象方法只有方法声明，没有方法体。</p><p>下面的代码演示了抽象类的定义和实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathTeacher</span>(<span class="params">override val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Teacher</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> age = <span class="number">29</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(): <span class="type">Unit</span> = println(<span class="string">"teaching Math"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">MathTeacher</span>(<span class="string">"tom"</span>)</span><br><span class="line"></span><br><span class="line">  teacher.teach</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中定义了抽象类Teacher，抽象类中有抽象字段（name和age）和抽象方法（teach()方法）。</p><p>抽象类有如下几个特征：</p><ol><li>在普通类中 字段必须赋值(包括赋具体的值和使用下划线为var变量赋默认值) </li><li>抽象类不需要初始化</li><li>抽象类中可以有抽象方法 </li><li>只定义不赋值的字段为抽象字段 </li><li>只声明而不实现的方法为抽象方法；和java不同，scala的抽象方法不强制使用abstract关键字声明，只需不写方法体即可</li></ol><h2 id="trait和抽象类"><a href="#trait和抽象类" class="headerlink" title="trait和抽象类"></a>trait和抽象类</h2><p>介绍下trait和抽象方法的异同。</p><p>二者的相似之处：</p><ol><li>都可以有普通方法和抽象方法；</li><li>都可以有普通成员变量和抽象变量；</li><li>抽象类能做的事情trait都能做。</li></ol><p>二者的不同之处：</p><ol><li>trait可以多重混入，抽象类只能单继承；</li><li>抽象类可以定义构造函数；</li><li>trait可以混入object，抽象类不可以。</li></ol><p>那什么时候用trait，什么时候用抽象类呢：</p><ol><li>优先使用trait。一个类扩展多个trait是很方便的，但却只能扩展一个抽象类。</li><li>如果你需要构造函数参数，使用抽象类。因为抽象类可以定义带参数的构造函数，而trait不行。例如，不能定义trait T(i: Int) {}，参数i是非法的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;发现前面多次提到了抽象类，可是却从没有正式的介绍过抽象类这个概念。在这里一起说下。&lt;/p&gt;
&lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;scala的抽象类的定义和Java
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
      <category term="抽象类" scheme="http://scala.chobit.org/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>trait方法延迟绑定</title>
    <link href="http://scala.chobit.org/wiki/20180530/a27-traitDelayBinding/"/>
    <id>http://scala.chobit.org/wiki/20180530/a27-traitDelayBinding/</id>
    <published>2018-05-29T23:14:00.000Z</published>
    <updated>2018-05-30T13:54:17.402Z</updated>
    
    <content type="html"><![CDATA[<p>关于延迟绑定上一节已经提到过了。这次再专门说一下。  </p><p>延迟绑定简单来说就是先混入的trait的方法会后调用。</p><p>再来看一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UpperWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span> = <span class="keyword">super</span>.write(message.toUpperCase)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">FilterWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span> = <span class="keyword">super</span>.write(message.replace('o', '-'))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">StringWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span> = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> myWriter1 = <span class="keyword">new</span> <span class="type">StringWriter</span> <span class="keyword">with</span> <span class="type">UpperWriter</span> <span class="keyword">with</span> <span class="type">FilterWriter</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> myWriter2 = <span class="keyword">new</span> <span class="type">StringWriter</span> <span class="keyword">with</span> <span class="type">FilterWriter</span> <span class="keyword">with</span> <span class="type">UpperWriter</span></span><br><span class="line"></span><br><span class="line">  println(myWriter1.write(<span class="string">"Hello World!"</span>))</span><br><span class="line"></span><br><span class="line">  println(myWriter2.write(<span class="string">"Hello World!"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中定义了一个抽象类和三个trait。</p><p>其中抽象类Writer仅定义了一个抽象方法，并没有提供具体的实现。继承抽象类Writer的trait需要实现write方法。</p><p>UpperWriter的write方法实现了将传入的英文字符转为大写；</p><p>FilterWriter的write方法实现了将小写的“o”替换为“-”；</p><p>StringWriter则只是将传入的字符串原样返回。</p><p>看下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELL- W-RLD!</span><br><span class="line">HELLO WORLD!</span><br></pre></td></tr></table></figure><p>验证了我们的说法：延迟绑定就是先混入的trait会后执行。</p><p>myWriter1的执行顺序：FilterWriter –&gt; UpperWriter –&gt; StringWriter；</p><p>myWriter2的执行顺序：UpperWriter –&gt; FilterWriter –&gt; StringWriter。</p><p>从trait的延迟绑定很容易会想到java的父类与子类的初始化顺序。又或者是java中的责任链模式。因此想想用java来实现这一点并不难：可以采用不同顺序的责任链，也可以是使用不同的继承顺序来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于延迟绑定上一节已经提到过了。这次再专门说一下。  &lt;/p&gt;
&lt;p&gt;延迟绑定简单来说就是先混入的trait的方法会后调用。&lt;/p&gt;
&lt;p&gt;再来看一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>trait选择性混入</title>
    <link href="http://scala.chobit.org/wiki/20180529/a26-traitSelectiveMixedIn/"/>
    <id>http://scala.chobit.org/wiki/20180529/a26-traitSelectiveMixedIn/</id>
    <published>2018-05-29T13:54:15.000Z</published>
    <updated>2018-05-31T13:40:25.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>上一节有说过如何在类级别混入trait，还举了一个人类的朋友Dog的例子。代码是这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span></span></span><br></pre></td></tr></table></figure><p>继续从这个例子展开来。并不是所有的狗都是人类的朋友，比如藏獒，这玩意儿又蠢又笨又凶狠，肯定不能算是很多人的好朋友了。我们更希望在创建一个Dog的实例后，再选择性地为其混入HumanFriend这个特质。也就是在对象级别混入trait。来看下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> tom = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>) <span class="keyword">with</span> <span class="type">HumanFriend</span></span><br><span class="line"></span><br><span class="line">  tom.accompany()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次没有为Dog类混入HumanFriend trait，而是在创建Dog的实例tom的时候混入了HumanFriend trait。虽然是在对象级别混入的，Dog实例tom也可以调用HumanFriend的accompany方法。如果此时Dog的实例没有混入HumanFriend，却还是调用了accompany方法，就会无法完成编译。</p><p>另外，关于HumanFriend的抽象成员变量name还得提一句。在这个例子里，我们为Dog类也提供了一个成员变量name，所以在为其实例混入HumanFriend trait的时候就没有报错。但是如果一个没有名为name的成员变量的类混入HumanFriend时，就得提供相应的实现了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> simba = <span class="keyword">new</span> <span class="type">Lion</span> <span class="keyword">with</span> <span class="type">HumanFriend</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">"Simba"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  simba.accompany()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lion类没有任何成员变量，在为其实例混入HumanFriend trait的时候就得提供抽象成员变量name的具体实现了。</p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My Friend Simba accompanies with me.</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>依赖trait的选择性混入的能力，我们可以很容易地实现功能的增强，或者说是装饰器模式。来看个案例。</p><p>假设我们要对一个人进行审查，包括信用记录、收支记录、犯罪记录和工作记录等。但是我们并不会总是都要审查所有的内容，比如要买房时会审查信用记录和收支记录，申请出境时会审查犯罪记录和工作记录。</p><p>想想该怎么做：最简单的思路是为每种审查创建一个方法，然后在需要的时候将这些方法组合起来。更常用的方案是创建一个审查接口，为每种审查内容创建一个类，并实现审查方法。为最基础的审查，比如信用记录、收支记录等创建一个基础类还是可行的，但是如果要为每一种复合审查（如买房或申请出境等）都创建一个类就会面临一个问题：类膨胀。scala可以让我们避免这种问题，使用trait混入实例可以实现面对不同的审查提供不同的处理方案这样的灵活性。</p><p>首先我们需要定义一个抽象类Checker，实现一些在审查中的通用的行为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Check</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Application Details..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为每一类基础性的审查创建一个trait</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CreditCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123; <span class="comment">//信用审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Credit..."</span> + <span class="keyword">super</span>.check()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BalanceCheck</span> <span class="keyword">extends</span> <span class="title">Check</span></span>&#123;<span class="comment">//收支记录审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Balance..."</span> + <span class="keyword">super</span>.check() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">EmploymentCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;<span class="comment">//工作记录审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Employment..."</span> + <span class="keyword">super</span>.check()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CriminalRecordCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;<span class="comment">//犯罪记录审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Check Criminal Records..."</span> + <span class="keyword">super</span>.check()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里有一个有趣的地方：就是这里的几个trait都继承自一个抽象类。让trait继承抽象类有两个用处：</p><ol><li>这些trait可以使用Check的方法；</li><li>这些trait只能混入继承自Check的类。</li></ol><p>在每个trait里，都重写了check方法，在重写的同时也引用了Check类的方法，这也可以说是对Check类的修饰或增强。</p><p>trait里，通过super调用的方法会经历一个延迟绑定的过程。这个调用并不是对父类的调用，而是对其左边混入的trait的调用——如果这个trait已经是混入的最左trait，那么这个调用就会解析成混入这个trait的类的方法。具体如何可以看一下下面的例子是如何实现的。</p><p>来看一个买房申请：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> apartmentApplication = <span class="keyword">new</span> <span class="type">Check</span> <span class="keyword">with</span> <span class="type">CreditCheck</span> <span class="keyword">with</span> <span class="type">BalanceCheck</span></span><br><span class="line"></span><br><span class="line">println(apartmentApplication.check())</span><br></pre></td></tr></table></figure></p><p>在创建Check实例的同时混入了两个trait：CreditCheck和BalanceCheck。同样的也可以这样实现出境申请：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exitApplication = <span class="keyword">new</span> <span class="type">Check</span> <span class="keyword">with</span> <span class="type">CriminalRecordCheck</span> <span class="keyword">with</span> <span class="type">EmploymentCheck</span></span><br><span class="line"></span><br><span class="line">println(exitApplication.check())</span><br></pre></td></tr></table></figure><p>可以看出，如果想要按照不同的组合进行检查的话，只需要按照希望的组合将trait混入即可。</p><p>看一下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Checked Balance...Checked Credit...Checked Application Details...</span><br><span class="line">Checked Employment...Check Criminal Records...Checked Application Details...</span><br></pre></td></tr></table></figure><p>可以看到，是从最右的trait开始调用check()方法。然后，顺着super.check()，将调用传递到其左边的trait。最左的trait调用的是实例的check()方法。</p><p>在Scala里，trait是一个强有力的工具，可以用它混入横切关注点。使用它们可以以较低的成本创建出高度可扩展的代码。无需创建一个拥有大量类和接口的层次结构，就可以快速地把必要的代码投入使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;上一节有说过如何在类级别混入trait，还举了一个人类的朋友Dog的例子。代码是这样的：&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>Trait</title>
    <link href="http://scala.chobit.org/wiki/20180528/a25-traitSummary/"/>
    <id>http://scala.chobit.org/wiki/20180528/a25-traitSummary/</id>
    <published>2018-05-28T14:26:54.000Z</published>
    <updated>2018-05-29T13:51:17.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不知道大家对java的接口是如何理解的。在我刚接触到接口这个概念的时候，我将接口理解为一系列规则的集合，认为接口是对类的行为的规范。现在想来，将接口理解为是对类的规范多少有些偏颇，更恰当些的观点应该是：相对于类来说，接口是更深层次的抽象，虽然同时接口也起到了规定类的行为的作用。  </p><p>和java的接口比起来，scala的trait可能更具体一些。正如trait这个单词的本意一样，它指的是一种特质：如果认为类有某种特质就混入对应的trait好了。在scala中，类是对现实某一类事务的建模，而Trait则是对已有模型的补充。  </p><p>我自己以为，trait这个概念理解起来要比接口更容易一些。</p><p>看个例子吧：狗是人类的好朋友，它在我们孤单的时候默默地陪伴。用scala可以这样定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span></span></span><br></pre></td></tr></table></figure><p>我们先定义了一个名为人类的朋友（HumanFriend）的trait，朋友的主要特征就是陪伴，所以在这个trait里面定义了一个方法accompany并做了实现。Dog（狗）具有人类的好朋友这个特质，所以可以混入trait HumanFriend。在scala中继承某个trait，通常也称为混入某个trait。</p><p>在trait HumanFriend中定义了一个val变量name。这个name没有默认值，我们可以认为它是抽象的，可以等到其他类混入这个trait时再为其赋值。</p><p>混入trait的类可以直接调用trait的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>).accompany()</span><br></pre></td></tr></table></figure></p><p>一个类混入trait后，我们可以认为其实例就是trait的引用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tom: <span class="type">HumanFriend</span>= <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>)</span><br></pre></td></tr></table></figure></p><p>一个trait会被编译为一个接口和一个抽象类。trait中定义的未赋值的val变量会被表示为一个抽象方法。</p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>混入trait的类可以重写trait的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span> accompany with me."</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写时需要使用override关键字。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>一个类混入trait的数量是任意的。用关键字<strong>with</strong>就可以混入更多的trait。比如，狗除了是人类的好朋友，还是忠诚的卫士，会保护我们：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Guard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">guard</span></span>() = println(<span class="string">s" <span class="subst">$name</span> guards me!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> <span class="keyword">with</span> <span class="title">Guard</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> tom = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>)</span><br><span class="line"></span><br><span class="line">  tom.accompany()</span><br><span class="line"></span><br><span class="line">  tom.guard()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog类同时混入了HumanFriend和Guard两个trait，所以它可以调用这两个trait的方法。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>前面提过，scala中的trait可以理解为是java中接口和抽象类的组合。那么在接口中定义抽象类也是可以的了。现在我们将HumanFriend中的accompany方法改为抽象方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span> accompanies with me."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象方法需要在子类中提供实现。子类实现抽象方法时override关键字是可选的，但是建议最好加上。</p><h2 id="构造顺序"><a href="#构造顺序" class="headerlink" title="构造顺序"></a>构造顺序</h2><p>在网上看到了这段关于trait的构造顺序的描述，觉得有点儿意思就顺路转了过来。</p><p>trait也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该trait的对象在构造时都会被执行。</p><p>构造器的执行顺序：</p><ol><li>调用超类的构造器；</li><li>trait构造器在超类构造器之后、类构造器之前执行；</li><li>trait由左到右被构造；</li><li>每个trait当中，父trait先被构造；</li><li>如果多个trait共有一个父trait，父trait不会被重复构造</li><li>所有trait被构造完毕，子类被构造。</li></ol><p>构造器的顺序是类的线性化的反向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;不知道大家对java的接口是如何理解的。在我刚接触到接口这个概念的时候，我将接口理解为一系列规则的集合，认为接口是对类的行为的规范。现在想来
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://scala.chobit.org/wiki/20180527/a24-array/"/>
    <id>http://scala.chobit.org/wiki/20180527/a24-array/</id>
    <published>2018-05-27T14:04:05.000Z</published>
    <updated>2018-05-28T14:20:31.915Z</updated>
    
    <content type="html"><![CDATA[<p>简单说下scala中的数组。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>声明数组的语法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>]\(<span class="number">3</span>\)</span><br></pre></td></tr></table></figure></p><p>声明数组时必须指定数组的长度。数组的类型可以不指定，但是不指定的话，数组就是无用的，因为此时数组元素的类型是Nothing。</p><p>这样声明的数组其元素初始为字符串的默认值，即null。可以这样调整数组元素的值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr(<span class="number">0</span>) = <span class="string">"com"</span></span><br><span class="line">arr(<span class="number">1</span>) = <span class="string">"zhyea"</span></span><br><span class="line">arr(<span class="number">2</span>) = <span class="string">"robin"</span></span><br></pre></td></tr></table></figure></p><p>可以看到scala中获取数组元素的方法是：数组名 + 小括号 + 索引值。这里究其根本还是调用了Array类的apply(i:Int)方法，因此索引值也可以是一个表达式，比如arr(4/2)。</p><p>也可以在创建数组时完成初始化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>[<span class="type">String</span>](<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>调用object Array的ofDim方法可以创建一维到五维的数组。如下是一个创建二维数组的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matrix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>值的一提的是，在scala中本质上也是没有多维数组的。同java一样，所谓的多维数组其实质也是一维数组的嵌套（或者说是数组的数组）。这在object Array的二维数组的实现中可以很明显地看出来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ofDim</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]] = (<span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]](n1): <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]])</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n1) arr(i) = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](n2)</span><br><span class="line">  arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>这里说的变长数组就是ArrayBuffer。ArrayBuffer更应该被归类到集合里面，但是既然看到了就一起写出来好了。在使用方式上ArrayBuffer有些类似于java里的ArrayList，但是要更灵活一些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">  arr += <span class="number">1</span> <span class="comment">//尾端添加一个元素</span></span><br><span class="line"></span><br><span class="line">  arr ++= <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//尾端添加一个数组</span></span><br><span class="line"></span><br><span class="line">  arr += (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">// 尾端添加多个元素</span></span><br><span class="line"></span><br><span class="line">  println(arr.mkString(<span class="string">", "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5, 6, 7</span><br></pre></td></tr></table></figure></p><p>ArrayBuffer和Array可以互相转换，只需分别调用toArray()和toBuffer()方法即可。</p><h2 id="数组应用"><a href="#数组应用" class="headerlink" title="数组应用"></a>数组应用</h2><p>关于数组觉得比较有趣的一个应用是在和变量一起的使用的时候，比如下面：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(a, b, c) = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">println(a)</span><br><span class="line">println(b)</span><br><span class="line">println(c)</span><br></pre></td></tr></table></figure></p><p>代码中通过一个数组完成了a、b、c三个变量的赋值。</p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>至于数组其他的应用，如循环、拼接、copy等操作，在使用的时候可以翻看一下API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单说下scala中的数组。&lt;/p&gt;
&lt;h2 id=&quot;声明数组&quot;&gt;&lt;a href=&quot;#声明数组&quot; class=&quot;headerlink&quot; title=&quot;声明数组&quot;&gt;&lt;/a&gt;声明数组&lt;/h2&gt;&lt;p&gt;声明数组的语法：&lt;br&gt;&lt;figure class=&quot;highlight sca
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数组" scheme="http://scala.chobit.org/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://scala.chobit.org/wiki/20180521/a23-closure/"/>
    <id>http://scala.chobit.org/wiki/20180521/a23-closure/</id>
    <published>2018-05-21T14:36:43.000Z</published>
    <updated>2018-05-26T02:48:25.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于闭包的概念，我手边scala的书如是说：</p><blockquote><p>闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。  </p></blockquote><p>在维基百科中的说法是：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p></blockquote><p>前者说闭包是一个函数，后者说闭包是函数和自由变量一同构成的实体。我个人是比较倾向于后者的。不过细细思考下来，二者也没什么差别，都描述了闭包的几个特征：</p><ol><li>闭包中有一个特殊的<strong>函数</strong>；</li><li>存在一个<strong>封闭</strong>的作用域，函数就在这个封闭的作用域中；</li><li>在封闭作用域中存在一个函数作用域之外的变量（即<strong>自由变量</strong>）；</li><li>闭包函数<strong>绑定</strong>了这个自由变量。</li></ol><p>来看个关于闭包的程序：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line">println(func(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个方法foo()，方法foo中有一个局部变量i。正常情况下只有在执行foo方法的时候，局部变量i才会存在；foo方法执行完成后，局部变量i就会消失，不再有意义。不过现在在foo方法中定义了一个内部方法bar()，在bar方法中引用了foo方法的局部变量i，最后是将bar转为函数值作为foo方法的返回值。</p><p>这段代码中的bar函数绑定了它的作用域之外的变量i。按照前文的说明：bar函数和变量i共同构成了一个闭包。</p><p>现在想一下：<strong>调用foo方法返回的bar函数时，foo的局部变量i是否有效？</strong> 显然的，根据维基百科的解释，虽然foo方法已经执行结束，但是局部变量i仍然和函数bar一同存在，调用bar函数，i仍然有效。</p><p>执行这段代码看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(): Int =&gt; Int = &#123;</span><br><span class="line">     |     val i = 1</span><br><span class="line">     |</span><br><span class="line">     |     def bar(num: Int) = &#123;</span><br><span class="line">     |       i + num</span><br><span class="line">     |     &#125;</span><br><span class="line">     |</span><br><span class="line">     |     bar</span><br><span class="line">     |   &#125;</span><br><span class="line">foo: ()Int =&gt; Int</span><br><span class="line"></span><br><span class="line">scala&gt;  val func = foo()</span><br><span class="line">func: Int =&gt; Int = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; println(func(2))</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>代码的执行结果和前面的推论是一致的。</p><p>根据这段代码我们可以看到闭包的“闭”封闭的是函数的外部作用域。在这个例子中，封闭的就是bar函数外的foo方法的作用域。整个闭包只有一个对外的通道，即bar函数，我们可以通过bar函数来访问封闭的作用域的内容。  </p><p>再来说明下闭包定义中的<strong>绑定</strong>两个字。闭包中的绑定并不是获得闭包绑定自由变量的一份副本，而是直接绑定到变量本身。在闭包中对自由变量的调整会影响到闭包外部的自由变量；同样的，外部自由变量的变化，闭包也会受到影响。下面这个例子应该可以说明这一点：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): () =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line"></span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br></pre></td></tr></table></figure><p>在代码中定义了一个闭包。闭包中的自由变量是i，在函数bar中对自由变量i做了调整。在闭包外，三次调用了闭包函数。这段代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">对比输出结果我们可以看到：每次调用闭包函数bar都会对自由变量i产生影响；而自由变量i的变化，又会在下一次执行bar函数的时候发挥作用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 思考 - 对象和闭包</span><br><span class="line"></span><br><span class="line">看完了闭包的示例代码后，回过头来再思考一下闭包的概念：  </span><br><span class="line"></span><br><span class="line">&gt; 闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那根据这个概念，下面这段代码是不是闭包：</span><br><span class="line">```scala</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">  private val i = 1</span><br><span class="line"></span><br><span class="line">  def bar(num: Int): Int = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了，还是直接看这段代码吧：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">A</span>().bar(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里定义了一个类A，类A有一个私有变量i，这个变量i只能通过bar方法访问，换言之bar方法也是引用了一个它的作用域之外的变量i。那么class A这个结构应该也算是闭包喽！？</p><p>但是这里的bar方法需要通过类A的对象来调用，它本质上是类A的一个实例成员，而非是一个独立的函数；另外这里的bar方法引用的变量i是绑定在类A的对象上，而非绑定在bar方法上，所以从根本上这种形式就不满足闭包的定义，所以不是闭包！？</p><p>对于这样定义的类是否是闭包，以上是两种观点，也是我纠结之处。也查了些资料，然而各种说法莫衷一是。思考了一段时间后决定停止这种纠结，仅从一点出发：<strong>只在函数作为头等公民的语境中来讨论闭包</strong>。</p><p>对象和函数各有自己不同的使用场景。在scala这种既支持函数又面向对象的语言中，使用对象可以减少一些复杂度，使用函数可以提升一些灵活性。但是把函数的概念放到面向对象的语境中，或者反过来都是没有意义的事情。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前想到的关于的闭包的用法主要有两种：一种是将闭包作为返回值，就如前面的例子；另一种是将闭包作为参数，如下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(f: (<span class="type">Int</span>) =&gt; <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>)</span><br><span class="line">  arr.filter(f).foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bar = (num: <span class="type">Int</span>) =&gt; num &gt; max</span><br><span class="line"></span><br><span class="line">foo(bar)</span><br></pre></td></tr></table></figure></p><p>又想到了一个应用场景，比如在一些对于面向对象支持不是很好的语言，可以用闭包来构建对象（用scala来举这个例子，有些费力，懒得写了）。严格来说，这种用法也是将函数用作闭包的返回值。</p><p>另外scala的curry化也是闭包的一种应用。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在知乎上有各路大神对闭包进行了讨论，有兴趣可以看一下：<a href="https://www.zhihu.com/question/34210214" rel="external nofollow noopener noreferrer" target="_blank">什么是闭包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;关于闭包的概念，我手边scala的书如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://scala.chobit.org/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Executor Aroud模式</title>
    <link href="http://scala.chobit.org/wiki/20180520/a22-executorAroundMode/"/>
    <id>http://scala.chobit.org/wiki/20180520/a22-executorAroundMode/</id>
    <published>2018-05-19T23:15:02.000Z</published>
    <updated>2018-05-19T23:35:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。</p><p>在scala里可以用函数值实现这种模式。下面是一个示例，使用Resource类演示了事务的开启和释放：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"Starting transaction..."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">cleanUp</span></span>() &#123;</span><br><span class="line">    println(<span class="string">"Ending transaction..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op1</span> </span>= println(<span class="string">"Operation 1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op2</span> </span>= println(<span class="string">"Operation 2"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op3</span> </span>= println(<span class="string">"Operation 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(codeBlock: <span class="type">Resource</span> =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = <span class="keyword">new</span> <span class="type">Resource</span> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codeBlock(resource)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resource.cleanUp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里将Resource类的构造器标记为private，这样就只能在Resource类内部和它的伴生类中创建实例。因为只能在这两个地方创建实例，就可以保证按照确定的方式使用这个类的对象，即可以保证其行为是按照确定的方式执行。cleanUp()方法也被标记为private，确保不会被意外调用。Resource类第一行的print语句是具体事务操作的占位符。调用构造函数时，事务启动；调用cleanUp()函数时，事务终结。此外Resource类中还准备了一些实例方法，如op1()、op2()等。</p><p>在伴生对象里有一个默认public的方法use，它接收一个函数值作为参数。use()方法创建了一个Resource的实例，在try和finally块的保护之下，把这个实例传给了给定的函数值。在finally块里，调用了Resource私有实例方法cleanUp()。</p><p>看一下是如何使用Resource类的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span>.use &#123; resource =&gt;</span><br><span class="line">  resource.op1</span><br><span class="line">  resource.op2</span><br><span class="line">  resource.op3</span><br><span class="line">  resource.op1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting transaction...</span><br><span class="line">Operation 1</span><br><span class="line">Operation 2</span><br><span class="line">Operation 3</span><br><span class="line">Operation 1</span><br><span class="line">Ending transaction...</span><br></pre></td></tr></table></figure><p>调用Resource的伴生对象的use方法时，会自动创建一个Resource实例，等到传递的函数值执行结束后，会自动调用cleanUp方法释放占用的资源。</p><p>上面模式的一个变体是Loan（借贷）模式。如果想确保非内存资源得到确定性释放，就可以使用这个模式。可以这样认为：这种资源密集型的对象是借给你的，用过之后应该立即归还。</p><p>下面是一个Loan模式的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeToFile</span></span>(fileName: <span class="type">String</span>)(codeBlock: <span class="type">PrintWriter</span> =&gt; <span class="type">Unit</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(fileName))</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    codeBlock(writer)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调用writeToFile()将一些内容写入文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeToFile(<span class="string">"output.txt"</span>) &#123; writer =&gt; writer write <span class="string">"hello from Scala"</span> &#125;</span><br></pre></td></tr></table></figure><p>这行这段代码会创建一个名为output.txt的文件，并在文件中写入一行文字“hello from Scala”。</p><p>作为writeToFile()方法的使用者，我们不必操心文件的关闭。在代码块里，这个文件是借给我们用的。我们可以用得到的PrintWriter实例进行写操作，一旦从这个块返回，方法就会自动关闭文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。&lt;/p&gt;
&lt;p&gt;在scala里可
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线和参数</title>
    <link href="http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/"/>
    <id>http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/</id>
    <published>2018-05-19T14:01:50.000Z</published>
    <updated>2018-05-19T14:11:57.033Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123; (sum, elem) =&gt; sum + elem &#125;)</span><br></pre></td></tr></table></figure><p>上面的代码里使用了“/:”方法。这个方法的意思大致上是从数组的左侧开始迭代运算。这里是用来计算数组中所有元素的和。因为在函数值中sum和elem只用了一次，所以这个函数也可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123;_+_&#125; )</span><br></pre></td></tr></table></figure><p>其中第一个“<em>”就是sum，即用来迭代运算的值；第二个“</em>”表示的是数组中的元素。这里是一处让人比较纠结的地方，这样做会让代码过于简洁，有时甚至让人费解。如果能在不失可读性又足够简洁的地方使用就最好了，来看一下下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> negativeNumberExists = arr.exists &#123; _ &lt; <span class="number">0</span> &#125;</span><br><span class="line">println(<span class="string">"Array has negative number? "</span> + negativeNumberExists)</span><br></pre></td></tr></table></figure></p><p>这里的代码用来查找数组中是否有小于0的元素。</p><p>在某些有意义的地方，这种简洁还可以更进一步。比如说我们想从一个数组中找出最大值。从这个需求出发，我们会一步步地简化实现的函数。最开始是这个样子的，我们使用了“/:”方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    a</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; (large, ele) =&gt; max(large, ele) &#125;)</span><br></pre></td></tr></table></figure><p>用下划线表示函数值参数来做一次简化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max(_, _) &#125;)</span><br></pre></td></tr></table></figure><p>“_”不仅可以表示一个参数，还可以表示整个参数列表。所以可以继续简化成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max _ &#125;)</span><br></pre></td></tr></table></figure><p>在上面的代码里，“_”表示整个参数列表。如果只是把参数传递给下层的方法，甚至可以省下使用“_”。上面的代码可以最终简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max &#125;)</span><br></pre></td></tr></table></figure><p>可以看到，依赖类型推断，scala的简洁到了丧心病狂（无贬义）的程度。这也给开发者留下了一个难题：需要适当克制自己简化代码的欲望，留下适当的可读性，不让代码变成天书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="下划线" scheme="http://scala.chobit.org/tags/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Curry化</title>
    <link href="http://scala.chobit.org/wiki/20180518/a21-currying/"/>
    <id>http://scala.chobit.org/wiki/20180518/a21-currying/</id>
    <published>2018-05-17T23:11:16.000Z</published>
    <updated>2018-05-28T22:27:42.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。</p><p>scala里的curry化可以把函数从接收多个参数转换成接收多个参数列表。也就是说我们写的多参数函数不再只是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>) &#123;???&#125;</span><br></pre></td></tr></table></figure></p><p>而是可以这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>或者这样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>甚至是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>来看个实例好了，下面的代码中定义了一个inject方法。inject方法有三个参数，两个Int型的参数，一个函数值参数。方法体中通过传入的函数对前两个Int型参数进行运算：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>, (a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure></p><p>在代码的最后一行还写了调用inject方法的一个示例。</p><p>有的时候可能会觉得把普通参数和函数值参数放在一起有点儿怪怪的。现在用curry化的方法将函数值参数独立开来：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>)(op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>) &#123; (a, b) =&gt; a + b &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到不管是在定义方式还是在使用方式上，代码都清爽了许多。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从方法的角度来看，Curry化只是一个语法糖，对方法的功能没有任何影响。    </p><p>将方法转为函数使用时，Curry化的影响就出现了。在scala解释器里看一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def inject(a: Int, b: Int, op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int, op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br></pre></td></tr></table></figure></p><p>我们在解释器里def了没有做Curry化的inject方法，并用“_”将inject方法转为函数。此时inject方法转成的函数是一个有三个参数的普通函数。  </p><p>再来看看Curry化后的inject方法转成的函数是怎样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;   def inject(a: Int, b: Int)(op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int)(op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>将两次生成的函数值对象res0和res1放在一起比较一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curry化之前： res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br><span class="line">Curry化之后： res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>inject方法Curry化之前转成的函数res0是一个三参数函数，继承自trait Function3；Curry化之后转成的函数res1是一个双参数函数，继承自trait Function2。  </p><p>用ABC来表示下inject方法的参数也许更直观些。inject方法最初为：inject(A, B, C)； curry化以后的结构是为：inject(A, B)(C)。inject方法curry化以后对应的函数res1为：</p><blockquote><p>(A, B)=&gt; (C)=&gt; Int</p></blockquote><p>可以看到res1实质上是被分解多个函数，inject方法的每个参数列表都对应一个函数，几个函数按参数列表顺序从右到左逐层嵌套，最左侧的参数列表即为最外侧的函数的参数。  </p><p>以上的内容说的是对方法进行Curry化。Scala也支持对函数进行Curry化。scala的多参数函数trait，包括Function2 ~ FuntionN都有一个curried方法，用来将函数的每个参数进行curry化。下面的代码是Function3的curried方法的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curried</span></span>: <span class="type">T1</span> =&gt; <span class="type">T2</span> =&gt; <span class="type">T3</span> =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">  (x1: <span class="type">T1</span>) =&gt; (x2: <span class="type">T2</span>) =&gt; (x3: <span class="type">T3</span>) =&gt; apply(x1, x2, x3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在curried方法中，Function3的每个参数都被拆分成一个独立的参数列表，每个参数列表对应的函数逐层嵌套形成了新的函数。</p><p>调用下前面的函数res1的curried方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res1.curried</span><br><span class="line">res2: Int =&gt; (Int =&gt; (((Int, Int) =&gt; Int) =&gt; Int)) = &lt;function1&gt;</span><br></pre></td></tr></table></figure></p><p>res1调用curried方法后生成的新函数res2类型为Function1，并且函数体又多了一层嵌套。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Curry化的本质是将多参数函数转为多个单参数函数的级联，以便于进行lambda运算——这是官方的说法。  </p><p>说下自己的理解：Curry化更多的情况下是一种语法糖而已，和部分应用函数一样，在scala中并不是一种支撑性的角色。我们可以将多个单参数函数组合在一起，也可以使用函数递归来解决一些特定的问题，但是不必要将这种用法称为curry化。当然，这只是我的一偏之见。如有不同意见，欢迎一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。&lt;/p&gt;
&lt;p&gt;scala里的curry化可以把函数从接收
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="柯里化" scheme="http://scala.chobit.org/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
      <category term="Curry化" scheme="http://scala.chobit.org/tags/Curry%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180516/c01-particialFuncion/"/>
    <id>http://scala.chobit.org/wiki/20180516/c01-particialFuncion/</id>
    <published>2018-05-15T23:01:16.000Z</published>
    <updated>2018-05-15T23:12:52.038Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><p>至于为什么会抛出这个异常，因为scala的语言太过简洁，有必要看一下对这个类的字节码文件反编译后的结果，其中主要是看一下偏函数find的实现。使用scalac完成编译后，可以看到生成了三个字节码文件：</p><blockquote><p>MyFunc$$anonfun$1.class<br>MyFunc$.class<br>MyFunc.class</p></blockquote><p>使用jd-gui打开MyFunc$.class可以看到find的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.find = <span class="keyword">new</span> AbstractPartialFunction.mcLI.sp() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;A1, B1&gt; <span class="function">B1 <span class="title">applyOrElse</span><span class="params">(A1 x1, Function1&lt;A1, B1&gt; <span class="keyword">default</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        Object localObject;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) localObject = <span class="string">"It's Target."</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            localObject = <span class="keyword">default</span>.apply(BoxesRunTime.boxToInteger(x1));</span><br><span class="line">        <span class="keyword">return</span> localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDefinedAt</span><span class="params">(<span class="keyword">int</span> x1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        <span class="keyword">boolean</span> bool;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) bool = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/yuanguangyu1221/article/details/71307664" rel="external nofollow noopener noreferrer" target="_blank">偏函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/20832218?refer=insight" rel="external nofollow noopener noreferrer" target="_blank">scala中的Partial Function</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是一个偏函数的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
      <category term="scala探索" scheme="http://scala.chobit.org/categories/scala%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
