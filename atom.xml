<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCALA 手账</title>
  
  <subtitle>scala</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scala.chobit.org/"/>
  <updated>2018-06-09T02:52:30.661Z</updated>
  <id>http://scala.chobit.org/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>scala集合概述</title>
    <link href="http://scala.chobit.org/wiki/20180608/a30-collectionOverview/"/>
    <id>http://scala.chobit.org/wiki/20180608/a30-collectionOverview/</id>
    <published>2018-06-08T14:28:19.000Z</published>
    <updated>2018-06-09T02:52:30.661Z</updated>
    
    <content type="html"><![CDATA[<p>##可变与不可变</p><p>scala的集合包括Set、List和Map。三种集合的特征和Java中的一样。scala为每种集合都提供了可变和不可变两种版本，分别位于scala.collection.mutable或scala.collection.immutable包下。scala建议使用尽量使用不可变集合，尤其是在多线程环境下。scala默认的集合就是不变的版本。</p><p>可变集合没什么好说的，java中的集合就是。来看一个不可变集合的实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>)</span><br><span class="line"><span class="keyword">var</span> c2 = c1</span><br><span class="line"></span><br><span class="line">c2 += <span class="string">"Black"</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"c2: "</span> + c2)</span><br><span class="line">println(<span class="string">"c1: "</span> + c1)</span><br></pre></td></tr></table></figure></p><p>代码中先创建了一个不可变的Set实例并将之赋给一个val变量c1。而后又将immutable Set实例通过c1赋给了var变量c2。c2调用了immutable Set的“+”方法，“+”方法的作用是在原集合的基础上添加元素并创建一个新的实例。所以现在c2是另一个Set实例了。看下程序输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c2: Set(Blue, Green, Red, Black)</span><br><span class="line">c1: Set(Blue, Green, Red)</span><br></pre></td></tr></table></figure></p><h2 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h2><p>主要是看一下集合的几个常用方法。至于其他的方法有机会再单独解释。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h4><p>filter()方法用来从Set中过滤获取含有指定特征的元素。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"><span class="keyword">val</span> filteredSet = colors1 filter (_ contains <span class="string">"l"</span>)</span><br><span class="line">println(filteredSet mkString <span class="string">","</span>)</span><br></pre></td></tr></table></figure><p>上面的代码从一个Set中过滤出了含有字符“l”的元素，而后调用mkString方法将过滤结果拼接打印出来。看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blue,yellow</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="++()方法"></a>++()方法</h4><p>++()方法用来拼接两个Set。示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"><span class="keyword">val</span> colors2 = <span class="type">Set</span>(<span class="string">"White"</span>, <span class="string">"Black"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> combinedSet = colors1 ++ colors2</span><br><span class="line">println(combinedSet mkString <span class="string">","</span>)</span><br></pre></td></tr></table></figure></p><p>看一下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Red,Blue,White,Black,Green,yellow</span><br></pre></td></tr></table></figure></p><h4 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h4><p>map()方法可以对Set的每个元素进行处理，最后返回一个新的集合。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors1 = <span class="type">Set</span>(<span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Red"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> colorSet = colors1.map(<span class="string">"color is : "</span> + _)</span><br><span class="line"></span><br><span class="line">colorSet.foreach(println)</span><br></pre></td></tr></table></figure><p>这里打印Set元素时使用了内置的迭代器foreach。执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color is : Blue</span><br><span class="line">color is : Green</span><br><span class="line">color is : Red</span><br><span class="line">color is : yellow</span><br></pre></td></tr></table></figure></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="filterKeys-方法"><a href="#filterKeys-方法" class="headerlink" title="filterKeys()方法"></a>filterKeys()方法</h4><p>filterKeys()方法用来对Map的key进行过滤，示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line"><span class="keyword">val</span> filteredMap = roster.filterKeys.(_ contains (<span class="string">"Jac"</span>))</span><br><span class="line">println(<span class="string">"Filtered Size : "</span> + filteredMap.size)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filtered Size : 1</span><br></pre></td></tr></table></figure></p><h4 id="filter-方法-1"><a href="#filter-方法-1" class="headerlink" title="filter()方法"></a>filter()方法</h4><p>也可以使用filter()方法来执行过滤，不过filter()方法中的函数值操作的对象是Key-Value对。看一下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line"><span class="keyword">val</span> filteredMap = roster.filter &#123;</span><br><span class="line">  ele =&gt;</span><br><span class="line">    <span class="keyword">val</span> (k, v) = ele</span><br><span class="line">    k contains (<span class="string">"Jac"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Filtered Size : "</span> + filteredMap.size)</span><br></pre></td></tr></table></figure><p>执行结果和上面的filterKeys方法是一样的，就不重复贴了。</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get()方法用来从Map中取值，不过返回值的类型是Optional[T]，示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line">println(<span class="string">"Jack"</span> +  <span class="string">" is a "</span> + (roster.get(<span class="string">"Jack"</span>).get )</span><br></pre></td></tr></table></figure></p><p>说实话，我不太喜欢Optional，还好scala不需要让我忍受这个东西，它还提供了另一种更简洁的获取kv对的方式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line">println(<span class="string">"Jack"</span> +  <span class="string">" is a "</span> + roster(<span class="string">"Jack"</span>) )</span><br></pre></td></tr></table></figure></p><p>在上面的代码里我们直接在Map对象后面使用了一个括号来取值。这是使用了Map的一个工厂方法apply。</p><h4 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a>update()方法</h4><p>update()方法可以用来“更新”Map对象。因为我们用的Map是一个immutable Map的对象，它的“更新”并不会影响当前的对象，而是返回一个新的对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> roster = <span class="type">Map</span>(<span class="string">"Jack"</span> -&gt; <span class="string">"Solider"</span>, <span class="string">"Jane"</span> -&gt; <span class="string">"Teacher"</span>)</span><br><span class="line"><span class="keyword">val</span> updatedRoster = roster.updated(<span class="string">"Jane"</span>, <span class="string">"Nurse"</span>)</span><br><span class="line">println(<span class="string">"Jane"</span> +  <span class="string">" is a "</span> + roster(<span class="string">"Jane"</span>) )</span><br><span class="line">println(<span class="string">"Jane"</span> +  <span class="string">" is a "</span> + updatedRoster(<span class="string">"Jane"</span>) )</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jane is a Teacher</span><br><span class="line">Jane is a Nurse</span><br></pre></td></tr></table></figure></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>在scala中Set和Map都有可变和不变两种实现，但是List只有不变的实现。scala中的List实现有些类似于java的LinkedList。scala的List的大部分操作都是围绕head和tail执行的。</p><p>如下是一个List使用的示例，我们要访问List示例的第一个元素可以使用list.head()方法也可以直接执行list(0)：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line">println(list1.head)</span><br><span class="line">println(list1(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Red</span><br><span class="line">Red</span><br></pre></td></tr></table></figure></p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="::()方法"></a>::()方法</h4><p>这个方法用于在List前添加元素。a :: list可以读作“在List前添加a”。示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="string">"Black"</span>::list1</span><br><span class="line">println(list1.mkString(<span class="string">","</span>))</span><br><span class="line">println(list2.mkString(<span class="string">","</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Red,Yellow,Blue</span><br><span class="line">Black,Red,Yellow,Blue</span><br></pre></td></tr></table></figure></p><h4 id="方法-2"><a href="#方法-2" class="headerlink" title=":::()方法"></a>:::()方法</h4><p>这个方法用于将一个List实例添加到另一个List实例前面。list ::: listA 可以读作“在listA前添加list”。示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="string">"Black"</span> :: list1</span><br><span class="line"><span class="keyword">val</span> combinedList = list2 ::: list1</span><br><span class="line"></span><br><span class="line">println(list1.mkString(<span class="string">","</span>))</span><br><span class="line">println(list2.mkString(<span class="string">","</span>))</span><br><span class="line">println(combinedList.mkString(<span class="string">","</span>))</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Red,Yellow,Blue</span><br><span class="line">Black,Red,Yellow,Blue</span><br><span class="line">Black,Red,Yellow,Blue,Red,Yellow,Blue</span><br></pre></td></tr></table></figure><p>请注意：以上两个List的方法操作对象都是操作符后的List实例。</p><h4 id="forall-和exists"><a href="#forall-和exists" class="headerlink" title="forall()和exists()"></a>forall()和exists()</h4><p>用forall()方法可以检查是否所有元素都满足某一特定条件。而想了解是否存在某些元素满足特定条件，可以用exists()。示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>)</span><br><span class="line">println(list1 forall (_ contains (<span class="string">"R"</span>)))</span><br><span class="line">println(list1 exists (_ contains (<span class="string">"R"</span>)))</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##可变与不可变&lt;/p&gt;
&lt;p&gt;scala的集合包括Set、List和Map。三种集合的特征和Java中的一样。scala为每种集合都提供了可变和不可变两种版本，分别位于scala.collection.mutable或scala.collection.immutable包
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="集合" scheme="http://scala.chobit.org/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="List" scheme="http://scala.chobit.org/tags/List/"/>
    
      <category term="Set" scheme="http://scala.chobit.org/tags/Set/"/>
    
      <category term="Map" scheme="http://scala.chobit.org/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>apply方法</title>
    <link href="http://scala.chobit.org/wiki/20180607/b014-applyMethod/"/>
    <id>http://scala.chobit.org/wiki/20180607/b014-applyMethod/</id>
    <published>2018-06-07T14:37:03.000Z</published>
    <updated>2018-06-08T13:46:25.488Z</updated>
    
    <content type="html"><![CDATA[<p>scala的apply方法有一个特性：就是在调用apply方法的时候可以省略方法名，即可以用 “<strong>类名或实例名 + ([参数列表])</strong>”这样的形式来使用。</p><p>scala中数组的定义和使用就是apply方法的一个典型实例，来看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val arr = Array(1,3,5,7,9)</span><br><span class="line">arr: Array[Int] = Array(1, 3, 5, 7, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; arr(3)</span><br><span class="line">res0: Int = 7</span><br></pre></td></tr></table></figure><p>构建数组实例的时候调用了object Array的一个apply方法，通过索引获取数组元素的时候调用的是class Array的一个apply方法。调用这两apply方法的时候，方法名被省略掉了，但是在使用上却更直观了。</p><p>通过刚才这个数组的例子，我们了解到在scala中apply方法有两种，一种是object中的apply方法，一种是class中的apply方法。接下来我们会尝试自己定义使用这两种apply方法。</p><p>先来看下class中apply方法的使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = print(<span class="string">s"<span class="subst">$name</span> is a coder."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(job: <span class="type">String</span>) = println(<span class="string">s"<span class="subst">$name</span>'s job is <span class="subst">$job</span>."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">Coder</span>(<span class="string">"robin"</span>)</span><br><span class="line"></span><br><span class="line">  c()</span><br><span class="line">  c(<span class="string">"coding"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到class的apply方法的作用就是可以通过实例并省略方法名来调用。</p><p>再来看下object的apply方法，其实也是一样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Coder</span> = <span class="keyword">new</span> <span class="type">Coder</span>(name)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> c = <span class="type">Coder</span>(<span class="string">"robin"</span>)</span><br><span class="line">  <span class="type">Coder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply方法的作用就是这样：可以让开发者更简单的调用apply方法。</p><p>上面的例子我做了一个不好的示范：因为这几个apply方法大多定义得没有意义——除了伴生对象中的创建实例的那个。apply方法是如此特殊，在使用的时候也应慎重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的apply方法有一个特性：就是在调用apply方法的时候可以省略方法名，即可以用 “&lt;strong&gt;类名或实例名 + ([参数列表])&lt;/strong&gt;”这样的形式来使用。&lt;/p&gt;
&lt;p&gt;scala中数组的定义和使用就是apply方法的一个典型实例，来看一下：&lt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="apply" scheme="http://scala.chobit.org/tags/apply/"/>
    
  </entry>
  
  <entry>
    <title>implicit-scala隐式处理</title>
    <link href="http://scala.chobit.org/wiki/20180531/a29-implicit/"/>
    <id>http://scala.chobit.org/wiki/20180531/a29-implicit/</id>
    <published>2018-05-30T22:07:47.000Z</published>
    <updated>2018-06-09T03:02:01.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先来看看下面的内容：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> days “ago”</span><br><span class="line"><span class="number">5</span> days “from_now”</span><br></pre></td></tr></table></figure></p><p>这段内容大家怎么看。首先这确定是一段代码（不是代码也没有必要提了），但是也可以确定的是scala的整型是没有days这样的方法的——在Int、RichInt还有Java的Integer中都没有days方法。  </p><p>那么是怎样为整型值添加days方法的，或者说是如何扩展整型的方法的。  </p><p>在scala中我们可以使用隐式类型转换来扩展类的能力。关于隐式类型转换，我手边的教材是这样说的：</p><blockquote><p>隐式类型转换可以帮助我们扩展语言，创建“专用于特定应用和领域”的词汇或语法，也可以帮助我们创建属于自己的领域专用语言。</p></blockquote><p>这句话说明了隐式类型转换的主要作用。</p><p>再来看看隐式类型转换具体是怎样发挥作用的。还以最初的那段代码为例，看一下是怎样为整型添加days方法的。</p><p>首先，我们需要创建一个DateHelper类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">number: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">Date</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> date = <span class="type">Calendar</span>.getInstance()</span><br><span class="line">    when <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, -number)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, number)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; date</span><br><span class="line">    &#125;</span><br><span class="line">    date.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在DateHelper方法中定义了days方法。可以明确地说这个days方法就是一开始的示例中的days方法。DateHelper类还有一个整型值的构造器。那么怎样使用隐式类型转换让整型值可以调用DateHelper的days方法？我们需要使用<strong>implicit</strong>关键字，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(number: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(number)</span><br></pre></td></tr></table></figure></p><p>这段代码将一个整型值转为了DateHelper实例。此时再让整型值调用days方法就可以了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(number: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(number)</span><br><span class="line"></span><br><span class="line">println(<span class="number">1</span> days <span class="string">"ago"</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tue Jun 05 07:09:29 CST 2018</span><br></pre></td></tr></table></figure></p><h2 id="隐式转换函数"><a href="#隐式转换函数" class="headerlink" title="隐式转换函数"></a>隐式转换函数</h2><p>刚才的例子就是一个隐式转换函数的实例。在这个例子中定义的隐式转换函数为convertInt2DateHelper。通过这个函数我们可以将DateHelper类的能力提供给一个整型值。另外，需要啰嗦一下：隐式转换函数的名称对其功能没有任何影响，只要能表达其含义，具备可读性即可。</p><p>接下来我们尝试优化一下前面的实例中的隐式转换。每次需要进行隐式转换时就定义一个隐式转换函数并不是一个很好的做法。我们可以把这个隐式转换函数定义在某个位置（比如某个包或某个类），在需要的时候import过来即可。对于我们这个实例来说，一个比较理想的位置就是DateHelper类的伴生对象了。来看下调整后的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Calendar</span>, <span class="type">Date</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">number: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">Date</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> date = <span class="type">Calendar</span>.getInstance()</span><br><span class="line">    when <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, -number)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; date.add(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>, number)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; date</span><br><span class="line">    &#125;</span><br><span class="line">    date.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(number: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DateHelper</span>._</span><br><span class="line"></span><br><span class="line">  println(<span class="number">1</span> days <span class="string">"ago"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MyApp类中我们通过“ import DateHelper._”调用了DateHelper object中的convertInt2DateHelper函数完成了隐式转换。如果应用场景类没有和DateHelper类在同一个包下，那么就可以在顶部引用中引入convertInt2DateHelper函数并进行使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhyea.<span class="type">DateHelper</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="number">1</span> days <span class="string">"ago"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p>一般定义的函数中，通常需要明确传入参数，如下例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s"Hello <span class="subst">$name</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(<span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure><p>但是如果函数的参数是隐式参数的话，则可以不必传入：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> gender: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  gender <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"male"</span> =&gt; println(<span class="string">s"Hello Mr <span class="subst">$name</span>!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"female"</span> =&gt; println(<span class="string">s"Hello Ms <span class="subst">$name</span>!"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Hello <span class="subst">$name</span>!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> gender: <span class="type">String</span> = <span class="string">"male"</span></span><br><span class="line"></span><br><span class="line">hello(<span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><p>声明函数时，隐式参数用implicit关键字声明，并以curry化形式使用。</p><p>调用含有隐式参数的函数时，可以不传入隐式参数，但是在调用隐式参数的上下文中，必须能找到可用的隐式参数。也就是说，在如下的情况下，调用hello函数也是OK的（因为隐式变量是在调用函数后提供的，执行结果是不一样的）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello(<span class="string">"robin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> g: <span class="type">String</span> = <span class="string">"male"</span></span><br></pre></td></tr></table></figure></p><p>但是如果不提供任何可用的隐式变量，就不能通过编译了。</p><h2 id="隐式处理规则"><a href="#隐式处理规则" class="headerlink" title="隐式处理规则"></a>隐式处理规则</h2><p>在scala中，隐式处理是普遍存在的，比如我们可以执行“1 to 7”这样的语句，就是因为Scala隐式地将1从Int类型转换为其富封装器RichInt类型。  </p><p>Int到RichInt的转换是定义在Predef对象中的（确切说是在Predef的超类LowPriorityImplicits中）。Predef对象中封装了一系列隐式类型转换函数定义。在我们每次执行scala程序时都会默认引用Predef对象，因此也默认引用了这些隐式转换函数。可以看几个Predef中定义的隐式转换函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">byte2Byte</span></span>(x: <span class="type">Byte</span>)           = java.lang.<span class="type">Byte</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">short2Short</span></span>(x: <span class="type">Short</span>)        = java.lang.<span class="type">Short</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">char2Character</span></span>(x: <span class="type">Char</span>)      = java.lang.<span class="type">Character</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Integer</span></span>(x: <span class="type">Int</span>)          = java.lang.<span class="type">Integer</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">long2Long</span></span>(x: <span class="type">Long</span>)           = java.lang.<span class="type">Long</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">float2Float</span></span>(x: <span class="type">Float</span>)        = java.lang.<span class="type">Float</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">double2Double</span></span>(x: <span class="type">Double</span>)     = java.lang.<span class="type">Double</span>.valueOf(x)</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">boolean2Boolean</span></span>(x: <span class="type">Boolean</span>)  = java.lang.<span class="type">Boolean</span>.valueOf(x)</span><br></pre></td></tr></table></figure></p><p>上面是scala使用隐式转换处理Java基本类型自动装箱和自动拆箱的代码。</p><p>那么什么时候会进行隐式处理呢？根据我们前面的实例可以推测出大致有这几种情况：</p><ol><li>调用方法时使用的参数列表和定义的参数列表不一致时；</li><li>值的类型与预期类型不一致时；</li><li>调用类中不存在的方法或成员时。</li></ol><p>第二种情况前面没有提到过，用scala解释器演示下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def double2Int(i:Double)=i.toInt</span><br><span class="line">warning: there was one feature warning; re-run with -feature <span class="keyword">for</span> details</span><br><span class="line">double2Int: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; def foo(x:Int)=<span class="built_in">print</span>(x)</span><br><span class="line">foo: (x: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(3.14)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>这里演示的是调用方法时产生了隐式转换。也许像下面这样更直观一些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val i:Int = 3.14</span><br><span class="line">i: Int = 3</span><br></pre></td></tr></table></figure></p><p>需要Int值，却提供了一个浮点值。scala检查到当前上下文中存在整型值到浮点值的隐式转换函数，就调用隐式转换函数将浮点值转为了整型值。</p><p>简而言之：在当前范围内，如果发现通过类型转换有助于操作、方法调用或类型转换的成功完成，就会进行转换。</p><p>再看下不进行隐式处理的情况，大概有这么几种：</p><ol><li>如果没有隐式转换函数或隐式变量，编译也可以通过，说明不需要进行隐式处理；</li><li>如果存在二义性，则无法进行隐式处理；</li><li>隐式处理无法嵌套执行，一次至多只能应用一次隐式转换。</li></ol><p>解释下后两种情况。关于二义性，看下这个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def double2Int(i:Double)=i.toInt</span><br><span class="line">double2Int: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def doubleToInt(i:Double)=i.toInt</span><br><span class="line">doubleToInt: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; val i:Int = 3.14</span><br><span class="line">&lt;console&gt;:16: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Double(3.14)</span><br><span class="line"> required: Int</span><br><span class="line">Note that implicit conversions are not applicable because they are ambiguous:</span><br><span class="line"> both method double2Int of <span class="built_in">type</span> (i: Double)Int</span><br><span class="line"> and method doubleToInt of <span class="built_in">type</span> (i: Double)Int</span><br><span class="line"> are possible conversion <span class="built_in">functions</span> from Double(3.14) to Int</span><br><span class="line">       val i:Int = 3.14</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure></p><p>在解释器中定义了两个将整型转为浮点型的函数，两个函数的处理方式是一样的，只是名称略有不同，然而在编译时报错了，提示ambiguous，即存在二义性。</p><p>为了避免二义性，在同一个作用范围内，尽量不要出现相同类型的隐式变量和隐式函数。</p><p>至于第三点，可以看一下下面的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def double2Int(i:Double)=i.toInt</span><br><span class="line">double2Int: (i: Double)Int</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def int2Boolean(i:Int)=i &gt; 2</span><br><span class="line">int2Boolean: (i: Int)Boolean</span><br><span class="line"></span><br><span class="line">scala&gt; val b:Boolean = 3.14</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Double(3.14)</span><br><span class="line"> required: Boolean</span><br><span class="line">       val b:Boolean = 3.14</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure></p><p>在解释器中尝试将一个浮点值赋值给一个boolean型的变量。这里期望先为这个浮点值调用double2Int函数隐式转换为整型值，然后在调用int2Boolean函数隐式转换为boolean类型。不过程序并没有按照预期的路线一个接一个的嵌套执行隐式转换，而是直接报错了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;先来看看下面的内容：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="implicit" scheme="http://scala.chobit.org/tags/implicit/"/>
    
  </entry>
  
  <entry>
    <title>trait和抽象类</title>
    <link href="http://scala.chobit.org/wiki/20180530/a28-traitAndAbstractClass/"/>
    <id>http://scala.chobit.org/wiki/20180530/a28-traitAndAbstractClass/</id>
    <published>2018-05-30T13:59:06.000Z</published>
    <updated>2018-06-06T13:49:00.766Z</updated>
    
    <content type="html"><![CDATA[<p>发现前面多次提到了抽象类，可是却从没有正式的介绍过抽象类这个概念。在这里一起说下。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>scala的抽象类的定义和Java的差不多。使用了关键词abstract声明的类叫作抽象类。如果一个类里包含了一个或多个抽象方法，该类就必须被定义为抽象类。抽象方法属于一种不完整的方法，抽象方法只有方法声明，没有方法体。</p><p>下面的代码演示了抽象类的定义和实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathTeacher</span>(<span class="params">override val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Teacher</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> age = <span class="number">29</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(): <span class="type">Unit</span> = println(<span class="string">"teaching Math"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">MathTeacher</span>(<span class="string">"tom"</span>)</span><br><span class="line"></span><br><span class="line">  teacher.teach</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中定义了抽象类Teacher，抽象类中有抽象字段（name和age）和抽象方法（teach()方法）。</p><p>抽象类有如下几个特征：</p><ol><li>在普通类中 字段必须赋值(包括赋具体的值和使用下划线为var变量赋默认值) </li><li>抽象类不需要初始化</li><li>抽象类中可以有抽象方法 </li><li>只定义不赋值的字段为抽象字段 </li><li>只声明而不实现的方法为抽象方法；和java不同，scala的抽象方法不强制使用abstract关键字声明，只需不写方法体即可</li></ol><h2 id="trait和抽象类"><a href="#trait和抽象类" class="headerlink" title="trait和抽象类"></a>trait和抽象类</h2><p>介绍下trait和抽象方法的异同。</p><p>二者的相似之处：</p><ol><li>都可以有普通方法和抽象方法；</li><li>都可以有普通成员变量和抽象变量；</li><li>抽象类能做的事情trait都能做。</li></ol><p>二者的不同之处：</p><ol><li>trait可以多重混入，抽象类只能单继承；</li><li>抽象类可以定义构造函数；</li><li>trait可以混入object，抽象类不可以。</li></ol><p>那什么时候用trait，什么时候用抽象类呢：</p><ol><li>优先使用trait。一个类扩展多个trait是很方便的，但却只能扩展一个抽象类。</li><li>如果你需要构造函数参数，使用抽象类。因为抽象类可以定义带参数的构造函数，而trait不行。例如，不能定义trait T(i: Int) {}，参数i是非法的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;发现前面多次提到了抽象类，可是却从没有正式的介绍过抽象类这个概念。在这里一起说下。&lt;/p&gt;
&lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;scala的抽象类的定义和Java
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
      <category term="抽象类" scheme="http://scala.chobit.org/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>trait方法延迟绑定</title>
    <link href="http://scala.chobit.org/wiki/20180530/a27-traitDelayBinding/"/>
    <id>http://scala.chobit.org/wiki/20180530/a27-traitDelayBinding/</id>
    <published>2018-05-29T23:14:00.000Z</published>
    <updated>2018-05-30T13:54:17.402Z</updated>
    
    <content type="html"><![CDATA[<p>关于延迟绑定上一节已经提到过了。这次再专门说一下。  </p><p>延迟绑定简单来说就是先混入的trait的方法会后调用。</p><p>再来看一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UpperWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span> = <span class="keyword">super</span>.write(message.toUpperCase)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">FilterWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span> = <span class="keyword">super</span>.write(message.replace('o', '-'))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">StringWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(message: <span class="type">String</span>): <span class="type">String</span> = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> myWriter1 = <span class="keyword">new</span> <span class="type">StringWriter</span> <span class="keyword">with</span> <span class="type">UpperWriter</span> <span class="keyword">with</span> <span class="type">FilterWriter</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> myWriter2 = <span class="keyword">new</span> <span class="type">StringWriter</span> <span class="keyword">with</span> <span class="type">FilterWriter</span> <span class="keyword">with</span> <span class="type">UpperWriter</span></span><br><span class="line"></span><br><span class="line">  println(myWriter1.write(<span class="string">"Hello World!"</span>))</span><br><span class="line"></span><br><span class="line">  println(myWriter2.write(<span class="string">"Hello World!"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中定义了一个抽象类和三个trait。</p><p>其中抽象类Writer仅定义了一个抽象方法，并没有提供具体的实现。继承抽象类Writer的trait需要实现write方法。</p><p>UpperWriter的write方法实现了将传入的英文字符转为大写；</p><p>FilterWriter的write方法实现了将小写的“o”替换为“-”；</p><p>StringWriter则只是将传入的字符串原样返回。</p><p>看下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELL- W-RLD!</span><br><span class="line">HELLO WORLD!</span><br></pre></td></tr></table></figure><p>验证了我们的说法：延迟绑定就是先混入的trait会后执行。</p><p>myWriter1的执行顺序：FilterWriter –&gt; UpperWriter –&gt; StringWriter；</p><p>myWriter2的执行顺序：UpperWriter –&gt; FilterWriter –&gt; StringWriter。</p><p>从trait的延迟绑定很容易会想到java的父类与子类的初始化顺序。又或者是java中的责任链模式。因此想想用java来实现这一点并不难：可以采用不同顺序的责任链，也可以是使用不同的继承顺序来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于延迟绑定上一节已经提到过了。这次再专门说一下。  &lt;/p&gt;
&lt;p&gt;延迟绑定简单来说就是先混入的trait的方法会后调用。&lt;/p&gt;
&lt;p&gt;再来看一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>trait选择性混入</title>
    <link href="http://scala.chobit.org/wiki/20180529/a26-traitSelectiveMixedIn/"/>
    <id>http://scala.chobit.org/wiki/20180529/a26-traitSelectiveMixedIn/</id>
    <published>2018-05-29T13:54:15.000Z</published>
    <updated>2018-05-31T13:40:25.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>上一节有说过如何在类级别混入trait，还举了一个人类的朋友Dog的例子。代码是这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span></span></span><br></pre></td></tr></table></figure><p>继续从这个例子展开来。并不是所有的狗都是人类的朋友，比如藏獒，这玩意儿又蠢又笨又凶狠，肯定不能算是很多人的好朋友了。我们更希望在创建一个Dog的实例后，再选择性地为其混入HumanFriend这个特质。也就是在对象级别混入trait。来看下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> tom = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>) <span class="keyword">with</span> <span class="type">HumanFriend</span></span><br><span class="line"></span><br><span class="line">  tom.accompany()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次没有为Dog类混入HumanFriend trait，而是在创建Dog的实例tom的时候混入了HumanFriend trait。虽然是在对象级别混入的，Dog实例tom也可以调用HumanFriend的accompany方法。如果此时Dog的实例没有混入HumanFriend，却还是调用了accompany方法，就会无法完成编译。</p><p>另外，关于HumanFriend的抽象成员变量name还得提一句。在这个例子里，我们为Dog类也提供了一个成员变量name，所以在为其实例混入HumanFriend trait的时候就没有报错。但是如果一个没有名为name的成员变量的类混入HumanFriend时，就得提供相应的实现了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> simba = <span class="keyword">new</span> <span class="type">Lion</span> <span class="keyword">with</span> <span class="type">HumanFriend</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">"Simba"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  simba.accompany()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lion类没有任何成员变量，在为其实例混入HumanFriend trait的时候就得提供抽象成员变量name的具体实现了。</p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My Friend Simba accompanies with me.</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>依赖trait的选择性混入的能力，我们可以很容易地实现功能的增强，或者说是装饰器模式。来看个案例。</p><p>假设我们要对一个人进行审查，包括信用记录、收支记录、犯罪记录和工作记录等。但是我们并不会总是都要审查所有的内容，比如要买房时会审查信用记录和收支记录，申请出境时会审查犯罪记录和工作记录。</p><p>想想该怎么做：最简单的思路是为每种审查创建一个方法，然后在需要的时候将这些方法组合起来。更常用的方案是创建一个审查接口，为每种审查内容创建一个类，并实现审查方法。为最基础的审查，比如信用记录、收支记录等创建一个基础类还是可行的，但是如果要为每一种复合审查（如买房或申请出境等）都创建一个类就会面临一个问题：类膨胀。scala可以让我们避免这种问题，使用trait混入实例可以实现面对不同的审查提供不同的处理方案这样的灵活性。</p><p>首先我们需要定义一个抽象类Checker，实现一些在审查中的通用的行为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Check</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Application Details..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为每一类基础性的审查创建一个trait</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CreditCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123; <span class="comment">//信用审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Credit..."</span> + <span class="keyword">super</span>.check()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BalanceCheck</span> <span class="keyword">extends</span> <span class="title">Check</span></span>&#123;<span class="comment">//收支记录审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Balance..."</span> + <span class="keyword">super</span>.check() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">EmploymentCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;<span class="comment">//工作记录审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Checked Employment..."</span> + <span class="keyword">super</span>.check()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CriminalRecordCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;<span class="comment">//犯罪记录审查</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">String</span> = <span class="string">"Check Criminal Records..."</span> + <span class="keyword">super</span>.check()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里有一个有趣的地方：就是这里的几个trait都继承自一个抽象类。让trait继承抽象类有两个用处：</p><ol><li>这些trait可以使用Check的方法；</li><li>这些trait只能混入继承自Check的类。</li></ol><p>在每个trait里，都重写了check方法，在重写的同时也引用了Check类的方法，这也可以说是对Check类的修饰或增强。</p><p>trait里，通过super调用的方法会经历一个延迟绑定的过程。这个调用并不是对父类的调用，而是对其左边混入的trait的调用——如果这个trait已经是混入的最左trait，那么这个调用就会解析成混入这个trait的类的方法。具体如何可以看一下下面的例子是如何实现的。</p><p>来看一个买房申请：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> apartmentApplication = <span class="keyword">new</span> <span class="type">Check</span> <span class="keyword">with</span> <span class="type">CreditCheck</span> <span class="keyword">with</span> <span class="type">BalanceCheck</span></span><br><span class="line"></span><br><span class="line">println(apartmentApplication.check())</span><br></pre></td></tr></table></figure></p><p>在创建Check实例的同时混入了两个trait：CreditCheck和BalanceCheck。同样的也可以这样实现出境申请：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exitApplication = <span class="keyword">new</span> <span class="type">Check</span> <span class="keyword">with</span> <span class="type">CriminalRecordCheck</span> <span class="keyword">with</span> <span class="type">EmploymentCheck</span></span><br><span class="line"></span><br><span class="line">println(exitApplication.check())</span><br></pre></td></tr></table></figure><p>可以看出，如果想要按照不同的组合进行检查的话，只需要按照希望的组合将trait混入即可。</p><p>看一下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Checked Balance...Checked Credit...Checked Application Details...</span><br><span class="line">Checked Employment...Check Criminal Records...Checked Application Details...</span><br></pre></td></tr></table></figure><p>可以看到，是从最右的trait开始调用check()方法。然后，顺着super.check()，将调用传递到其左边的trait。最左的trait调用的是实例的check()方法。</p><p>在Scala里，trait是一个强有力的工具，可以用它混入横切关注点。使用它们可以以较低的成本创建出高度可扩展的代码。无需创建一个拥有大量类和接口的层次结构，就可以快速地把必要的代码投入使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;上一节有说过如何在类级别混入trait，还举了一个人类的朋友Dog的例子。代码是这样的：&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>Trait</title>
    <link href="http://scala.chobit.org/wiki/20180528/a25-traitSummary/"/>
    <id>http://scala.chobit.org/wiki/20180528/a25-traitSummary/</id>
    <published>2018-05-28T14:26:54.000Z</published>
    <updated>2018-05-29T13:51:17.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不知道大家对java的接口是如何理解的。在我刚接触到接口这个概念的时候，我将接口理解为一系列规则的集合，认为接口是对类的行为的规范。现在想来，将接口理解为是对类的规范多少有些偏颇，更恰当些的观点应该是：相对于类来说，接口是更深层次的抽象，虽然同时接口也起到了规定类的行为的作用。  </p><p>和java的接口比起来，scala的trait可能更具体一些。正如trait这个单词的本意一样，它指的是一种特质：如果认为类有某种特质就混入对应的trait好了。在scala中，类是对现实某一类事务的建模，而Trait则是对已有模型的补充。  </p><p>我自己以为，trait这个概念理解起来要比接口更容易一些。</p><p>看个例子吧：狗是人类的好朋友，它在我们孤单的时候默默地陪伴。用scala可以这样定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>() = println(<span class="string">s"My Friend <span class="subst">$name</span> accompanies with me. "</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span></span></span><br></pre></td></tr></table></figure><p>我们先定义了一个名为人类的朋友（HumanFriend）的trait，朋友的主要特征就是陪伴，所以在这个trait里面定义了一个方法accompany并做了实现。Dog（狗）具有人类的好朋友这个特质，所以可以混入trait HumanFriend。在scala中继承某个trait，通常也称为混入某个trait。</p><p>在trait HumanFriend中定义了一个val变量name。这个name没有默认值，我们可以认为它是抽象的，可以等到其他类混入这个trait时再为其赋值。</p><p>混入trait的类可以直接调用trait的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>).accompany()</span><br></pre></td></tr></table></figure></p><p>一个类混入trait后，我们可以认为其实例就是trait的引用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tom: <span class="type">HumanFriend</span>= <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>)</span><br></pre></td></tr></table></figure></p><p>一个trait会被编译为一个接口和一个抽象类。trait中定义的未赋值的val变量会被表示为一个抽象方法。</p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>混入trait的类可以重写trait的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span> accompany with me."</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写时需要使用override关键字。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>一个类混入trait的数量是任意的。用关键字<strong>with</strong>就可以混入更多的trait。比如，狗除了是人类的好朋友，还是忠诚的卫士，会保护我们：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Guard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">guard</span></span>() = println(<span class="string">s" <span class="subst">$name</span> guards me!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> <span class="keyword">with</span> <span class="title">Guard</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyTrait</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> tom = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"tom"</span>)</span><br><span class="line"></span><br><span class="line">  tom.accompany()</span><br><span class="line"></span><br><span class="line">  tom.guard()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog类同时混入了HumanFriend和Guard两个trait，所以它可以调用这两个trait的方法。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>前面提过，scala中的trait可以理解为是java中接口和抽象类的组合。那么在接口中定义抽象类也是可以的了。现在我们将HumanFriend中的accompany方法改为抽象方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HumanFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">accompany</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span> accompanies with me."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象方法需要在子类中提供实现。子类实现抽象方法时override关键字是可选的，但是建议最好加上。</p><h2 id="构造顺序"><a href="#构造顺序" class="headerlink" title="构造顺序"></a>构造顺序</h2><p>在网上看到了这段关于trait的构造顺序的描述，觉得有点儿意思就顺路转了过来。</p><p>trait也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该trait的对象在构造时都会被执行。</p><p>构造器的执行顺序：</p><ol><li>调用超类的构造器；</li><li>trait构造器在超类构造器之后、类构造器之前执行；</li><li>trait由左到右被构造；</li><li>每个trait当中，父trait先被构造；</li><li>如果多个trait共有一个父trait，父trait不会被重复构造</li><li>所有trait被构造完毕，子类被构造。</li></ol><p>构造器的顺序是类的线性化的反向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;不知道大家对java的接口是如何理解的。在我刚接触到接口这个概念的时候，我将接口理解为一系列规则的集合，认为接口是对类的行为的规范。现在想来
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="trait" scheme="http://scala.chobit.org/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://scala.chobit.org/wiki/20180527/a24-array/"/>
    <id>http://scala.chobit.org/wiki/20180527/a24-array/</id>
    <published>2018-05-27T14:04:05.000Z</published>
    <updated>2018-05-28T14:20:31.915Z</updated>
    
    <content type="html"><![CDATA[<p>简单说下scala中的数组。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>声明数组的语法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>]\(<span class="number">3</span>\)</span><br></pre></td></tr></table></figure></p><p>声明数组时必须指定数组的长度。数组的类型可以不指定，但是不指定的话，数组就是无用的，因为此时数组元素的类型是Nothing。</p><p>这样声明的数组其元素初始为字符串的默认值，即null。可以这样调整数组元素的值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr(<span class="number">0</span>) = <span class="string">"com"</span></span><br><span class="line">arr(<span class="number">1</span>) = <span class="string">"zhyea"</span></span><br><span class="line">arr(<span class="number">2</span>) = <span class="string">"robin"</span></span><br></pre></td></tr></table></figure></p><p>可以看到scala中获取数组元素的方法是：数组名 + 小括号 + 索引值。这里究其根本还是调用了Array类的apply(i:Int)方法，因此索引值也可以是一个表达式，比如arr(4/2)。</p><p>也可以在创建数组时完成初始化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>[<span class="type">String</span>](<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>调用object Array的ofDim方法可以创建一维到五维的数组。如下是一个创建二维数组的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matrix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>值的一提的是，在scala中本质上也是没有多维数组的。同java一样，所谓的多维数组其实质也是一维数组的嵌套（或者说是数组的数组）。这在object Array的二维数组的实现中可以很明显地看出来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ofDim</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]] = (<span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]](n1): <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">T</span>]])</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n1) arr(i) = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](n2)</span><br><span class="line">  arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>这里说的变长数组就是ArrayBuffer。ArrayBuffer更应该被归类到集合里面，但是既然看到了就一起写出来好了。在使用方式上ArrayBuffer有些类似于java里的ArrayList，但是要更灵活一些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">  arr += <span class="number">1</span> <span class="comment">//尾端添加一个元素</span></span><br><span class="line"></span><br><span class="line">  arr ++= <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//尾端添加一个数组</span></span><br><span class="line"></span><br><span class="line">  arr += (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">// 尾端添加多个元素</span></span><br><span class="line"></span><br><span class="line">  println(arr.mkString(<span class="string">", "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5, 6, 7</span><br></pre></td></tr></table></figure></p><p>ArrayBuffer和Array可以互相转换，只需分别调用toArray()和toBuffer()方法即可。</p><h2 id="数组应用"><a href="#数组应用" class="headerlink" title="数组应用"></a>数组应用</h2><p>关于数组觉得比较有趣的一个应用是在和变量一起的使用的时候，比如下面：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(a, b, c) = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">println(a)</span><br><span class="line">println(b)</span><br><span class="line">println(c)</span><br></pre></td></tr></table></figure></p><p>代码中通过一个数组完成了a、b、c三个变量的赋值。</p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>至于数组其他的应用，如循环、拼接、copy等操作，在使用的时候可以翻看一下API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单说下scala中的数组。&lt;/p&gt;
&lt;h2 id=&quot;声明数组&quot;&gt;&lt;a href=&quot;#声明数组&quot; class=&quot;headerlink&quot; title=&quot;声明数组&quot;&gt;&lt;/a&gt;声明数组&lt;/h2&gt;&lt;p&gt;声明数组的语法：&lt;br&gt;&lt;figure class=&quot;highlight sca
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数组" scheme="http://scala.chobit.org/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://scala.chobit.org/wiki/20180521/a23-closure/"/>
    <id>http://scala.chobit.org/wiki/20180521/a23-closure/</id>
    <published>2018-05-21T14:36:43.000Z</published>
    <updated>2018-05-26T02:48:25.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于闭包的概念，我手边scala的书如是说：</p><blockquote><p>闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。  </p></blockquote><p>在维基百科中的说法是：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p></blockquote><p>前者说闭包是一个函数，后者说闭包是函数和自由变量一同构成的实体。我个人是比较倾向于后者的。不过细细思考下来，二者也没什么差别，都描述了闭包的几个特征：</p><ol><li>闭包中有一个特殊的<strong>函数</strong>；</li><li>存在一个<strong>封闭</strong>的作用域，函数就在这个封闭的作用域中；</li><li>在封闭作用域中存在一个函数作用域之外的变量（即<strong>自由变量</strong>）；</li><li>闭包函数<strong>绑定</strong>了这个自由变量。</li></ol><p>来看个关于闭包的程序：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line">println(func(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个方法foo()，方法foo中有一个局部变量i。正常情况下只有在执行foo方法的时候，局部变量i才会存在；foo方法执行完成后，局部变量i就会消失，不再有意义。不过现在在foo方法中定义了一个内部方法bar()，在bar方法中引用了foo方法的局部变量i，最后是将bar转为函数值作为foo方法的返回值。</p><p>这段代码中的bar函数绑定了它的作用域之外的变量i。按照前文的说明：bar函数和变量i共同构成了一个闭包。</p><p>现在想一下：<strong>调用foo方法返回的bar函数时，foo的局部变量i是否有效？</strong> 显然的，根据维基百科的解释，虽然foo方法已经执行结束，但是局部变量i仍然和函数bar一同存在，调用bar函数，i仍然有效。</p><p>执行这段代码看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(): Int =&gt; Int = &#123;</span><br><span class="line">     |     val i = 1</span><br><span class="line">     |</span><br><span class="line">     |     def bar(num: Int) = &#123;</span><br><span class="line">     |       i + num</span><br><span class="line">     |     &#125;</span><br><span class="line">     |</span><br><span class="line">     |     bar</span><br><span class="line">     |   &#125;</span><br><span class="line">foo: ()Int =&gt; Int</span><br><span class="line"></span><br><span class="line">scala&gt;  val func = foo()</span><br><span class="line">func: Int =&gt; Int = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; println(func(2))</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>代码的执行结果和前面的推论是一致的。</p><p>根据这段代码我们可以看到闭包的“闭”封闭的是函数的外部作用域。在这个例子中，封闭的就是bar函数外的foo方法的作用域。整个闭包只有一个对外的通道，即bar函数，我们可以通过bar函数来访问封闭的作用域的内容。  </p><p>再来说明下闭包定义中的<strong>绑定</strong>两个字。闭包中的绑定并不是获得闭包绑定自由变量的一份副本，而是直接绑定到变量本身。在闭包中对自由变量的调整会影响到闭包外部的自由变量；同样的，外部自由变量的变化，闭包也会受到影响。下面这个例子应该可以说明这一点：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): () =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line"></span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br></pre></td></tr></table></figure><p>在代码中定义了一个闭包。闭包中的自由变量是i，在函数bar中对自由变量i做了调整。在闭包外，三次调用了闭包函数。这段代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">对比输出结果我们可以看到：每次调用闭包函数bar都会对自由变量i产生影响；而自由变量i的变化，又会在下一次执行bar函数的时候发挥作用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 思考 - 对象和闭包</span><br><span class="line"></span><br><span class="line">看完了闭包的示例代码后，回过头来再思考一下闭包的概念：  </span><br><span class="line"></span><br><span class="line">&gt; 闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那根据这个概念，下面这段代码是不是闭包：</span><br><span class="line">```scala</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">  private val i = 1</span><br><span class="line"></span><br><span class="line">  def bar(num: Int): Int = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了，还是直接看这段代码吧：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">A</span>().bar(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里定义了一个类A，类A有一个私有变量i，这个变量i只能通过bar方法访问，换言之bar方法也是引用了一个它的作用域之外的变量i。那么class A这个结构应该也算是闭包喽！？</p><p>但是这里的bar方法需要通过类A的对象来调用，它本质上是类A的一个实例成员，而非是一个独立的函数；另外这里的bar方法引用的变量i是绑定在类A的对象上，而非绑定在bar方法上，所以从根本上这种形式就不满足闭包的定义，所以不是闭包！？</p><p>对于这样定义的类是否是闭包，以上是两种观点，也是我纠结之处。也查了些资料，然而各种说法莫衷一是。思考了一段时间后决定停止这种纠结，仅从一点出发：<strong>只在函数作为头等公民的语境中来讨论闭包</strong>。</p><p>对象和函数各有自己不同的使用场景。在scala这种既支持函数又面向对象的语言中，使用对象可以减少一些复杂度，使用函数可以提升一些灵活性。但是把函数的概念放到面向对象的语境中，或者反过来都是没有意义的事情。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前想到的关于的闭包的用法主要有两种：一种是将闭包作为返回值，就如前面的例子；另一种是将闭包作为参数，如下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(f: (<span class="type">Int</span>) =&gt; <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>)</span><br><span class="line">  arr.filter(f).foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bar = (num: <span class="type">Int</span>) =&gt; num &gt; max</span><br><span class="line"></span><br><span class="line">foo(bar)</span><br></pre></td></tr></table></figure></p><p>又想到了一个应用场景，比如在一些对于面向对象支持不是很好的语言，可以用闭包来构建对象（用scala来举这个例子，有些费力，懒得写了）。严格来说，这种用法也是将函数用作闭包的返回值。</p><p>另外scala的curry化也是闭包的一种应用。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在知乎上有各路大神对闭包进行了讨论，有兴趣可以看一下：<a href="https://www.zhihu.com/question/34210214" rel="external nofollow noopener noreferrer" target="_blank">什么是闭包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;关于闭包的概念，我手边scala的书如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://scala.chobit.org/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Executor Aroud模式</title>
    <link href="http://scala.chobit.org/wiki/20180520/a22-executorAroudMode/"/>
    <id>http://scala.chobit.org/wiki/20180520/a22-executorAroudMode/</id>
    <published>2018-05-19T23:15:02.000Z</published>
    <updated>2018-05-19T23:35:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。</p><p>在scala里可以用函数值实现这种模式。下面是一个示例，使用Resource类演示了事务的开启和释放：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"Starting transaction..."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">cleanUp</span></span>() &#123;</span><br><span class="line">    println(<span class="string">"Ending transaction..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op1</span> </span>= println(<span class="string">"Operation 1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op2</span> </span>= println(<span class="string">"Operation 2"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op3</span> </span>= println(<span class="string">"Operation 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(codeBlock: <span class="type">Resource</span> =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = <span class="keyword">new</span> <span class="type">Resource</span> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codeBlock(resource)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resource.cleanUp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里将Resource类的构造器标记为private，这样就只能在Resource类内部和它的伴生类中创建实例。因为只能在这两个地方创建实例，就可以保证按照确定的方式使用这个类的对象，即可以保证其行为是按照确定的方式执行。cleanUp()方法也被标记为private，确保不会被意外调用。Resource类第一行的print语句是具体事务操作的占位符。调用构造函数时，事务启动；调用cleanUp()函数时，事务终结。此外Resource类中还准备了一些实例方法，如op1()、op2()等。</p><p>在伴生对象里有一个默认public的方法use，它接收一个函数值作为参数。use()方法创建了一个Resource的实例，在try和finally块的保护之下，把这个实例传给了给定的函数值。在finally块里，调用了Resource私有实例方法cleanUp()。</p><p>看一下是如何使用Resource类的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span>.use &#123; resource =&gt;</span><br><span class="line">  resource.op1</span><br><span class="line">  resource.op2</span><br><span class="line">  resource.op3</span><br><span class="line">  resource.op1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting transaction...</span><br><span class="line">Operation 1</span><br><span class="line">Operation 2</span><br><span class="line">Operation 3</span><br><span class="line">Operation 1</span><br><span class="line">Ending transaction...</span><br></pre></td></tr></table></figure><p>调用Resource的伴生对象的use方法时，会自动创建一个Resource实例，等到传递的函数值执行结束后，会自动调用cleanUp方法释放占用的资源。</p><p>上面模式的一个变体是Loan（借贷）模式。如果想确保非内存资源得到确定性释放，就可以使用这个模式。可以这样认为：这种资源密集型的对象是借给你的，用过之后应该立即归还。</p><p>下面是一个Loan模式的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeToFile</span></span>(fileName: <span class="type">String</span>)(codeBlock: <span class="type">PrintWriter</span> =&gt; <span class="type">Unit</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(fileName))</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    codeBlock(writer)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调用writeToFile()将一些内容写入文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeToFile(<span class="string">"output.txt"</span>) &#123; writer =&gt; writer write <span class="string">"hello from Scala"</span> &#125;</span><br></pre></td></tr></table></figure><p>这行这段代码会创建一个名为output.txt的文件，并在文件中写入一行文字“hello from Scala”。</p><p>作为writeToFile()方法的使用者，我们不必操心文件的关闭。在代码块里，这个文件是借给我们用的。我们可以用得到的PrintWriter实例进行写操作，一旦从这个块返回，方法就会自动关闭文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。&lt;/p&gt;
&lt;p&gt;在scala里可
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线和参数</title>
    <link href="http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/"/>
    <id>http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/</id>
    <published>2018-05-19T14:01:50.000Z</published>
    <updated>2018-05-19T14:11:57.033Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123; (sum, elem) =&gt; sum + elem &#125;)</span><br></pre></td></tr></table></figure><p>上面的代码里使用了“/:”方法。这个方法的意思大致上是从数组的左侧开始迭代运算。这里是用来计算数组中所有元素的和。因为在函数值中sum和elem只用了一次，所以这个函数也可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123;_+_&#125; )</span><br></pre></td></tr></table></figure><p>其中第一个“<em>”就是sum，即用来迭代运算的值；第二个“</em>”表示的是数组中的元素。这里是一处让人比较纠结的地方，这样做会让代码过于简洁，有时甚至让人费解。如果能在不失可读性又足够简洁的地方使用就最好了，来看一下下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> negativeNumberExists = arr.exists &#123; _ &lt; <span class="number">0</span> &#125;</span><br><span class="line">println(<span class="string">"Array has negative number? "</span> + negativeNumberExists)</span><br></pre></td></tr></table></figure></p><p>这里的代码用来查找数组中是否有小于0的元素。</p><p>在某些有意义的地方，这种简洁还可以更进一步。比如说我们想从一个数组中找出最大值。从这个需求出发，我们会一步步地简化实现的函数。最开始是这个样子的，我们使用了“/:”方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    a</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; (large, ele) =&gt; max(large, ele) &#125;)</span><br></pre></td></tr></table></figure><p>用下划线表示函数值参数来做一次简化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max(_, _) &#125;)</span><br></pre></td></tr></table></figure><p>“_”不仅可以表示一个参数，还可以表示整个参数列表。所以可以继续简化成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max _ &#125;)</span><br></pre></td></tr></table></figure><p>在上面的代码里，“_”表示整个参数列表。如果只是把参数传递给下层的方法，甚至可以省下使用“_”。上面的代码可以最终简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max &#125;)</span><br></pre></td></tr></table></figure><p>可以看到，依赖类型推断，scala的简洁到了丧心病狂（无贬义）的程度。这也给开发者留下了一个难题：需要适当克制自己简化代码的欲望，留下适当的可读性，不让代码变成天书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="下划线" scheme="http://scala.chobit.org/tags/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Curry化</title>
    <link href="http://scala.chobit.org/wiki/20180518/a21-currying/"/>
    <id>http://scala.chobit.org/wiki/20180518/a21-currying/</id>
    <published>2018-05-17T23:11:16.000Z</published>
    <updated>2018-05-28T22:27:42.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。</p><p>scala里的curry化可以把函数从接收多个参数转换成接收多个参数列表。也就是说我们写的多参数函数不再只是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>) &#123;???&#125;</span><br></pre></td></tr></table></figure></p><p>而是可以这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>或者这样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>甚至是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>来看个实例好了，下面的代码中定义了一个inject方法。inject方法有三个参数，两个Int型的参数，一个函数值参数。方法体中通过传入的函数对前两个Int型参数进行运算：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>, (a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure></p><p>在代码的最后一行还写了调用inject方法的一个示例。</p><p>有的时候可能会觉得把普通参数和函数值参数放在一起有点儿怪怪的。现在用curry化的方法将函数值参数独立开来：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>)(op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>) &#123; (a, b) =&gt; a + b &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到不管是在定义方式还是在使用方式上，代码都清爽了许多。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从方法的角度来看，Curry化只是一个语法糖，对方法的功能没有任何影响。    </p><p>将方法转为函数使用时，Curry化的影响就出现了。在scala解释器里看一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def inject(a: Int, b: Int, op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int, op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br></pre></td></tr></table></figure></p><p>我们在解释器里def了没有做Curry化的inject方法，并用“_”将inject方法转为函数。此时inject方法转成的函数是一个有三个参数的普通函数。  </p><p>再来看看Curry化后的inject方法转成的函数是怎样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;   def inject(a: Int, b: Int)(op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int)(op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>将两次生成的函数值对象res0和res1放在一起比较一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curry化之前： res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br><span class="line">Curry化之后： res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>inject方法Curry化之前转成的函数res0是一个三参数函数，继承自trait Function3；Curry化之后转成的函数res1是一个双参数函数，继承自trait Function2。  </p><p>用ABC来表示下inject方法的参数也许更直观些。inject方法最初为：inject(A, B, C)； curry化以后的结构是为：inject(A, B)(C)。inject方法curry化以后对应的函数res1为：</p><blockquote><p>(A, B)=&gt; (C)=&gt; Int</p></blockquote><p>可以看到res1实质上是被分解多个函数，inject方法的每个参数列表都对应一个函数，几个函数按参数列表顺序从右到左逐层嵌套，最左侧的参数列表即为最外侧的函数的参数。  </p><p>以上的内容说的是对方法进行Curry化。Scala也支持对函数进行Curry化。scala的多参数函数trait，包括Function2 ~ FuntionN都有一个curried方法，用来将函数的每个参数进行curry化。下面的代码是Function3的curried方法的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curried</span></span>: <span class="type">T1</span> =&gt; <span class="type">T2</span> =&gt; <span class="type">T3</span> =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">  (x1: <span class="type">T1</span>) =&gt; (x2: <span class="type">T2</span>) =&gt; (x3: <span class="type">T3</span>) =&gt; apply(x1, x2, x3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在curried方法中，Function3的每个参数都被拆分成一个独立的参数列表，每个参数列表对应的函数逐层嵌套形成了新的函数。</p><p>调用下前面的函数res1的curried方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res1.curried</span><br><span class="line">res2: Int =&gt; (Int =&gt; (((Int, Int) =&gt; Int) =&gt; Int)) = &lt;function1&gt;</span><br></pre></td></tr></table></figure></p><p>res1调用curried方法后生成的新函数res2类型为Function1，并且函数体又多了一层嵌套。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Curry化的本质是将多参数函数转为多个单参数函数的级联，以便于进行lambda运算——这是官方的说法。  </p><p>说下自己的理解：Curry化更多的情况下是一种语法糖而已，和部分应用函数一样，在scala中并不是一种支撑性的角色。我们可以将多个单参数函数组合在一起，也可以使用函数递归来解决一些特定的问题，但是不必要将这种用法称为curry化。当然，这只是我的一偏之见。如有不同意见，欢迎一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。&lt;/p&gt;
&lt;p&gt;scala里的curry化可以把函数从接收
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="柯里化" scheme="http://scala.chobit.org/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
      <category term="Curry化" scheme="http://scala.chobit.org/tags/Curry%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180516/c01-particialFuncion/"/>
    <id>http://scala.chobit.org/wiki/20180516/c01-particialFuncion/</id>
    <published>2018-05-15T23:01:16.000Z</published>
    <updated>2018-05-15T23:12:52.038Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><p>至于为什么会抛出这个异常，因为scala的语言太过简洁，有必要看一下对这个类的字节码文件反编译后的结果，其中主要是看一下偏函数find的实现。使用scalac完成编译后，可以看到生成了三个字节码文件：</p><blockquote><p>MyFunc$$anonfun$1.class<br>MyFunc$.class<br>MyFunc.class</p></blockquote><p>使用jd-gui打开MyFunc$.class可以看到find的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.find = <span class="keyword">new</span> AbstractPartialFunction.mcLI.sp() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;A1, B1&gt; <span class="function">B1 <span class="title">applyOrElse</span><span class="params">(A1 x1, Function1&lt;A1, B1&gt; <span class="keyword">default</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        Object localObject;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) localObject = <span class="string">"It's Target."</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            localObject = <span class="keyword">default</span>.apply(BoxesRunTime.boxToInteger(x1));</span><br><span class="line">        <span class="keyword">return</span> localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDefinedAt</span><span class="params">(<span class="keyword">int</span> x1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        <span class="keyword">boolean</span> bool;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) bool = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/yuanguangyu1221/article/details/71307664" rel="external nofollow noopener noreferrer" target="_blank">偏函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/20832218?refer=insight" rel="external nofollow noopener noreferrer" target="_blank">scala中的Partial Function</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是一个偏函数的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
      <category term="scala探索" scheme="http://scala.chobit.org/categories/scala%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180508/a20-partialFunction/"/>
    <id>http://scala.chobit.org/wiki/20180508/a20-partialFunction/</id>
    <published>2018-05-07T22:46:47.000Z</published>
    <updated>2018-05-17T15:14:18.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>scala的部分应用函数英文名为Partial Apply Function。此外，还有一个英文名为Partial Function的概念，即偏函数。</p><p>普通的函数会处理输入参数的全量的值，而偏函数只会处理输入参数中部分特定的值。  </p><p>偏函数在实现上有如下特征：  </p><ul><li>需要显示声明类型，类型为PartialFunction[-A, +B]，其中A为输入类型，B为输出类型；</li><li>输入参数只有一个，且输入类型已在PartialFunction的类型声明中指出，所以在声明偏函数的时候不需要像声明普通函数一样指明参数列表；</li><li>通常由包围在花括号中的一个或多个case语句构成，且花括号不可省略。</li></ul><p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><h2 id="组合运算"><a href="#组合运算" class="headerlink" title="组合运算"></a>组合运算</h2><p>scala提供了几个组合方法可以将两个偏函数组合在一起使用。常用的组合方法有：orElse、andThen和compose，现在分别看一下。</p><h3 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h3><p>orElse方法是在trait PartialFunction中定义的方法。使用orElse方法，可以在无法匹配一个偏函数的时候继续尝试匹配下一个。下面是一个使用orElse组合偏函数判断奇偶的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is odd."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findEven: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> check = findEven orElse findOdd</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(check(<span class="number">9</span>))</span><br><span class="line">    print(check(<span class="number">10</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个偏函数使用orElse方法组合后形成一个新的偏函数，并赋值给变量check。</p><p>代码中的check函数的作用等同于如下的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">  num <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>) =&gt; <span class="string">s"<span class="subst">$num</span> is odd."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序的执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 is odd.</span><br><span class="line">10 is even.</span><br></pre></td></tr></table></figure></p><p>使用orElse方法还可以直接组合case语句：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd orElse &#123;</span><br><span class="line">  <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的case语句被scala直接包装为偏函数来处理了。</p><h3 id="andThen"><a href="#andThen" class="headerlink" title="andThen"></a>andThen</h3><p>如果说orElse方法是将两个偏函数并联在一起，那么andThen方法就是将两个偏函数串联在了一起。经过andThen串联后，上一个函数的输出内容即是下一个函数的输入内容。最初的输入参数必须能够匹配所有被andThen串联在一起的偏函数，否则就会报scala.MatchError错误。</p><p>来看一个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findGreaterThanTen: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">10</span> =&gt; <span class="string">s"<span class="subst">$num</span> is greater than 10."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd andThen findGreaterThanTen</span><br><span class="line"></span><br><span class="line">  println(check(<span class="number">17</span>))</span><br><span class="line">  println(check(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中的两个偏函数被andThen方法串联起来构成了check函数，check函数要求输入的整型数值满足findOdd即为奇数，且满足findGreaterThanTen即大于10。  </p><p>在验证部分输入了两个数值17和7。为check函数输入17可以正常执行，输入7则会在执行到findGreaterThanTen时报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17 is odd.</span><br><span class="line">17 is greater than 10.</span><br><span class="line">7 is odd.</span><br><span class="line">scala.MatchError: 7 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$2.applyOrElse(MyFunc.scala:9)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$2.applyOrElse(MyFunc.scala:9)</span><br></pre></td></tr></table></figure></p><p>andThen方法并不是只在trait PartialFunction中定义了，而是继承自trait Function1并重写的。所以也可以使用andThen方法串联一个普通函数——只要输入类型匹配即可。看个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = (num: <span class="type">Int</span>) =&gt; <span class="string">s"<span class="subst">$num</span> hasn't been checked."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd andThen func</span><br><span class="line"></span><br><span class="line">println(check(<span class="number">17</span>))</span><br><span class="line">println(check(<span class="number">7</span>))</span><br></pre></td></tr></table></figure></p><p>执行后输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17 is odd.</span><br><span class="line">17 hasn&apos;t been checked.</span><br><span class="line">7 is odd.</span><br><span class="line">7 hasn&apos;t been checked.</span><br></pre></td></tr></table></figure></p><p>同样的andThen也可以组合case语句。不过懒得再写了， 有兴趣的话可以自己试试看。</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>compose方法也是trait PartialFunction继承自Function1的。PartialFunction甚至没有override这个方法。  </p><p>compose方法的作用的也是将两个偏函数串联在一起。不过compose串联的方向和andThen串联的方向相反。  </p><p>再用compose串联一下前面创建的findOdd和findGreaterThanTen两个偏函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findGreaterThanTen: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">10</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is greater than 10."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd compose findGreaterThanTen</span><br><span class="line"></span><br><span class="line">  println(check(<span class="number">17</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17 is greater than 10.</span><br><span class="line">17 is odd.</span><br><span class="line">17</span><br></pre></td></tr></table></figure></p><p>通过结果可以看出来使用compose组合后，先执行的是findGreaterThanTen函数。使用andThen组合时，先执行的则是findOdd函数。从trait Function1的定义中可以很清楚地看清这两个方法的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>](g: <span class="type">A</span> =&gt; <span class="type">T1</span>): <span class="type">A</span> =&gt; <span class="type">R</span> = &#123; x =&gt; apply(g(x)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">A</span>](g: <span class="type">R</span> =&gt; <span class="type">A</span>): <span class="type">T1</span> =&gt; <span class="type">A</span> = &#123; x =&gt; g(apply(x)) &#125;</span><br></pre></td></tr></table></figure></p><p>一个是apply(g(x))、一个是g(apply(x))，正好是相反的。</p><p>因为compose是在trait Function1实现的，所以它也可以用来组合普通函数。同样因为PartialFunction继承自Function1，所以compose也可以组合case语句。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单说下我对偏函数的理解：如果说普通函数是一个细粒度的操作，那么偏函数又对一个操作做了更细粒度的切分——将一个操作的不同分支切分了出来。   </p><p>示例中使用的几个函数都比较简单，所以使用组合方法组合显得有些意义不大。但是假想一个函数的业务比较复杂时，而又存在多个分支，如果这些分支的业务都写在一个函数内，那就不如使用偏函数恰当了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;scala的部分应用函数英文名为Partial Apply Function。此外，还有一个英文名为Partial Function的概念，
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>部分应用函数</title>
    <link href="http://scala.chobit.org/wiki/20180507/a19-partialApplyFunction/"/>
    <id>http://scala.chobit.org/wiki/20180507/a19-partialApplyFunction/</id>
    <published>2018-05-06T22:50:33.000Z</published>
    <updated>2018-05-08T23:01:33.288Z</updated>
    
    <content type="html"><![CDATA[<p>scala的部分应用函数（也可以成为偏应用函数），是一种特殊的表达式。使用部分应用函数让我们在调用一个方法时可以不必提供全部的参数，只需要提供部分参数，或者完全不提供参数。</p><p>先来看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialApplyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">    log(date, <span class="string">"message1"</span>)</span><br><span class="line">    log(date, <span class="string">"message2"</span>)</span><br><span class="line">    log(date, <span class="string">"message2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$date</span> : <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段代码中，连续调用了log方法三次，每次传入的参数中date是相同的，message是不同的。<br>要避免每次都输入这个相同的参数date可以考虑使用部分应用函数。部分应用函数要解决的问题就是：在一个比较小的作用域内连续调用一个已有方法或函数时，避免重复输入相同的参数。  </p><p>用部分应用函数重构下刚才的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialApplyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logWithDateBound = log(date, _: <span class="type">String</span>) <span class="comment">//需要提供的参数必须使用通配符，不可用参数名</span></span><br><span class="line"></span><br><span class="line">    logWithDateBound(<span class="string">"message1"</span>)</span><br><span class="line">    logWithDateBound(<span class="string">"message2"</span>)</span><br><span class="line">    logWithDateBound(<span class="string">"message2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$date</span> : <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重构后的代码中定义了一个logWithDateBound函数，并为这个函数绑定了第一个date参数，然后用下划线(_)替换缺失的参数列表。</p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mon May 07 07:29:05 CST 2018 : message1</span><br><span class="line">Mon May 07 07:29:05 CST 2018 : message2</span><br><span class="line">Mon May 07 07:29:05 CST 2018 : message2</span><br></pre></td></tr></table></figure></p><p>通过反编译后的代码查看下logWithBound的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function1 logWithDateBound = <span class="keyword">new</span> AbstractFunction1() &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date date$<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String x$<span class="number">1</span>)</span> </span>&#123; PartiallyFunc..MODULE$.log(<span class="keyword">this</span>.date$<span class="number">1</span>, x$<span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在反编译后的代码中看到logWithDateBound的类型是Function1，apply方法参数类型为String，可知logWithDateBound函数是一个类型为(String)=&gt;Unit函数值。</p><p>再来总结一次：部分应用函数是在已有函数的基础上，提供部分默认参数，未提供默认参数的地方使用“_”替代，从而创建出一个函数值，在使用这个函数值（部分应用函数）的时候，只需提供“_”部分对应的参数即可。</p><p>关于部分应用函数还可以多想想的一点就是与在函数或方法中指定参数默认值的区别。</p><p>部分应用函数的作用就体现在“部分”两个子上。定义部分应用函数时，提供全部参数或者是不提供任何参数都有画蛇添足的嫌疑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的部分应用函数（也可以成为偏应用函数），是一种特殊的表达式。使用部分应用函数让我们在调用一个方法时可以不必提供全部的参数，只需要提供部分参数，或者完全不提供参数。&lt;/p&gt;
&lt;p&gt;先来看一段代码：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala字符串插值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b012-stringInterpolation/"/>
    <id>http://scala.chobit.org/wiki/20180506/b012-stringInterpolation/</id>
    <published>2018-05-06T11:02:07.000Z</published>
    <updated>2018-05-06T23:11:10.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符中。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>在上例中， s”Hello,$name” 是待处理字符串字面，编译器会对它做额外的工作。待处理字符串字面通过“号前的字符来标示（例如：上例中是s）。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Scala 提供了三种创新的字符串插值方法：s,f 和 raw.</p><h3 id="s-字符串插值器"><a href="#s-字符串插值器" class="headerlink" title="s 字符串插值器"></a>s 字符串插值器</h3><p>在任何字符串前加上s，就可以直接在串中使用变量了。你已经见过这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>此例中，$name嵌套在一个将被s字符串插值器处理的字符串中。插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。  </p><p>字符串插值器也可以处理任意的表达式。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">s"1+1=<span class="subst">$&#123;1+1&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>将会输出字符串1+1=2。任何表达式都可以嵌入到${}中。</p><h3 id="f-插值器"><a href="#f-插值器" class="headerlink" title="f 插值器"></a>f 插值器</h3><p>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数。当使用 f 插值器的时候，所有的变量引用都应当后跟一个printf-style格式的字符串，如%d。看下面这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">f"<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall"</span>)<span class="comment">//James is 1.90 meters tall</span></span><br></pre></td></tr></table></figure></p><p>f 插值器是类型安全的。如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val height:Double=1.9d</span><br><span class="line"></span><br><span class="line">scala&gt;f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">&lt;console&gt;:9: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found : Double</span><br><span class="line"> required: Int</span><br><span class="line">           f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">              ^ f</span><br></pre></td></tr></table></figure><p>插值器利用了java中的字符串数据格式。这种以%开头的格式在 [Formatter javadoc] 中有相关概述。如果在具体变量后没有%，则格式化程序默认使用 %s（串型）格式。</p><h3 id="raw-插值器"><a href="#raw-插值器" class="headerlink" title="raw 插值器"></a>raw 插值器</h3><p>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的。如下是个被处理过的字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;s<span class="string">"a\nb"</span></span><br><span class="line">res0:String=</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><p>这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;raw<span class="string">"a\nb"</span></span><br><span class="line">res1:String=a\nb</span><br></pre></td></tr></table></figure></p><p>当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。  </p><p>除了以上三种字符串插值器外，使用者可以自定义插值器。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>在Scala中，所有处理过的字符串字面值都进行了简单编码转换。任何时候编译器遇到一个如下形式的字符串字面值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">id"string content"</span></span><br></pre></td></tr></table></figure></p><p>它都会被转换成一个StringContext实例的call(id)方法。这个方法在隐式范围内仍可用。只需要简单得建立一个隐类，给StringContext实例增加一个新方法，便可以定义我们自己的字符串插值器。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：为了避免运行时实例化，我们从AnyVal中继承。</span></span><br><span class="line"><span class="comment">//更多信息请见值类的说明</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=sys.error(<span class="string">"TODO-IMPLEMENT"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveMeSomeJson</span></span>(x:<span class="type">JSONObject</span>):<span class="type">Unit</span>=...</span><br><span class="line"></span><br><span class="line">giveMeSomeJson(<span class="string">json"&#123;name:<span class="subst">$name</span>,id:<span class="subst">$id</span>&#125;"</span>)</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们试图通过字符串插值生成一个JSON文本语法。隐类JsonHelper作用域内使用该语法，且这个JSON方法需要一个完整的实现。只不过，字符串字面值格式化的结果不是一个字符串，而是一个JSON对象。<br>当编译器遇到“{name:\$name, id:\$id”}”，它将会被重写成如下表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>).json(name,id)</span><br></pre></td></tr></table></figure></p><p>隐类则被重写成如下形式<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">JsonHelper</span>(<span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>)).json(name,id)</span><br></pre></td></tr></table></figure></p><p>所以，JSON方法可以访问字符串的原生片段而每个表达式都是一个值。这个方法的一个简单但又令人迷惑的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=&#123;</span><br><span class="line">    <span class="keyword">val</span> strings=sc.parts.iterator</span><br><span class="line">    <span class="keyword">val</span> expressions=args.iterator</span><br><span class="line">    <span class="keyword">var</span> buf=<span class="keyword">new</span> <span class="type">StringBuffer</span>(strings.next)</span><br><span class="line">    <span class="keyword">while</span>(strings.hasNext)&#123;</span><br><span class="line">      buf append expressions.next</span><br><span class="line">      buf append strings.next</span><br><span class="line">    &#125;</span><br><span class="line">    parseJson(buf)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被处理过的字符串的每部分都是StringContext的成员。每个表达式的值都将传入到JSON方法的args参数。JSON方法接受这些值并合成一个大字符串，然后再解析成JSON格式。有一种更复杂的实现可以避免合成字符串的操作，它只是简单的直接通过原生字符串和表达式值构建JSON。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>字符串插值目前对模式匹配语句不适用。此特性将在2.11版本中生效。</p><p>本文转载自：<a href="https://docs.scala-lang.org/zh-cn/overviews/core/string-interpolation.html" rel="external nofollow noopener noreferrer" target="_blank">字符串插值</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>带名称的参数值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b011-namedParam/"/>
    <id>http://scala.chobit.org/wiki/20180506/b011-namedParam/</id>
    <published>2018-05-06T11:00:40.000Z</published>
    <updated>2018-05-06T11:14:06.543Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一段代码，看看执行后会输出什么：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">showValue</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"x is <span class="subst">$x</span>"</span>)</span><br><span class="line">    println(<span class="string">s"y is <span class="subst">$y</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  showValue(y = <span class="number">3</span>, x = <span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码看了以后第一反应是会报错。我将最后一行“showValue(y = 3, x = 6)”中的“y=3”和“x=3”看做简单赋值语句了。scala中赋值语句返回值为Unit，所以执行代码会报类型不匹配的错误。</p><p>然而我错了。  </p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x is 6</span><br><span class="line">y is 3</span><br></pre></td></tr></table></figure></p><p>最后一行代码中的“y=3”和“x=3”的确是赋值语句，更准确的说法是根据参数名称显式赋值。传递给方法的值就是赋给参数的值，而非Unit。  </p><p>一般情况下调用方法或函数，就按照函数定义时的参数顺序一个个传递。但是也可以通过指定参数名赋值，并且不需要按照定义时的顺序向函数传递参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看一段代码，看看执行后会输出什么：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数默认值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b010-defaultParamValue/"/>
    <id>http://scala.chobit.org/wiki/20180506/b010-defaultParamValue/</id>
    <published>2018-05-06T10:45:01.000Z</published>
    <updated>2018-05-06T10:56:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>Scala可以为方法参数指定默认值。<br>使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。</p><p>举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no</span></span>(no: <span class="type">Int</span> = <span class="number">1</span>) = no</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Default No. is "</span> + no())</span><br><span class="line"></span><br><span class="line">println(<span class="string">"This No. is "</span> + no(<span class="number">9</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Default No. is 1</span><br><span class="line">This No. is 9</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala可以为方法参数指定默认值。&lt;br&gt;使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数中的 =&gt;U 和 ()=&gt;U</title>
    <link href="http://scala.chobit.org/wiki/20180506/b009-callByNameAndFunctionValue/"/>
    <id>http://scala.chobit.org/wiki/20180506/b009-callByNameAndFunctionValue/</id>
    <published>2018-05-06T10:06:30.000Z</published>
    <updated>2018-05-06T11:23:54.888Z</updated>
    
    <content type="html"><![CDATA[<p>在scala参数中会遇到=&gt;U 或者 ()=&gt;U。U表示返回值类型。简单说下二者的区别。  </p><p>=&gt;U是一个传名参数，表示一个无参方法。  </p><p>()=&gt;U则是一个函数。</p><p>举个例子，看一下二者的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mTime</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> fTime = ()=&gt;<span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t1: =&gt; <span class="type">Long</span>, t2: ()=&gt;<span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t1</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$&#123;t2()&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(mTime, fTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于方法和函数的关系可以参考<a href="/wiki/20180501/a15-methodVsFunction/">之前的一篇文</a>。  </p><p>还有篇关于传名参数的文：<a href="/wiki/20180506/a18-callByName/">传名参数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala参数中会遇到=&amp;gt;U 或者 ()=&amp;gt;U。U表示返回值类型。简单说下二者的区别。  &lt;/p&gt;
&lt;p&gt;=&amp;gt;U是一个传名参数，表示一个无参方法。  &lt;/p&gt;
&lt;p&gt;()=&amp;gt;U则是一个函数。&lt;/p&gt;
&lt;p&gt;举个例子，看一下二者的区别：&lt;br&gt;&lt;fi
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>传名参数 =&gt;Unit</title>
    <link href="http://scala.chobit.org/wiki/20180506/a18-callByName/"/>
    <id>http://scala.chobit.org/wiki/20180506/a18-callByName/</id>
    <published>2018-05-05T23:09:35.000Z</published>
    <updated>2018-05-06T10:59:30.758Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的解释器在解析函数参数(function arguments)时有两种方式：</p><ul><li>传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；</li><li>传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部。</li></ul><p>以上是比较严谨的说法。简单解释下，传值调用就是我们常见的方法调用方式，将一个值作为参数传递给方法或函数。java中的方法都是传值调用。传名调用，则是将一个方法作为参数传递给其他方法或函数。</p><p>传名调用的参数是方法而非函数，且要求作为参数的方法的参数为空。</p><p>来看一个传名参数的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">time</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t: =&gt; <span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$t</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结下传名参数的优势：</p><ul><li>进行实时运算；</li><li>如果没有被用到，就可以不必进行运算。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala的解释器在解析函数参数(function arguments)时有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；&lt;/li&gt;
&lt;li&gt;传名调用（call-by-name）：将未计算的参数表达式直
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
