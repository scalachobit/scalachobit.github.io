<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCALA 手账</title>
  
  <subtitle>scala</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scala.chobit.org/"/>
  <updated>2018-05-25T14:43:59.996Z</updated>
  <id>http://scala.chobit.org/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>闭包</title>
    <link href="http://scala.chobit.org/wiki/20180521/a23-closure/"/>
    <id>http://scala.chobit.org/wiki/20180521/a23-closure/</id>
    <published>2018-05-21T14:36:43.000Z</published>
    <updated>2018-05-25T14:43:59.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于闭包的概念，我手边scala的书如是说：</p><blockquote><p>闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。  </p></blockquote><p>在维基百科中的说法是：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p></blockquote><p>这两种说法前者说闭包是一个函数，后者说闭包是函数和自由变量一同构成的实体。我个人是比较倾向于后者的。不过细细思考下来，二者也没什么差别，都描述了闭包的几个特征：</p><ol><li>闭包中有一个特殊的<strong>函数</strong>；</li><li>存在一个<strong>封闭</strong>的作用域，函数就在这个封闭的作用域中；</li><li>在封闭作用域中存在一个函数作用域之外的变量（即<strong>自由变量</strong>）；</li><li>闭包函数<strong>绑定</strong>了这个自由变量。</li></ol><p>来看个关于闭包的程序：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line">println(func(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个方法foo()，方法foo中有一个局部变量i。正常情况下只有在执行foo方法的时候，局部变量i才会存在；foo方法执行完成后，局部变量i就会消失，不再有意义。不过现在在foo方法中定义了一个内部方法bar()，在bar方法中引用了foo方法的局部变量i，最后是将bar转为函数值作为foo方法的返回值。</p><p>这段代码中的bar函数绑定了它的作用域之外的变量i。按照前文的说明：bar函数和变量i共同构成了一个闭包。</p><p>现在想一下：<strong>调用foo方法返回的bar函数时，foo的局部变量i是否有效？</strong> 显然的，根据维基百科的解释，虽然foo方法已经执行结束，但是局部变量i仍然和函数bar一同存在，调用bar函数，i仍然有效。</p><p>执行这段代码看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(): Int =&gt; Int = &#123;</span><br><span class="line">     |     val i = 1</span><br><span class="line">     |</span><br><span class="line">     |     def bar(num: Int) = &#123;</span><br><span class="line">     |       i + num</span><br><span class="line">     |     &#125;</span><br><span class="line">     |</span><br><span class="line">     |     bar</span><br><span class="line">     |   &#125;</span><br><span class="line">foo: ()Int =&gt; Int</span><br><span class="line"></span><br><span class="line">scala&gt;  val func = foo()</span><br><span class="line">func: Int =&gt; Int = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; println(func(2))</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>代码的执行结果和前面的推论是一致的。</p><p>根据这段代码我们可以看到闭包的“闭”封闭的是函数的外部作用域。在这个例子中，封闭的就是bar函数外的foo方法的作用域。整个闭包只有一个对外的通道，即bar函数，我们可以通过bar函数来访问封闭的作用域的内容。  </p><p>再来说明下闭包定义中的<strong>绑定</strong>两个字。闭包中的绑定并不是获得闭包绑定自由变量的一份副本，而是直接绑定到变量本身。在闭包中对自由变量的调整会影响到闭包外部的自由变量；同样的，外部自由变量的变化，闭包也会受到影响。下面这个例子应该可以说明这一点：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(): () =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = foo()</span><br><span class="line"></span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br><span class="line">println(func())</span><br></pre></td></tr></table></figure><p>在代码中定义了一个闭包。闭包中的自由变量是i，在函数bar中对自由变量i做了调整。在闭包外，三次调用了闭包函数。这段代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">对比输出结果我们可以看到：每次调用闭包函数bar都会对自由变量i产生影响；而自由变量i的变化，又会在下一次执行bar函数的时候发挥作用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 思考 - 对象和闭包</span><br><span class="line"></span><br><span class="line">看完了闭包的示例代码后，回过头来再思考一下闭包的概念：  </span><br><span class="line"></span><br><span class="line">&gt; 闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用域或上下文中定义的变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那根据这个概念，下面这段代码是不是闭包：</span><br><span class="line">```scala</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">  private val i = 1</span><br><span class="line"></span><br><span class="line">  def bar(num: Int): Int = &#123;</span><br><span class="line">    i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了，还是直接看这段代码吧：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.i + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">A</span>().bar(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里定义了一个类A，类A有一个私有变量i，这个变量i只能通过bar方法访问，换言之bar方法也是引用了一个它的作用域之外的变量i。那么class A这个结构应该也算是闭包喽！？</p><p>但是这里的bar方法需要通过类A的对象来调用，它本质上是类A的一个实例成员，而非是一个独立的函数；另外这里的bar方法引用的变量i是绑定在类A的对象上，而非绑定在bar方法上，所以从根本上这种形式就不满足闭包的定义，所以不是闭包！？</p><p>对于这样定义的类是否是闭包，以上是两种观点，也是我纠结之处。也查了些资料，然而各种说法莫衷一是。思考了一段时间后决定停止这种纠结，仅从一点出发：<strong>只在函数作为头等公民的语境中来讨论闭包</strong>。</p><p>对象和函数各有自己不同的使用场景。在scala这种既支持函数又面向对象的语言中，使用对象可以减少一些复杂度，使用函数可以提升一些灵活性。但是把函数的概念放到面向对象的语境中，或者反过来都是没有意义的事情。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前想到的关于的闭包的用法主要有两种：一种是将函数作为闭包的返回值，就如前面的例子；另一种是将函数作为参数，如下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(op:(<span class="type">Int</span>, <span class="type">Int</span>)=&gt;<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sum = (a:<span class="type">Int</span>, b:<span class="type">Int</span>)=&gt; a + b</span><br><span class="line"></span><br><span class="line">foo(sum)</span><br></pre></td></tr></table></figure></p><p>又想到了一个应用场景，比如在一些对于面向对象支持不是很好的语言，可以用闭包来构建对象（用scala来举这个例子，有些费力，懒得写了）。严格来说，这种用法也是将函数用作闭包的返回值。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在知乎上有各路大神对闭包进行了讨论，有兴趣可以看一下：<a href="https://www.zhihu.com/question/34210214" rel="external nofollow noopener noreferrer" target="_blank">什么是闭包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;关于闭包的概念，我手边scala的书如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是一种特殊的函数值，闭包中封闭或绑定了在另一个作用
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://scala.chobit.org/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Executor Aroud模式</title>
    <link href="http://scala.chobit.org/wiki/20180520/a22-executorAroudMode/"/>
    <id>http://scala.chobit.org/wiki/20180520/a22-executorAroudMode/</id>
    <published>2018-05-19T23:15:02.000Z</published>
    <updated>2018-05-19T23:35:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。</p><p>在scala里可以用函数值实现这种模式。下面是一个示例，使用Resource类演示了事务的开启和释放：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"Starting transaction..."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">cleanUp</span></span>() &#123;</span><br><span class="line">    println(<span class="string">"Ending transaction..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op1</span> </span>= println(<span class="string">"Operation 1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op2</span> </span>= println(<span class="string">"Operation 2"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op3</span> </span>= println(<span class="string">"Operation 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(codeBlock: <span class="type">Resource</span> =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = <span class="keyword">new</span> <span class="type">Resource</span> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codeBlock(resource)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resource.cleanUp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里将Resource类的构造器标记为private，这样就只能在Resource类内部和它的伴生类中创建实例。因为只能在这两个地方创建实例，就可以保证按照确定的方式使用这个类的对象，即可以保证其行为是按照确定的方式执行。cleanUp()方法也被标记为private，确保不会被意外调用。Resource类第一行的print语句是具体事务操作的占位符。调用构造函数时，事务启动；调用cleanUp()函数时，事务终结。此外Resource类中还准备了一些实例方法，如op1()、op2()等。</p><p>在伴生对象里有一个默认public的方法use，它接收一个函数值作为参数。use()方法创建了一个Resource的实例，在try和finally块的保护之下，把这个实例传给了给定的函数值。在finally块里，调用了Resource私有实例方法cleanUp()。</p><p>看一下是如何使用Resource类的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span>.use &#123; resource =&gt;</span><br><span class="line">  resource.op1</span><br><span class="line">  resource.op2</span><br><span class="line">  resource.op3</span><br><span class="line">  resource.op1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting transaction...</span><br><span class="line">Operation 1</span><br><span class="line">Operation 2</span><br><span class="line">Operation 3</span><br><span class="line">Operation 1</span><br><span class="line">Ending transaction...</span><br></pre></td></tr></table></figure><p>调用Resource的伴生对象的use方法时，会自动创建一个Resource实例，等到传递的函数值执行结束后，会自动调用cleanUp方法释放占用的资源。</p><p>上面模式的一个变体是Loan（借贷）模式。如果想确保非内存资源得到确定性释放，就可以使用这个模式。可以这样认为：这种资源密集型的对象是借给你的，用过之后应该立即归还。</p><p>下面是一个Loan模式的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeToFile</span></span>(fileName: <span class="type">String</span>)(codeBlock: <span class="type">PrintWriter</span> =&gt; <span class="type">Unit</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(fileName))</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    codeBlock(writer)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调用writeToFile()将一些内容写入文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeToFile(<span class="string">"output.txt"</span>) &#123; writer =&gt; writer write <span class="string">"hello from Scala"</span> &#125;</span><br></pre></td></tr></table></figure><p>这行这段代码会创建一个名为output.txt的文件，并在文件中写入一行文字“hello from Scala”。</p><p>作为writeToFile()方法的使用者，我们不必操心文件的关闭。在代码块里，这个文件是借给我们用的。我们可以用得到的PrintWriter实例进行写操作，一旦从这个块返回，方法就会自动关闭文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们访问资源需要关注对资源的锁定、对资源的申请和释放，还要考虑可能遇到的各种异常。这些事项本身与代码的逻辑操作无关，但我们不能遗漏。也就是说需要在进入方法时获取资源，退出方法时释放资源。这种处理就进入了Execute Around模式的范畴。&lt;/p&gt;
&lt;p&gt;在scala里可
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线和参数</title>
    <link href="http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/"/>
    <id>http://scala.chobit.org/wiki/20180519/b013-underscoreAndParams/</id>
    <published>2018-05-19T14:01:50.000Z</published>
    <updated>2018-05-19T14:11:57.033Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123; (sum, elem) =&gt; sum + elem &#125;)</span><br></pre></td></tr></table></figure><p>上面的代码里使用了“/:”方法。这个方法的意思大致上是从数组的左侧开始迭代运算。这里是用来计算数组中所有元素的和。因为在函数值中sum和elem只用了一次，所以这个函数也可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(<span class="string">"Sum of all values in array is "</span> + (<span class="number">0</span> /: arr) &#123;_+_&#125; )</span><br></pre></td></tr></table></figure><p>其中第一个“<em>”就是sum，即用来迭代运算的值；第二个“</em>”表示的是数组中的元素。这里是一处让人比较纠结的地方，这样做会让代码过于简洁，有时甚至让人费解。如果能在不失可读性又足够简洁的地方使用就最好了，来看一下下面的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> negativeNumberExists = arr.exists &#123; _ &lt; <span class="number">0</span> &#125;</span><br><span class="line">println(<span class="string">"Array has negative number? "</span> + negativeNumberExists)</span><br></pre></td></tr></table></figure></p><p>这里的代码用来查找数组中是否有小于0的元素。</p><p>在某些有意义的地方，这种简洁还可以更进一步。比如说我们想从一个数组中找出最大值。从这个需求出发，我们会一步步地简化实现的函数。最开始是这个样子的，我们使用了“/:”方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    a</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; (large, ele) =&gt; max(large, ele) &#125;)</span><br></pre></td></tr></table></figure><p>用下划线表示函数值参数来做一次简化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max(_, _) &#125;)</span><br></pre></td></tr></table></figure><p>“_”不仅可以表示一个参数，还可以表示整个参数列表。所以可以继续简化成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max _ &#125;)</span><br></pre></td></tr></table></figure><p>在上面的代码里，“_”表示整个参数列表。如果只是把参数传递给下层的方法，甚至可以省下使用“_”。上面的代码可以最终简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Max value in array is "</span> + (<span class="type">Int</span>.<span class="type">MinValue</span> /: arr) &#123; max &#125;)</span><br></pre></td></tr></table></figure><p>可以看到，依赖类型推断，scala的简洁到了丧心病狂（无贬义）的程度。这也给开发者留下了一个难题：需要适当克制自己简化代码的欲望，留下适当的可读性，不让代码变成天书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Scala里，下划线（_）可以表示函数值的参数。如果某个参数在函数里仅使用一次，就可以用下划线表示。每次在函数里用下划线，都表示随后的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="下划线" scheme="http://scala.chobit.org/tags/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Curry化</title>
    <link href="http://scala.chobit.org/wiki/20180518/a21-currying/"/>
    <id>http://scala.chobit.org/wiki/20180518/a21-currying/</id>
    <published>2018-05-17T23:11:16.000Z</published>
    <updated>2018-05-19T14:29:14.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。</p><p>scala里的curry化可以把函数从接收多个参数转换成接收多个参数列表。也就是说我们写的多参数函数不再只是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>) &#123;???&#125;</span><br></pre></td></tr></table></figure></p><p>而是可以这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>或者这样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>甚至是这样子的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125;&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>来看个实例好了，下面的代码中定义了一个inject方法。inject方法有三个参数，两个Int型的参数，一个函数值参数。方法体中通过传入的函数对前两个Int型参数进行运算：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>, (a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure></p><p>在代码的最后一行还写了调用inject方法的一个示例。</p><p>有的时候可能会觉得把普通参数和函数值参数放在一起有点儿怪怪的。现在用curry化的方法将函数值参数独立开来：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>)(op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inject(<span class="number">2</span>, <span class="number">3</span>) &#123; (a, b) =&gt; a + b &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到不管是在定义方式还是在使用方式上，代码都清爽了许多。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从方法的角度来看，Curry化只是一个语法糖，对方法的功能没有任何影响。    </p><p>将方法转为函数使用时，Curry化的影响就出现了。在scala解释器里看一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def inject(a: Int, b: Int, op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int, op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br></pre></td></tr></table></figure></p><p>我们在解释器里def了没有做Curry化的inject方法，并用“_”将inject方法转为函数。此时inject方法转成的函数是一个有三个参数的普通函数。  </p><p>再来看看Curry化后的inject方法转成的函数是怎样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;   def inject(a: Int, b: Int)(op: (Int, Int) =&gt; Int): Int = &#123;</span><br><span class="line">     |     op(a, b)</span><br><span class="line">     |   &#125;</span><br><span class="line">inject: (a: Int, b: Int)(op: (Int, Int) =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; inject _</span><br><span class="line">res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>将两次生成的函数值对象res0和res1放在一起比较一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curry化之前： res0: (Int, Int, (Int, Int) =&gt; Int) =&gt; Int = &lt;function3&gt;</span><br><span class="line">Curry化之后： res1: (Int, Int) =&gt; ((Int, Int) =&gt; Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>inject方法Curry化之前转成的函数res0是一个三参数函数，继承自trait Function3；Curry化之后转成的函数res1是一个双参数函数，继承自trait Function2。  </p><p>用ABC来表示下inject方法的参数也许更直观些。inject方法最初为：inject(A, B, C)； curry化以后的结构是为：inject(A, B)(C)。inject方法curry化以后对应的函数res1为：</p><blockquote><p>(A, B)=&gt; (C)=&gt; Int</p></blockquote><p>可以看到res1实质上是被分解多个函数，inject方法的每个参数列表都对应一个函数，几个函数按参数列表顺序从右到左逐层嵌套，最左侧的参数列表即为最外侧的函数的参数。  </p><p>以上的内容说的是对方法进行Curry化。Scala也支持对函数进行Curry化。scala的多参数函数trait，包括Function2 ~ FuntionN都有一个curried方法，用来将函数的每个参数进行curry化。下面的代码是Function3的curried方法的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curried</span></span>: <span class="type">T1</span> =&gt; <span class="type">T2</span> =&gt; <span class="type">T3</span> =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">  (x1: <span class="type">T1</span>) =&gt; (x2: <span class="type">T2</span>) =&gt; (x3: <span class="type">T3</span>) =&gt; apply(x1, x2, x3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在curried方法中，Function3的每个参数都被拆分成一个独立的参数列表，每个参数列表对应的函数逐层嵌套形成了新的函数。</p><p>调用下前面的函数res1的curried方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res1.curried</span><br><span class="line">res2: Int =&gt; (Int =&gt; (((Int, Int) =&gt; Int) =&gt; Int)) = &lt;function1&gt;</span><br></pre></td></tr></table></figure></p><p>res1调用curried方法后生成的新函数res2类型为Function1，并且函数体又多了一层嵌套。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Curry化的本质是将多参数函数转为多个单参数函数的级联，以便于进行lambda运算——这是官方的说法。  </p><p>说下自己的理解：Curry化更多的情况下是一种语法糖而已，和部分应用函数一样，在scala中并不是一种支撑性的角色。我们可以将多个单参数函数组合在一起，也可以使用函数递归来解决一些特定的问题，但是不必要将这种用法称为curry化。当然，这只是我的一偏之见。如有不同意见，欢迎一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Curry化也称柯里化。以Haskell发明人 Haskell Curry 命名。&lt;/p&gt;
&lt;p&gt;scala里的curry化可以把函数从接收
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="柯里化,Curry化" scheme="http://scala.chobit.org/tags/%E6%9F%AF%E9%87%8C%E5%8C%96-Curry%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180516/c01-particialFuncion/"/>
    <id>http://scala.chobit.org/wiki/20180516/c01-particialFuncion/</id>
    <published>2018-05-15T23:01:16.000Z</published>
    <updated>2018-05-15T23:12:52.038Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><p>至于为什么会抛出这个异常，因为scala的语言太过简洁，有必要看一下对这个类的字节码文件反编译后的结果，其中主要是看一下偏函数find的实现。使用scalac完成编译后，可以看到生成了三个字节码文件：</p><blockquote><p>MyFunc$$anonfun$1.class<br>MyFunc$.class<br>MyFunc.class</p></blockquote><p>使用jd-gui打开MyFunc$.class可以看到find的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.find = <span class="keyword">new</span> AbstractPartialFunction.mcLI.sp() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;A1, B1&gt; <span class="function">B1 <span class="title">applyOrElse</span><span class="params">(A1 x1, Function1&lt;A1, B1&gt; <span class="keyword">default</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        Object localObject;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) localObject = <span class="string">"It's Target."</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            localObject = <span class="keyword">default</span>.apply(BoxesRunTime.boxToInteger(x1));</span><br><span class="line">        <span class="keyword">return</span> localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDefinedAt</span><span class="params">(<span class="keyword">int</span> x1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x1;</span><br><span class="line">        <span class="keyword">boolean</span> bool;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) bool = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/yuanguangyu1221/article/details/71307664" rel="external nofollow noopener noreferrer" target="_blank">偏函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/20832218?refer=insight" rel="external nofollow noopener noreferrer" target="_blank">scala中的Partial Function</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是一个偏函数的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
      <category term="scala探索" scheme="http://scala.chobit.org/categories/scala%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="http://scala.chobit.org/wiki/20180508/a20-partialFunction/"/>
    <id>http://scala.chobit.org/wiki/20180508/a20-partialFunction/</id>
    <published>2018-05-07T22:46:47.000Z</published>
    <updated>2018-05-17T15:14:18.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>scala的部分应用函数英文名为Partial Apply Function。此外，还有一个英文名为Partial Function的概念，即偏函数。</p><p>普通的函数会处理输入参数的全量的值，而偏函数只会处理输入参数中部分特定的值。  </p><p>偏函数在实现上有如下特征：  </p><ul><li>需要显示声明类型，类型为PartialFunction[-A, +B]，其中A为输入类型，B为输出类型；</li><li>输入参数只有一个，且输入类型已在PartialFunction的类型声明中指出，所以在声明偏函数的时候不需要像声明普通函数一样指明参数列表；</li><li>通常由包围在花括号中的一个或多个case语句构成，且花括号不可省略。</li></ul><p>下面是一个偏函数的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> find: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">5</span> =&gt; <span class="string">"It's Target."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(find(<span class="number">6</span>))</span><br><span class="line">    println(find(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个偏函数find，这个函数只处理大于5的值。执行代码find(6)可以正常处理，执行find(3)会报scala.MatchError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Target.</span><br><span class="line">Exception in thread &quot;main&quot; scala.MatchError: 3 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$1.applyOrElse(MyFunc.scala:5)</span><br></pre></td></tr></table></figure><h2 id="组合运算"><a href="#组合运算" class="headerlink" title="组合运算"></a>组合运算</h2><p>scala提供了几个组合方法可以将两个偏函数组合在一起使用。常用的组合方法有：orElse、andThen和compose，现在分别看一下。</p><h3 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h3><p>orElse方法是在trait PartialFunction中定义的方法。使用orElse方法，可以在无法匹配一个偏函数的时候继续尝试匹配下一个。下面是一个使用orElse组合偏函数判断奇偶的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is odd."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findEven: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> check = findEven orElse findOdd</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(check(<span class="number">9</span>))</span><br><span class="line">    print(check(<span class="number">10</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个偏函数使用orElse方法组合后形成一个新的偏函数，并赋值给变量check。</p><p>代码中的check函数的作用等同于如下的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">  num <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>) =&gt; <span class="string">s"<span class="subst">$num</span> is odd."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序的执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 is odd.</span><br><span class="line">10 is even.</span><br></pre></td></tr></table></figure></p><p>使用orElse方法还可以直接组合case语句：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd orElse &#123;</span><br><span class="line">  <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="string">s"<span class="subst">$num</span> is even."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的case语句被scala直接包装为偏函数来处理了。</p><h3 id="andThen"><a href="#andThen" class="headerlink" title="andThen"></a>andThen</h3><p>如果说orElse方法是将两个偏函数并联在一起，那么andThen方法就是将两个偏函数串联在了一起。经过andThen串联后，上一个函数的输出内容即是下一个函数的输入内容。最初的输入参数必须能够匹配所有被andThen串联在一起的偏函数，否则就会报scala.MatchError错误。</p><p>来看一个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findGreaterThanTen: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">10</span> =&gt; <span class="string">s"<span class="subst">$num</span> is greater than 10."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd andThen findGreaterThanTen</span><br><span class="line"></span><br><span class="line">  println(check(<span class="number">17</span>))</span><br><span class="line">  println(check(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中的两个偏函数被andThen方法串联起来构成了check函数，check函数要求输入的整型数值满足findOdd即为奇数，且满足findGreaterThanTen即大于10。  </p><p>在验证部分输入了两个数值17和7。为check函数输入17可以正常执行，输入7则会在执行到findGreaterThanTen时报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17 is odd.</span><br><span class="line">17 is greater than 10.</span><br><span class="line">7 is odd.</span><br><span class="line">scala.MatchError: 7 (of class java.lang.Integer)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:248)</span><br><span class="line">at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:246)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$2.applyOrElse(MyFunc.scala:9)</span><br><span class="line">at com.zhyea.MyFunc$$anonfun$2.applyOrElse(MyFunc.scala:9)</span><br></pre></td></tr></table></figure></p><p>andThen方法并不是只在trait PartialFunction中定义了，而是继承自trait Function1并重写的。所以也可以使用andThen方法串联一个普通函数——只要输入类型匹配即可。看个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func = (num: <span class="type">Int</span>) =&gt; <span class="string">s"<span class="subst">$num</span> hasn't been checked."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd andThen func</span><br><span class="line"></span><br><span class="line">println(check(<span class="number">17</span>))</span><br><span class="line">println(check(<span class="number">7</span>))</span><br></pre></td></tr></table></figure></p><p>执行后输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17 is odd.</span><br><span class="line">17 hasn&apos;t been checked.</span><br><span class="line">7 is odd.</span><br><span class="line">7 hasn&apos;t been checked.</span><br></pre></td></tr></table></figure></p><p>同样的andThen也可以组合case语句。不过懒得再写了， 有兴趣的话可以自己试试看。</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>compose方法也是trait PartialFunction继承自Function1的。PartialFunction甚至没有override这个方法。  </p><p>compose方法的作用的也是将两个偏函数串联在一起。不过compose串联的方向和andThen串联的方向相反。  </p><p>再用compose串联一下前面创建的findOdd和findGreaterThanTen两个偏函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunc</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findOdd: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is odd."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> findGreaterThanTen: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> num <span class="keyword">if</span> num &gt; <span class="number">10</span> =&gt; println(<span class="string">s"<span class="subst">$num</span> is greater than 10."</span>); num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span> </span>= findOdd compose findGreaterThanTen</span><br><span class="line"></span><br><span class="line">  println(check(<span class="number">17</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17 is greater than 10.</span><br><span class="line">17 is odd.</span><br><span class="line">17</span><br></pre></td></tr></table></figure></p><p>通过结果可以看出来使用compose组合后，先执行的是findGreaterThanTen函数。使用andThen组合时，先执行的则是findOdd函数。从trait Function1的定义中可以很清楚地看清这两个方法的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>](g: <span class="type">A</span> =&gt; <span class="type">T1</span>): <span class="type">A</span> =&gt; <span class="type">R</span> = &#123; x =&gt; apply(g(x)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">A</span>](g: <span class="type">R</span> =&gt; <span class="type">A</span>): <span class="type">T1</span> =&gt; <span class="type">A</span> = &#123; x =&gt; g(apply(x)) &#125;</span><br></pre></td></tr></table></figure></p><p>一个是apply(g(x))、一个是g(apply(x))，正好是相反的。</p><p>因为compose是在trait Function1实现的，所以它也可以用来组合普通函数。同样因为PartialFunction继承自Function1，所以compose也可以组合case语句。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单说下我对偏函数的理解：如果说普通函数是一个细粒度的操作，那么偏函数又对一个操作做了更细粒度的切分——将一个操作的不同分支切分了出来。   </p><p>示例中使用的几个函数都比较简单，所以使用组合方法组合显得有些意义不大。但是假想一个函数的业务比较复杂时，而又存在多个分支，如果这些分支的业务都写在一个函数内，那就不如使用偏函数恰当了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;scala的部分应用函数英文名为Partial Apply Function。此外，还有一个英文名为Partial Function的概念，
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="偏函数" scheme="http://scala.chobit.org/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>部分应用函数</title>
    <link href="http://scala.chobit.org/wiki/20180507/a19-partialApplyFunction/"/>
    <id>http://scala.chobit.org/wiki/20180507/a19-partialApplyFunction/</id>
    <published>2018-05-06T22:50:33.000Z</published>
    <updated>2018-05-08T23:01:33.288Z</updated>
    
    <content type="html"><![CDATA[<p>scala的部分应用函数（也可以成为偏应用函数），是一种特殊的表达式。使用部分应用函数让我们在调用一个方法时可以不必提供全部的参数，只需要提供部分参数，或者完全不提供参数。</p><p>先来看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialApplyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">    log(date, <span class="string">"message1"</span>)</span><br><span class="line">    log(date, <span class="string">"message2"</span>)</span><br><span class="line">    log(date, <span class="string">"message2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$date</span> : <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段代码中，连续调用了log方法三次，每次传入的参数中date是相同的，message是不同的。<br>要避免每次都输入这个相同的参数date可以考虑使用部分应用函数。部分应用函数要解决的问题就是：在一个比较小的作用域内连续调用一个已有方法或函数时，避免重复输入相同的参数。  </p><p>用部分应用函数重构下刚才的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialApplyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logWithDateBound = log(date, _: <span class="type">String</span>) <span class="comment">//需要提供的参数必须使用通配符，不可用参数名</span></span><br><span class="line"></span><br><span class="line">    logWithDateBound(<span class="string">"message1"</span>)</span><br><span class="line">    logWithDateBound(<span class="string">"message2"</span>)</span><br><span class="line">    logWithDateBound(<span class="string">"message2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$date</span> : <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重构后的代码中定义了一个logWithDateBound函数，并为这个函数绑定了第一个date参数，然后用下划线(_)替换缺失的参数列表。</p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mon May 07 07:29:05 CST 2018 : message1</span><br><span class="line">Mon May 07 07:29:05 CST 2018 : message2</span><br><span class="line">Mon May 07 07:29:05 CST 2018 : message2</span><br></pre></td></tr></table></figure></p><p>通过反编译后的代码查看下logWithBound的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function1 logWithDateBound = <span class="keyword">new</span> AbstractFunction1() &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date date$<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String x$<span class="number">1</span>)</span> </span>&#123; PartiallyFunc..MODULE$.log(<span class="keyword">this</span>.date$<span class="number">1</span>, x$<span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在反编译后的代码中看到logWithDateBound的类型是Function1，apply方法参数类型为String，可知logWithDateBound函数是一个类型为(String)=&gt;Unit函数值。</p><p>再来总结一次：部分应用函数是在已有函数的基础上，提供部分默认参数，未提供默认参数的地方使用“_”替代，从而创建出一个函数值，在使用这个函数值（部分应用函数）的时候，只需提供“_”部分对应的参数即可。</p><p>关于部分应用函数还可以多想想的一点就是与在函数或方法中指定参数默认值的区别。</p><p>部分应用函数的作用就体现在“部分”两个子上。定义部分应用函数时，提供全部参数或者是不提供任何参数都有画蛇添足的嫌疑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的部分应用函数（也可以成为偏应用函数），是一种特殊的表达式。使用部分应用函数让我们在调用一个方法时可以不必提供全部的参数，只需要提供部分参数，或者完全不提供参数。&lt;/p&gt;
&lt;p&gt;先来看一段代码：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala字符串插值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b012-stringInterpolation/"/>
    <id>http://scala.chobit.org/wiki/20180506/b012-stringInterpolation/</id>
    <published>2018-05-06T11:02:07.000Z</published>
    <updated>2018-05-06T23:11:10.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符中。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>在上例中， s”Hello,$name” 是待处理字符串字面，编译器会对它做额外的工作。待处理字符串字面通过“号前的字符来标示（例如：上例中是s）。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Scala 提供了三种创新的字符串插值方法：s,f 和 raw.</p><h3 id="s-字符串插值器"><a href="#s-字符串插值器" class="headerlink" title="s 字符串插值器"></a>s 字符串插值器</h3><p>在任何字符串前加上s，就可以直接在串中使用变量了。你已经见过这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>此例中，$name嵌套在一个将被s字符串插值器处理的字符串中。插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。  </p><p>字符串插值器也可以处理任意的表达式。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">s"1+1=<span class="subst">$&#123;1+1&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>将会输出字符串1+1=2。任何表达式都可以嵌入到${}中。</p><h3 id="f-插值器"><a href="#f-插值器" class="headerlink" title="f 插值器"></a>f 插值器</h3><p>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数。当使用 f 插值器的时候，所有的变量引用都应当后跟一个printf-style格式的字符串，如%d。看下面这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">f"<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall"</span>)<span class="comment">//James is 1.90 meters tall</span></span><br></pre></td></tr></table></figure></p><p>f 插值器是类型安全的。如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val height:Double=1.9d</span><br><span class="line"></span><br><span class="line">scala&gt;f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">&lt;console&gt;:9: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found : Double</span><br><span class="line"> required: Int</span><br><span class="line">           f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">              ^ f</span><br></pre></td></tr></table></figure><p>插值器利用了java中的字符串数据格式。这种以%开头的格式在 [Formatter javadoc] 中有相关概述。如果在具体变量后没有%，则格式化程序默认使用 %s（串型）格式。</p><h3 id="raw-插值器"><a href="#raw-插值器" class="headerlink" title="raw 插值器"></a>raw 插值器</h3><p>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的。如下是个被处理过的字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;s<span class="string">"a\nb"</span></span><br><span class="line">res0:String=</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><p>这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;raw<span class="string">"a\nb"</span></span><br><span class="line">res1:String=a\nb</span><br></pre></td></tr></table></figure></p><p>当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。  </p><p>除了以上三种字符串插值器外，使用者可以自定义插值器。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>在Scala中，所有处理过的字符串字面值都进行了简单编码转换。任何时候编译器遇到一个如下形式的字符串字面值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">id"string content"</span></span><br></pre></td></tr></table></figure></p><p>它都会被转换成一个StringContext实例的call(id)方法。这个方法在隐式范围内仍可用。只需要简单得建立一个隐类，给StringContext实例增加一个新方法，便可以定义我们自己的字符串插值器。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：为了避免运行时实例化，我们从AnyVal中继承。</span></span><br><span class="line"><span class="comment">//更多信息请见值类的说明</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=sys.error(<span class="string">"TODO-IMPLEMENT"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveMeSomeJson</span></span>(x:<span class="type">JSONObject</span>):<span class="type">Unit</span>=...</span><br><span class="line"></span><br><span class="line">giveMeSomeJson(<span class="string">json"&#123;name:<span class="subst">$name</span>,id:<span class="subst">$id</span>&#125;"</span>)</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们试图通过字符串插值生成一个JSON文本语法。隐类JsonHelper作用域内使用该语法，且这个JSON方法需要一个完整的实现。只不过，字符串字面值格式化的结果不是一个字符串，而是一个JSON对象。<br>当编译器遇到“{name:\$name, id:\$id”}”，它将会被重写成如下表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>).json(name,id)</span><br></pre></td></tr></table></figure></p><p>隐类则被重写成如下形式<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">JsonHelper</span>(<span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>)).json(name,id)</span><br></pre></td></tr></table></figure></p><p>所以，JSON方法可以访问字符串的原生片段而每个表达式都是一个值。这个方法的一个简单但又令人迷惑的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=&#123;</span><br><span class="line">    <span class="keyword">val</span> strings=sc.parts.iterator</span><br><span class="line">    <span class="keyword">val</span> expressions=args.iterator</span><br><span class="line">    <span class="keyword">var</span> buf=<span class="keyword">new</span> <span class="type">StringBuffer</span>(strings.next)</span><br><span class="line">    <span class="keyword">while</span>(strings.hasNext)&#123;</span><br><span class="line">      buf append expressions.next</span><br><span class="line">      buf append strings.next</span><br><span class="line">    &#125;</span><br><span class="line">    parseJson(buf)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被处理过的字符串的每部分都是StringContext的成员。每个表达式的值都将传入到JSON方法的args参数。JSON方法接受这些值并合成一个大字符串，然后再解析成JSON格式。有一种更复杂的实现可以避免合成字符串的操作，它只是简单的直接通过原生字符串和表达式值构建JSON。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>字符串插值目前对模式匹配语句不适用。此特性将在2.11版本中生效。</p><p>本文转载自：<a href="https://docs.scala-lang.org/zh-cn/overviews/core/string-interpolation.html" rel="external nofollow noopener noreferrer" target="_blank">字符串插值</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>带名称的参数值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b011-namedParam/"/>
    <id>http://scala.chobit.org/wiki/20180506/b011-namedParam/</id>
    <published>2018-05-06T11:00:40.000Z</published>
    <updated>2018-05-06T11:14:06.543Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一段代码，看看执行后会输出什么：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">showValue</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"x is <span class="subst">$x</span>"</span>)</span><br><span class="line">    println(<span class="string">s"y is <span class="subst">$y</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  showValue(y = <span class="number">3</span>, x = <span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码看了以后第一反应是会报错。我将最后一行“showValue(y = 3, x = 6)”中的“y=3”和“x=3”看做简单赋值语句了。scala中赋值语句返回值为Unit，所以执行代码会报类型不匹配的错误。</p><p>然而我错了。  </p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x is 6</span><br><span class="line">y is 3</span><br></pre></td></tr></table></figure></p><p>最后一行代码中的“y=3”和“x=3”的确是赋值语句，更准确的说法是根据参数名称显式赋值。传递给方法的值就是赋给参数的值，而非Unit。  </p><p>一般情况下调用方法或函数，就按照函数定义时的参数顺序一个个传递。但是也可以通过指定参数名赋值，并且不需要按照定义时的顺序向函数传递参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看一段代码，看看执行后会输出什么：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数默认值</title>
    <link href="http://scala.chobit.org/wiki/20180506/b010-defaultParamValue/"/>
    <id>http://scala.chobit.org/wiki/20180506/b010-defaultParamValue/</id>
    <published>2018-05-06T10:45:01.000Z</published>
    <updated>2018-05-06T10:56:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>Scala可以为方法参数指定默认值。<br>使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。</p><p>举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no</span></span>(no: <span class="type">Int</span> = <span class="number">1</span>) = no</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Default No. is "</span> + no())</span><br><span class="line"></span><br><span class="line">println(<span class="string">"This No. is "</span> + no(<span class="number">9</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Default No. is 1</span><br><span class="line">This No. is 9</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala可以为方法参数指定默认值。&lt;br&gt;使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数中的 =&gt;U 和 ()=&gt;U</title>
    <link href="http://scala.chobit.org/wiki/20180506/b009-callByNameAndFunctionValue/"/>
    <id>http://scala.chobit.org/wiki/20180506/b009-callByNameAndFunctionValue/</id>
    <published>2018-05-06T10:06:30.000Z</published>
    <updated>2018-05-06T11:23:54.888Z</updated>
    
    <content type="html"><![CDATA[<p>在scala参数中会遇到=&gt;U 或者 ()=&gt;U。U表示返回值类型。简单说下二者的区别。  </p><p>=&gt;U是一个传名参数，表示一个无参方法。  </p><p>()=&gt;U则是一个函数。</p><p>举个例子，看一下二者的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mTime</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> fTime = ()=&gt;<span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t1: =&gt; <span class="type">Long</span>, t2: ()=&gt;<span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t1</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$&#123;t2()&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(mTime, fTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于方法和函数的关系可以参考<a href="/wiki/20180501/a15-methodVsFunction/">之前的一篇文</a>。  </p><p>还有篇关于传名参数的文：<a href="/wiki/20180506/a18-callByName/">传名参数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala参数中会遇到=&amp;gt;U 或者 ()=&amp;gt;U。U表示返回值类型。简单说下二者的区别。  &lt;/p&gt;
&lt;p&gt;=&amp;gt;U是一个传名参数，表示一个无参方法。  &lt;/p&gt;
&lt;p&gt;()=&amp;gt;U则是一个函数。&lt;/p&gt;
&lt;p&gt;举个例子，看一下二者的区别：&lt;br&gt;&lt;fi
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>传名参数 =&gt;Unit</title>
    <link href="http://scala.chobit.org/wiki/20180506/a18-callByName/"/>
    <id>http://scala.chobit.org/wiki/20180506/a18-callByName/</id>
    <published>2018-05-05T23:09:35.000Z</published>
    <updated>2018-05-06T10:59:30.758Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的解释器在解析函数参数(function arguments)时有两种方式：</p><ul><li>传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；</li><li>传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部。</li></ul><p>以上是比较严谨的说法。简单解释下，传值调用就是我们常见的方法调用方式，将一个值作为参数传递给方法或函数。java中的方法都是传值调用。传名调用，则是将一个方法作为参数传递给其他方法或函数。</p><p>传名调用的参数是方法而非函数，且要求作为参数的方法的参数为空。</p><p>来看一个传名参数的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">time</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t: =&gt; <span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$t</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结下传名参数的优势：</p><ul><li>进行实时运算；</li><li>如果没有被用到，就可以不必进行运算。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala的解释器在解析函数参数(function arguments)时有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；&lt;/li&gt;
&lt;li&gt;传名调用（call-by-name）：将未计算的参数表达式直
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于import</title>
    <link href="http://scala.chobit.org/wiki/20180505/a17-aboutImport/"/>
    <id>http://scala.chobit.org/wiki/20180505/a17-aboutImport/</id>
    <published>2018-05-05T14:56:26.000Z</published>
    <updated>2018-05-05T15:02:11.940Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几个import相关的特性</p><ul><li><p>特性一: 用import com.zhyea._这种格式，可以导入包下所有的成员</p></li><li><p>特性二: 与java不同，scala在任何地方都可以使用import，比如类内、方法内：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">import</span> com.zhyea.service._</span><br><span class="line">        <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">MyService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处在于，可以在一定作用域范围内使用导入</p><ul><li><p>特性三: 选择器、重命名、隐藏</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> &#125; \\仅仅导入com.zhyea.service包下的<span class="type">MyService</span>类，其它不导入</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> =&gt; <span class="type">MyServiceImpl</span> &#125; \\将导入的类进行重命名</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> =&gt; _, _ &#125; \\导入com.zhyea.service包下所有的类，但是隐藏掉<span class="type">MyService</span>类</span><br></pre></td></tr></table></figure></li></ul><ul><li>特性四: 隐式导入</li></ul><p>每个scala程序默认都会隐式导入以下几个包下所有的成员</p><blockquote><p>import java.lang._<br>import scala._<br>import Predef._</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍几个import相关的特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特性一: 用import com.zhyea._这种格式，可以导入包下所有的成员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特性二: 与java不同，scala在任何地方都可以使用import，比如类内、方法内：&lt;/p
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线的作用</title>
    <link href="http://scala.chobit.org/wiki/20180505/b008-usageOfUnderscore/"/>
    <id>http://scala.chobit.org/wiki/20180505/b008-usageOfUnderscore/</id>
    <published>2018-05-05T10:22:46.000Z</published>
    <updated>2018-05-05T11:31:33.231Z</updated>
    
    <content type="html"><![CDATA[<p>相关概念暂未能了解，提供两个参考文档：</p><blockquote><p><a href="https://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala" rel="external nofollow noopener noreferrer" target="_blank">Usage of Underscore In Scala</a><br><a href="https://www.zhihu.com/question/21622725" rel="external nofollow noopener noreferrer" target="_blank">Scala中下划线的应用场景</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相关概念暂未能了解，提供两个参考文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-sc
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>package的使用</title>
    <link href="http://scala.chobit.org/wiki/20180505/a16-usingOfPackage/"/>
    <id>http://scala.chobit.org/wiki/20180505/a16-usingOfPackage/</id>
    <published>2018-05-05T10:16:34.000Z</published>
    <updated>2018-05-05T15:12:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>这一节介绍一些关于package的内容。本来不想写关于package的内容的，因为一开始觉得没啥好写的。这次写因为发现了点儿可以写的内容。</p><h2 id="package定义"><a href="#package定义" class="headerlink" title="package定义"></a>package定义</h2><p>scala中package定义有如下几种方式：</p><h3 id="在文件顶部定义。"><a href="#在文件顶部定义。" class="headerlink" title="在文件顶部定义。"></a>在文件顶部定义。</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea.robin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br></pre></td></tr></table></figure><p>这种方式和java相同。  </p><h3 id="多层级package定义"><a href="#多层级package定义" class="headerlink" title="多层级package定义"></a>多层级package定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com&#123;</span><br><span class="line">    <span class="keyword">package</span> zhyea&#123;</span><br><span class="line">        <span class="keyword">package</span> robin&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这种定义方式比较繁琐，通常都不会采用。</p><h3 id="串联式package定义"><a href="#串联式package定义" class="headerlink" title="串联式package定义"></a>串联式package定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea&#123;</span><br><span class="line">    <span class="keyword">package</span> robin&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">package</span> <span class="title">tom</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方式算是上一种方式的优化版。  </p><p>有的时候我们需要定义几个结构比较简单的class，又不可以将之放在同一个package下，就可以采用这种方案。</p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h3><p>定义package的时候还可以把第一种方式和第二或第三种方式组合起来使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> robin&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">tom</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="package特性"><a href="#package特性" class="headerlink" title="package特性"></a>package特性</h2><p>比较起Java来，scala的package定义有许多特别的地方：</p><ol><li>scala的包定义不受源文件所在目录结构的限制；</li><li>同一个包的定义是可以在不同的源文件中的；</li><li>同一个源文件中是可以存在多个包的。</li></ol><p>java的包声明和文件系统关联比较紧密，比如java的一个public类com.zhyea.Test，我们就可以判断出这个类的源文件是在类路径的com/zhyea路径下。</p><p>scala的包声明不受文件系统的限制，比如一个位于com/zhyea路径下的scala源文件，其顶端的包声明完全可以是“package org.chobit”。另外scala也并不要求源文件的名称要与类名相同。</p><p>根据前面说到的第三种和第四种包定义方式，一个文件中存在多个包是没有问题的。另外一个源文件中定义的多个包可以互相没有任何关系，比如下面这样的定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">org</span>.<span class="title">chobit</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这里定义的两个package不必一定要有相同的父级包。</p><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><p>先来看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> scala &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">      <span class="keyword">val</span> list = <span class="keyword">new</span> scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] <span class="comment">//会在此处报错，使用了相对路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码会在标明的位置报错。因为scala默认会在当前位置向上的相对路径中去找相关的类。在标明会报错的那一行的父级包正好是scala，所以实际上声明的list是这样的类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> com.zhyea.scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure></p><p>编译器会从com.zhyea.scala中去找声明的类，找不到自然就会报错。</p><p>在编程的时候应当尽量避免出现问题。如果是在无法避免可以使用“_root_”声明通过绝对路径去寻找相关的类。如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> scala &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">      <span class="keyword">val</span> list = <span class="keyword">new</span> _root_.scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] <span class="comment">//通过绝对路径查找，不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Scala 定义<em>root</em>包为用户可创建的包之外的包，也就是说任何顶层包都被当作是<em>root</em>包的成员。</p><h2 id="package可见性"><a href="#package可见性" class="headerlink" title="package可见性"></a>package可见性</h2><p>关于scala可见性的内容<a href="wiki/20180429/a11-accessModifier/">前面的一篇文</a>已经说了许多了。<br>这里仅提一点：scala子包中的类可以访问父包中的类。</p><p>不多说，直接看个例子好了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">male</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(fruit: <span class="type">Fruit</span>) = println(<span class="string">s"<span class="subst">$name</span> is eating <span class="subst">$&#123;fruit.name&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="package对象"><a href="#package对象" class="headerlink" title="package对象"></a>package对象</h2><p>package对象或者说package object是一种特殊的object。它的定义方式为：</p><blockquote><p>package object packageName{<br>    valueOrVariant<br>    methods<br>}</p></blockquote><p>package对象的名称需要与package的名称一致，否则就没有意义。package下面的类和对象可以直接访问同名package对象中定义的值或方法。</p><p>看个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> job: <span class="type">String</span> = <span class="string">"Student"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duty</span></span>: <span class="type">String</span> = <span class="string">"Study"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> student &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span>'s job is <span class="subst">$job</span>, and his/her duty is <span class="subst">$&#123;duty&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    println(<span class="keyword">new</span> student.<span class="type">Student</span>(<span class="string">"robin"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过例子可以看出，scala通过package对象在package这一层对功能又做了一次聚合。通过package对象，scala可以解决一些功能增强及版本兼容相关的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节介绍一些关于package的内容。本来不想写关于package的内容的，因为一开始觉得没啥好写的。这次写因为发现了点儿可以写的内容。&lt;/p&gt;
&lt;h2 id=&quot;package定义&quot;&gt;&lt;a href=&quot;#package定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>方法的点和括号是可选的</title>
    <link href="http://scala.chobit.org/wiki/20180503/b007-pointlessMethod/"/>
    <id>http://scala.chobit.org/wiki/20180503/b007-pointlessMethod/</id>
    <published>2018-05-03T14:04:13.000Z</published>
    <updated>2018-05-05T02:38:36.572Z</updated>
    
    <content type="html"><![CDATA[<p>在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。   </p><p>比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。  </p><p>这样做的优势也很明显：代码读起来更加自然，在展现上不至于显得杂乱。</p><p>下面是一段示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(subject: <span class="type">String</span>) = println(<span class="string">s"<span class="subst">$name</span> teaches <span class="subst">$subject</span>."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(subject: <span class="type">String</span>, student: <span class="type">String</span>*) = println(<span class="string">s"<span class="subst">$name</span> teaches <span class="subst">$&#123;student.mkString(",")&#125;</span> to learn <span class="subst">$subject</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>(<span class="string">"Mr.Chang"</span>)</span><br><span class="line"></span><br><span class="line">teacher teach <span class="string">"Mathematics"</span></span><br><span class="line"></span><br><span class="line">teacher teach (<span class="string">"Mathematics"</span>, <span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mr.Chang teaches Mathematics.</span><br><span class="line">Mr.Chang teaches robin to learn Mathematics</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。   &lt;/p&gt;
&lt;p&gt;比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。  &lt;/p&gt;
&lt;p&gt;这样做的优势也很明显：代码读起来更加自然，在展现
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>可变长度参数</title>
    <link href="http://scala.chobit.org/wiki/20180502/b006-variableLengthParams/"/>
    <id>http://scala.chobit.org/wiki/20180502/b006-variableLengthParams/</id>
    <published>2018-05-02T13:53:46.000Z</published>
    <updated>2018-05-05T04:50:18.868Z</updated>
    
    <content type="html"><![CDATA[<p>scala支持可变长度参数。在scala中，可变长度参数的特征如下：</p><ul><li>在参数列表中处于最后面；</li><li>标识方法为在参数类型后放一个星号。</li></ul><p>在scala解释器中写了一个示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(str:String*) = str.foreach&#123;println&#125;</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)</span><br><span class="line">com</span><br><span class="line">zhyea</span><br><span class="line">robin</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个foo方法，它的参数长度就是可变的，方法体的定义是逐行输出每个参数。在随后的验证代码中可以看到结果和预期是一致的。  </p><p>我们知道，在java中，变长参数是被作为数组来处理的。至于在scala中是否也是一样，则需要进行验证。  </p><p>对刚才的示例代码做了些调整来进行验证：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(str: String*) = println(str.getClass)</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"zhyea"</span>)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofRef</span></span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofRef</span></span><br><span class="line"></span><br><span class="line">scala&gt; def foo(nums:Int*) = println(nums.getClass)</span><br><span class="line">foo: (nums: Int*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(1, 2, 3)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofInt</span></span><br></pre></td></tr></table></figure></p><p>可以看到，在scala中变长参数的类型是scala.collection.mutable.WrappedArray的ofXXX子类，并不是一个数组结构。</p><p>再来看看给变长参数的方法传递一个数组结构会有什么样的反应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  def foo(str: String*) = println(str.getClass)</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(Array(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>))</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Array[String]</span><br><span class="line"> required: String</span><br><span class="line">       foo(Array(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>))</span><br></pre></td></tr></table></figure></p><p>可以看到报错了：类型不匹配，需要的是String，传递是String数组。  </p><p>如果我们确实需要把一个类型匹配的数组传递给这个方法，此时我们可以使用“:_<em>”标识符。“:_</em>”作为一个整体，告诉编译器你希望将某个参数当作参数序列处理。  </p><p>看下演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(nums:Int*) = nums.foreach(println)</span><br><span class="line">foo: (nums: Int*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(Array(1,2,3) :_*)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>注意一下，“:_*”不只是能标识数组，还可以标识其他的集合，比如List、Seq、Range等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; foo(1 to 3 :_\*)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>“1 to 3”是一个Range结果，使用“:_*”标识后依然可以被变长参数方法调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala支持可变长度参数。在scala中，可变长度参数的特征如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在参数列表中处于最后面；&lt;/li&gt;
&lt;li&gt;标识方法为在参数类型后放一个星号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在scala解释器中写了一个示例：&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>for循环详述</title>
    <link href="http://scala.chobit.org/wiki/20180501/a14-forLoopDetail/"/>
    <id>http://scala.chobit.org/wiki/20180501/a14-forLoopDetail/</id>
    <published>2018-05-01T05:12:49.000Z</published>
    <updated>2018-05-01T10:52:10.527Z</updated>
    
    <content type="html"><![CDATA[<p>scala的for循环能做的事情很多，这里简单介绍下。</p><h2 id="遍历集合元素"><a href="#遍历集合元素" class="headerlink" title="遍历集合元素"></a>遍历集合元素</h2><p>示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (e &lt;- list) &#123;</span><br><span class="line">  println(<span class="string">s"Current value is: <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有些类似于java中的增强循环。代码中先创建了一个List集合，而后使用for循环遍历输出集合中的元素。  </p><p>代码中的“e&lt;-list”结构被称为“生成器”，在每次迭代时，变量e会被初始化为List集合中的一个元素。e为val变量。  </p><p>scala的for表达式支持所有的集合类型，比如数组、Range、List、Seq等。  </p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>在遍历集合元素时，如不想处理某些元素，可以使用if语句（if语句也被称为卫述语句）来执行过滤。</p><p>示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e &lt;- <span class="number">0</span> to <span class="number">6</span>; <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Current value is: <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中使用生成器“e &lt;- 0 to 6”生成了一个0~6的整型Range；在遍历过程中，使用if语句筛选出了整形序列中所有值为偶数的元素。看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Current value is: 0</span><br><span class="line">Current value is: 2</span><br><span class="line">Current value is: 4</span><br><span class="line">Current value is: 6</span><br></pre></td></tr></table></figure></p><p>如果有必要的话，可以添加多个过滤器，只需要再添加一个if语句即可。比如下面的代码过滤出了整型序列中值为偶数，且大于3的元素：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e &lt;- <span class="number">0</span> to <span class="number">6</span></span><br><span class="line">     <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">     <span class="keyword">if</span> e &gt; <span class="number">3</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Current value is: <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Current value is: 4</span><br><span class="line">Current value is: 6</span><br></pre></td></tr></table></figure></p><h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>for表达式支持多重循环。下面是个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (e &lt;- list; c &lt;- e) &#123;</span><br><span class="line">  println(<span class="string">s"<span class="subst">$c</span> of <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码一重循环遍历了字符串集合中的每个元素，而后在二重循环中遍历了一个字符串元素的每个字符。看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c of com</span><br><span class="line">o of com</span><br><span class="line">m of com</span><br><span class="line">z of zhyea</span><br><span class="line">h of zhyea</span><br><span class="line">y of zhyea</span><br><span class="line">e of zhyea</span><br><span class="line">a of zhyea</span><br></pre></td></tr></table></figure></p><p>上面代码中的两个循环间使用“;”做了分隔，因为下面这种写法在scala中是不被允许的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e &lt;- list</span><br><span class="line">  c &lt;- e) &#123;</span><br><span class="line">  println(<span class="string">s"<span class="subst">$c</span> of <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为scala编译器不会推断在小括号内省略掉的“;”号。要想省略两个生成器中的“;”，可以使用花括号替换for循环的小括号：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;e &lt;- list</span><br><span class="line">     c &lt;- e&#125; &#123;</span><br><span class="line">  println(<span class="string">s"<span class="subst">$c</span> of <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用花括号和使用小括号是等价的，处理逻辑上并无不同。</p><h2 id="绑定中间变量"><a href="#绑定中间变量" class="headerlink" title="绑定中间变量"></a>绑定中间变量</h2><p>在for循环表达式中，scala允许创建一个变量保存中间值。看下示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;e &lt;- list</span><br><span class="line">     c &lt;- e</span><br><span class="line">     index = e.indexOf(c)&#125; &#123;</span><br><span class="line">  println(<span class="string">s"Index of <span class="subst">$c</span> in <span class="subst">$e</span> is <span class="subst">$index</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的for循环表达式中创建了一个index变量保存每个字符在字符串的索引位置。这里的index是val变量，只是不需要使用val声明。  </p><p>如果将index变量移动到for循环的循环体中，则val声明不可省略。</p><h2 id="生成新集合"><a href="#生成新集合" class="headerlink" title="生成新集合"></a>生成新集合</h2><p>在for循环中可以使用yield关键字返回一个新的集合。通常新的集合的类型和循环的集合类型一致。</p><p>这个实例在scala解释器中写比较直观些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nums = <span class="keyword">for</span>(i&lt;-List(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)) yield i</span><br><span class="line">nums: List[String] = List(com, zhyea, robin)</span><br></pre></td></tr></table></figure></p><p>下面是一个返回值和循环的集合类型不严格一致的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nums = 0 to 6</span><br><span class="line">nums: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; val nums = <span class="keyword">for</span>(i&lt;- 0 to 6)yield i</span><br><span class="line">nums: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的for循环能做的事情很多，这里简单介绍下。&lt;/p&gt;
&lt;h2 id=&quot;遍历集合元素&quot;&gt;&lt;a href=&quot;#遍历集合元素&quot; class=&quot;headerlink&quot; title=&quot;遍历集合元素&quot;&gt;&lt;/a&gt;遍历集合元素&lt;/h2&gt;&lt;p&gt;示例代码如下：&lt;br&gt;&lt;figure 
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>方法VS函数</title>
    <link href="http://scala.chobit.org/wiki/20180501/a15-methodVsFunction/"/>
    <id>http://scala.chobit.org/wiki/20180501/a15-methodVsFunction/</id>
    <published>2018-05-01T02:23:25.000Z</published>
    <updated>2018-05-05T02:51:53.954Z</updated>
    
    <content type="html"><![CDATA[<p>在scala中，我们可以认为函数和方法是两个不同的概念——尽管很多时候它们是通用的。这一节简单介绍下二者之间的关系。</p><h2 id="方法和函数的不同"><a href="#方法和函数的不同" class="headerlink" title="方法和函数的不同"></a>方法和函数的不同</h2><p>函数在定义和调用等方面有着不同。先来看一下。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>scala中的方法是类的一部分，方法不能脱离类独立存在。</p><p>scala中的函数是一个对象。scala用22个trait（包括Function1~Function22，以下简称FunctionN）抽象出了函数的概念。scala中的函数就是实现了这些trait的对象。它的表现形式通常为“(T1, …, Tn) =&gt; U”。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是一个方法的声明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个相同功能的函数的声明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multi = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">  x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到声明函数声明方法存在着明显的不同：</p><ul><li>声明方法使用的是def关键字，声明函数使用的是val关键字</li><li>函数不需要(不可以)显式注明返回值的类型，方法的返回值类型是可选的</li><li>函数的表现形式为：(T1, …, Tn) =&gt; U</li></ul><p>函数本质上是一个值（也称函数值），我们定义的multi函数其意义等同于下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multi = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>]()&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里代码中的multi实际上就是依赖trait Function2实现的一个匿名类实例。Function2有三个类型参数[Int, Int, Int]，前两个是apply方法的参数类型，最后一个是apply返回值类型。</p><p>apply是scala提供的一个语法糖，比如对object A调用A()，scala编译器会自动将之转换为A.apply()。对一个class B调用B()，就是在调用B的伴生对象的apply方法。</p><p>应该能注意到Function2对应的函数有两个参数。scala就是这样设计的：FunctionN对应的函数有N个参数。所以scala的函数的参数长度是有限的。</p><p>既然函数本质上是一个对象，那么声明函数也可以使用关键字var：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multi = (x:<span class="type">Int</span>, y:<span class="type">Int</span>) =&gt; x * y</span><br></pre></td></tr></table></figure></p><p>在为var函数值变量重新赋值时遇到了一个问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var multi = (x: Int, y: Int) =&gt; x * y</span><br><span class="line">multi: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; multi = (x:Int) =&gt; x * 1</span><br><span class="line">&lt;console&gt;:12: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Int =&gt; Int</span><br><span class="line"> required: (Int, Int) =&gt; Int</span><br><span class="line">       multi = (x:Int) =&gt; x * 1</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure></p><p>重新赋值时要求新的函数值的参数列表与原函数值一致。这是因为scala的类型推断能力，在初始化multi函数值时就将multi的类型推断为Function2[Int, Int, Int]。当为multi重新赋值时，就只能赋值为Function2[Int, Int, Int]的实例，也就是只能赋值为相同参数类型且相同返回值类型的函数。</p><h3 id="方法和函数的调用"><a href="#方法和函数的调用" class="headerlink" title="方法和函数的调用"></a>方法和函数的调用</h3><p>方法名就意味着方法的调用。而函数因为本身是一个值，函数名只能代表函数自身。</p><p>我们定义一个无参的方法和一个无参的函数来做一下演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def m() = 100</span><br><span class="line">m: ()Int</span><br><span class="line"></span><br><span class="line">scala&gt; val f = ()=&gt;100</span><br><span class="line">f: () =&gt; Int = &lt;function0&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; m</span><br><span class="line">res1: Int = 100</span><br><span class="line"></span><br><span class="line">scala&gt; f</span><br><span class="line">res2: () =&gt; Int = &lt;function0&gt;</span><br></pre></td></tr></table></figure></p><p>使用方法名时可以看到是调用了方法，使用函数名时则与声明函数时返回的信息相同。</p><p>如果要调用一个函数，可以在函数名后面加上()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; f()</span><br><span class="line">res3: Int = 100</span><br></pre></td></tr></table></figure></p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>方法和函数都有参数列表，它们的参数列表的长度都可以为0。  </p><p>方法可以没有参数列表，比如“def m=100”就是正确的。  </p><p>函数则不能没有参数列表，如“val f = =&gt;100”就一定会报错。函数的参数列表长度可以为0，比如“()=&gt;100”</p><h3 id="最终表达式"><a href="#最终表达式" class="headerlink" title="最终表达式"></a>最终表达式</h3><p>因为函数本质上是一个值，所以函数可以作为最终表达式使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val multi = (x:Int, y:Int) =&gt; x*y</span><br><span class="line">multi: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; multi</span><br><span class="line">res5: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>方法不能作为最终表达式使用。当方法有参数时或者说参数长度大于0时，直接使用方法名就会报错。当方法参数长度为0时，直接使用方法名等同于调用方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def add(x:Int, y:Int) = x+y</span><br><span class="line">add: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; add</span><br><span class="line">&lt;console&gt;:13: error: missing argument list <span class="keyword">for</span> method add</span><br><span class="line">Unapplied methods are only converted to <span class="built_in">functions</span> when a <span class="keyword">function</span> <span class="built_in">type</span> is expected.</span><br><span class="line">You can make this conversion explicit by writing `add _` or `add(_,_)` instead of `add`.</span><br><span class="line">       add</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure></p><h2 id="方法和函数的转换"><a href="#方法和函数的转换" class="headerlink" title="方法和函数的转换"></a>方法和函数的转换</h2><p>在本文一开始我们提到过scala的函数和方法很多时候是通用的，这里是指scala中的函数和方法是可以互相转换的。这种转换很多时候还是隐式的。</p><h3 id="将方法转换为函数"><a href="#将方法转换为函数" class="headerlink" title="将方法转换为函数"></a>将方法转换为函数</h3><p>scala的一些高级函数比如map()、filter()、foreach()等，需要传递一个函数值作为参数。我们可以直接传递一个方法给这些高级函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(1,2,3,4)</span><br><span class="line">list: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; val f = (n:Int)=&gt;<span class="built_in">print</span>(n)</span><br><span class="line">f: Int =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; list.foreach(f)</span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">scala&gt; def m(n:Int) = <span class="built_in">print</span>(n)</span><br><span class="line">m: (n: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; list.foreach(m)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure></p><p>在代码中我们定义了一个List实例，我们主要调用了list的foreach方法。foreach方法的参数是一个函数值。通过foreach方法我们可以遍历List实例，并在函数值中调用List实例的每个值。  </p><p>我们先为foreach方法提供了一个函数值f。函数值的功能很简单，就是打印出当前遍历的值。然后又为foreach方法提供了一个方法m作为参数，方法m和函数f提供的能力是相同的，我们可以看到执行结果也是相同的。</p><p>这种在期望出现函数的地方提供了一个方法，方法被自动转换成函数的行为被称为ETA展开。</p><p>注意，虽然scala提供了ETA展开的能力，但是不能直接将方法赋值给变量作为函数值。</p><p>刚才我们说的是一种隐式转换的例子。我们还可以显式地将方法转为函数，做法很简单，就是在方法名后面加一个下划线：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def add(x:Int, y:Int) = x +y</span><br><span class="line">add: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; add _</span><br><span class="line">res12: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>注意方法名后的下划线和方法名中间需要存在一个空格。</p><p>scala还有一种特殊的参数叫做传名参数，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delayed</span></span>( t: =&gt; <span class="type">Long</span> ) = &#123;</span><br><span class="line">      println(<span class="string">"参数： "</span> + t)</span><br><span class="line">      t</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time</span></span>() = <span class="type">System</span>.currentTimeMillis</span><br><span class="line"></span><br><span class="line">delayed(time())</span><br></pre></td></tr></table></figure></p><p>看起来有点儿像是函数值的使用，但是传名参数实质是一个没有参数列表的方法，因此使用参数名字的时候是调用了对应的方法。</p><h3 id="将函数转换为方法"><a href="#将函数转换为方法" class="headerlink" title="将函数转换为方法"></a>将函数转换为方法</h3><p>将函数转换为方法的做法前面提到过：在函数名后面添加()和参数即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val multi = (x:Int, y:Int) =&gt; x*y</span><br><span class="line">multi: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; multi(1,2)</span><br><span class="line">res13: Int = 2</span><br></pre></td></tr></table></figure></p><p>这一节就先介绍这些内容。如果想深入了解可以参考下<a href="/download/ScalaSpecification.pdf">Scala 语言规范</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala中，我们可以认为函数和方法是两个不同的概念——尽管很多时候它们是通用的。这一节简单介绍下二者之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;方法和函数的不同&quot;&gt;&lt;a href=&quot;#方法和函数的不同&quot; class=&quot;headerlink&quot; title=&quot;方法和函数的不同&quot;&gt;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.org/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala中的自适应做法</title>
    <link href="http://scala.chobit.org/wiki/20180501/b005-adaptivePractice/"/>
    <id>http://scala.chobit.org/wiki/20180501/b005-adaptivePractice/</id>
    <published>2018-04-30T23:21:13.000Z</published>
    <updated>2018-05-01T04:31:43.481Z</updated>
    
    <content type="html"><![CDATA[<p>scala有一些默认做法，会让代码更简洁、更易读写，下面列出了这样几个特性：</p><ol><li><p>支持脚本。scala支持脚本，因此无须将所有的代码都放到类里。如果脚本可以满足需求，就将代码放到一个脚本里，无须再创建一个冗余的类。</p></li><li><p>return是可选的。如果没有写return关键字，方法调用会自动返回最后一个求值的表达式——如果它符合方法声明的返回值类型。</p></li><li><p>分号“；”是可选的。不必在每个语句的后面都写上分号，这样会使代码更简洁。如果语句太长或者包含多行的话可以换行继续写，scala能够识别语句是否完整。通常使用分号的场景就是一行内有多条语句。</p></li><li><p>类和方法默认是public的，不必显式使用public关键字。</p></li><li><p>Scala提供了轻量级的语法创建JavaBean——用更少的代码创建变量和final属性。 </p></li><li><p>Scala不会强制捕获一些不关心的异常，降低了代码规模，也避免了不恰当的异常处理。  </p></li></ol><p>另外，默认情况下，scala会导入两个包和一个对象。导入顺序如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">scala</span><br><span class="line">scala.<span class="type">Predef</span></span><br></pre></td></tr></table></figure></p><p>两个包是：java.lang和scala，一个对象是scala.Predef。  </p><p>因为有这个默认导入的机制，使用这两个包中的类不需要使用全限定类名。比如使用String类时，就不需要使用java.lang.String，也不必显式导入。因为默认导入了scala包中的全部内容，所以可以很容易的使用scala中的类型。  </p><p>Predef对象（是对象不是类哦）包含了类型、隐式转换以及一些常用的方法。因为已经默认导入了，所以使用时无需导入也不需要任何前缀即可使用这些方法和转换。这些操作非常便捷，以至于在刚开始使用时会将之视为scala语言的一部分，实际上他们是scala程序库的一部分。  </p><p>Predef对象也为诸如scala.collection.immutable.Set和scala.collection. immutable.Map这样的东西提供了别名。比如，引用Set或Map，实际上引用的是他们在Predef中的定义，它们会依次转换为其在scala.collection.immutable包里的定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala有一些默认做法，会让代码更简洁、更易读写，下面列出了这样几个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;支持脚本。scala支持脚本，因此无须将所有的代码都放到类里。如果脚本可以满足需求，就将代码放到一个脚本里，无须再创建一个冗余的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.org/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
