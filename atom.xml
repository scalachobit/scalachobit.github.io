<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCALA 手账</title>
  
  <subtitle>scala</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scala.chobit.com/"/>
  <updated>2018-05-06T13:49:23.377Z</updated>
  <id>http://scala.chobit.com/</id>
  
  <author>
    <name>robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>scala字符串插值</title>
    <link href="http://scala.chobit.com/wiki/20180506/b012-stringInterpolation/"/>
    <id>http://scala.chobit.com/wiki/20180506/b012-stringInterpolation/</id>
    <published>2018-05-06T11:02:07.000Z</published>
    <updated>2018-05-06T13:49:23.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符中。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>在上例中， s”Hello,$name” 是待处理字符串字面，编译器会对它做额外的工作。待处理字符串字面通过“号前的字符来标示（例如：上例中是s）。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Scala 提供了三种创新的字符串插值方法：s,f 和 raw.</p><h3 id="s-字符串插值器"><a href="#s-字符串插值器" class="headerlink" title="s 字符串插值器"></a>s 字符串插值器</h3><p>在任何字符串前加上s，就可以直接在串中使用变量了。你已经见过这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure></p><p>此例中，$name嵌套在一个将被s字符串插值器处理的字符串中。插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。  </p><p>字符串插值器也可以处理任意的表达式。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">s"1+1=<span class="subst">$&#123;1+1&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>将会输出字符串1+1=2。任何表达式都可以嵌入到${}中。</p><h3 id="f-插值器"><a href="#f-插值器" class="headerlink" title="f 插值器"></a>f 插值器</h3><p>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数。当使用 f 插值器的时候，所有的变量引用都应当后跟一个printf-style格式的字符串，如%d。看下面这个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line">println(<span class="string">f"<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall"</span>)<span class="comment">//James is 1.90 meters tall</span></span><br></pre></td></tr></table></figure></p><p>f 插值器是类型安全的。如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val height:Double=1.9d</span><br><span class="line"></span><br><span class="line">scala&gt;f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">&lt;console&gt;:9: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found : Double</span><br><span class="line"> required: Int</span><br><span class="line">           f<span class="string">"<span class="variable">$height</span>%4d"</span></span><br><span class="line">              ^ f</span><br></pre></td></tr></table></figure><p>插值器利用了java中的字符串数据格式。这种以%开头的格式在 [Formatter javadoc] 中有相关概述。如果在具体变量后没有%，则格式化程序默认使用 %s（串型）格式。</p><h3 id="raw-插值器"><a href="#raw-插值器" class="headerlink" title="raw 插值器"></a>raw 插值器</h3><p>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的。如下是个被处理过的字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;s<span class="string">"a\nb"</span></span><br><span class="line">res0:String=</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><p>这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;raw<span class="string">"a\nb"</span></span><br><span class="line">res1:String=a\nb</span><br></pre></td></tr></table></figure></p><p>当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。  </p><p>除了以上三种字符串插值器外，使用者可以自定义插值器。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>在Scala中，所有处理过的字符串字面值都进行了简单编码转换。任何时候编译器遇到一个如下形式的字符串字面值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">id"string content"</span></span><br></pre></td></tr></table></figure></p><p>它都会被转换成一个StringContext实例的call(id)方法。这个方法在隐式范围内仍可用。只需要简单得建立一个隐类，给StringContext实例增加一个新方法，便可以定义我们自己的字符串插值器。如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：为了避免运行时实例化，我们从AnyVal中继承。</span></span><br><span class="line"><span class="comment">//更多信息请见值类的说明</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=sys.error(<span class="string">"TODO-IMPLEMENT"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveMeSomeJson</span></span>(x:<span class="type">JSONObject</span>):<span class="type">Unit</span>=...</span><br><span class="line"></span><br><span class="line">giveMeSomeJson(<span class="string">json"&#123;name:<span class="subst">$name</span>,id:<span class="subst">$id</span>&#125;"</span>)</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们试图通过字符串插值生成一个JSON文本语法。隐类JsonHelper作用域内使用该语法，且这个JSON方法需要一个完整的实现。只不过，字符串字面值格式化的结果不是一个字符串，而是一个JSON对象。<br>当编译器遇到”{name:$name,id:$id”}”，它将会被重写成如下表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>).json(name,id)</span><br></pre></td></tr></table></figure></p><p>隐类则被重写成如下形式<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">JsonHelper</span>(<span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">"&#123;name:"</span>,<span class="string">",id:"</span>,<span class="string">"&#125;"</span>)).json(name,id)</span><br></pre></td></tr></table></figure></p><p>所以，JSON方法可以访问字符串的原生片段而每个表达式都是一个值。这个方法的一个简单但又令人迷惑的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=&#123;</span><br><span class="line">    <span class="keyword">val</span> strings=sc.parts.iterator</span><br><span class="line">    <span class="keyword">val</span> expressions=args.iterator</span><br><span class="line">    <span class="keyword">var</span> buf=<span class="keyword">new</span> <span class="type">StringBuffer</span>(strings.next)</span><br><span class="line">    <span class="keyword">while</span>(strings.hasNext)&#123;</span><br><span class="line">      buf append expressions.next</span><br><span class="line">      buf append strings.next</span><br><span class="line">    &#125;</span><br><span class="line">    parseJson(buf)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被处理过的字符串的每部分都是StringContext的成员。每个表达式的值都将传入到JSON方法的args参数。JSON方法接受这些值并合成一个大字符串，然后再解析成JSON格式。有一种更复杂的实现可以避免合成字符串的操作，它只是简单的直接通过原生字符串和表达式值构建JSON。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>字符串插值目前对模式匹配语句不适用。此特性将在2.11版本中生效。</p><p>本文转载自：<a href="https://docs.scala-lang.org/zh-cn/overviews/core/string-.html" rel="external nofollow noopener noreferrer" target="_blank">字符串插值</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;自2.10.0版本开始，Scala提供了一种新的机制来根据数据生成字符串：字符串插值。字符串插值允许使用者将变量引用直接插入处理过的字面字符
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>带名称的参数值</title>
    <link href="http://scala.chobit.com/wiki/20180506/b011-namedParam/"/>
    <id>http://scala.chobit.com/wiki/20180506/b011-namedParam/</id>
    <published>2018-05-06T11:00:40.000Z</published>
    <updated>2018-05-06T11:14:06.543Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一段代码，看看执行后会输出什么：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">showValue</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s"x is <span class="subst">$x</span>"</span>)</span><br><span class="line">    println(<span class="string">s"y is <span class="subst">$y</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  showValue(y = <span class="number">3</span>, x = <span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码看了以后第一反应是会报错。我将最后一行“showValue(y = 3, x = 6)”中的“y=3”和“x=3”看做简单赋值语句了。scala中赋值语句返回值为Unit，所以执行代码会报类型不匹配的错误。</p><p>然而我错了。  </p><p>看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x is 6</span><br><span class="line">y is 3</span><br></pre></td></tr></table></figure></p><p>最后一行代码中的“y=3”和“x=3”的确是赋值语句，更准确的说法是根据参数名称显式赋值。传递给方法的值就是赋给参数的值，而非Unit。  </p><p>一般情况下调用方法或函数，就按照函数定义时的参数顺序一个个传递。但是也可以通过指定参数名赋值，并且不需要按照定义时的顺序向函数传递参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看一段代码，看看执行后会输出什么：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数默认值</title>
    <link href="http://scala.chobit.com/wiki/20180506/b010-defaultParamValue/"/>
    <id>http://scala.chobit.com/wiki/20180506/b010-defaultParamValue/</id>
    <published>2018-05-06T10:45:01.000Z</published>
    <updated>2018-05-06T10:56:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>Scala可以为方法参数指定默认值。<br>使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。</p><p>举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no</span></span>(no: <span class="type">Int</span> = <span class="number">1</span>) = no</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Default No. is "</span> + no())</span><br><span class="line"></span><br><span class="line">println(<span class="string">"This No. is "</span> + no(<span class="number">9</span>))</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Default No. is 1</span><br><span class="line">This No. is 9</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala可以为方法参数指定默认值。&lt;br&gt;使用了默认参数，在调用方法时可以不需要再传递参数，此时函数就会调用默认参数值，如果传递了参数值，则传递值会取代默认值。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>参数中的 =&gt;U 和 ()=&gt;U</title>
    <link href="http://scala.chobit.com/wiki/20180506/b009-callByNameAndFunctionValue/"/>
    <id>http://scala.chobit.com/wiki/20180506/b009-callByNameAndFunctionValue/</id>
    <published>2018-05-06T10:06:30.000Z</published>
    <updated>2018-05-06T11:23:54.888Z</updated>
    
    <content type="html"><![CDATA[<p>在scala参数中会遇到=&gt;U 或者 ()=&gt;U。U表示返回值类型。简单说下二者的区别。  </p><p>=&gt;U是一个传名参数，表示一个无参方法。  </p><p>()=&gt;U则是一个函数。</p><p>举个例子，看一下二者的区别：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mTime</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> fTime = ()=&gt;<span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t1: =&gt; <span class="type">Long</span>, t2: ()=&gt;<span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t1</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$&#123;t2()&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(mTime, fTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于方法和函数的关系可以参考<a href="/wiki/20180501/a15-methodVsFunction/">之前的一篇文</a>。  </p><p>还有篇关于传名参数的文：<a href="/wiki/20180506/a18-callByName/">传名参数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala参数中会遇到=&amp;gt;U 或者 ()=&amp;gt;U。U表示返回值类型。简单说下二者的区别。  &lt;/p&gt;
&lt;p&gt;=&amp;gt;U是一个传名参数，表示一个无参方法。  &lt;/p&gt;
&lt;p&gt;()=&amp;gt;U则是一个函数。&lt;/p&gt;
&lt;p&gt;举个例子，看一下二者的区别：&lt;br&gt;&lt;fi
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>传名参数 =&gt;Unit</title>
    <link href="http://scala.chobit.com/wiki/20180506/a18-callByName/"/>
    <id>http://scala.chobit.com/wiki/20180506/a18-callByName/</id>
    <published>2018-05-05T23:09:35.000Z</published>
    <updated>2018-05-06T10:59:30.758Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的解释器在解析函数参数(function arguments)时有两种方式：</p><ul><li>传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；</li><li>传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部。</li></ul><p>以上是比较严谨的说法。简单解释下，传值调用就是我们常见的方法调用方式，将一个值作为参数传递给方法或函数。java中的方法都是传值调用。传名调用，则是将一个方法作为参数传递给其他方法或函数。</p><p>传名调用的参数是方法而非函数，且要求作为参数的方法的参数为空。</p><p>来看一个传名参数的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">time</span></span>: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">job</span></span>(t: =&gt; <span class="type">Long</span>) = &#123;</span><br><span class="line">    println(<span class="string">s"start time: <span class="subst">$t</span>"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) <span class="type">Thread</span>.sleep(i * <span class="number">100</span>)</span><br><span class="line">    println(<span class="string">s"end time: <span class="subst">$t</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结下传名参数的优势：</p><ul><li>进行实时运算；</li><li>如果没有被用到，就可以不必进行运算。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala的解释器在解析函数参数(function arguments)时有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；&lt;/li&gt;
&lt;li&gt;传名调用（call-by-name）：将未计算的参数表达式直
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于import</title>
    <link href="http://scala.chobit.com/wiki/20180505/a17-aboutImport/"/>
    <id>http://scala.chobit.com/wiki/20180505/a17-aboutImport/</id>
    <published>2018-05-05T14:56:26.000Z</published>
    <updated>2018-05-05T15:02:11.940Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几个import相关的特性</p><ul><li><p>特性一: 用import com.zhyea._这种格式，可以导入包下所有的成员</p></li><li><p>特性二: 与java不同，scala在任何地方都可以使用import，比如类内、方法内：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">import</span> com.zhyea.service._</span><br><span class="line">        <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">MyService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处在于，可以在一定作用域范围内使用导入</p><ul><li><p>特性三: 选择器、重命名、隐藏</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> &#125; \\仅仅导入com.zhyea.service包下的<span class="type">MyService</span>类，其它不导入</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> =&gt; <span class="type">MyServiceImpl</span> &#125; \\将导入的类进行重命名</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhyea.service.&#123; <span class="type">MyService</span> =&gt; _, _ &#125; \\导入com.zhyea.service包下所有的类，但是隐藏掉<span class="type">MyService</span>类</span><br></pre></td></tr></table></figure></li></ul><ul><li>特性四: 隐式导入</li></ul><p>每个scala程序默认都会隐式导入以下几个包下所有的成员</p><blockquote><p>import java.lang._<br>import scala._<br>import Predef._</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍几个import相关的特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特性一: 用import com.zhyea._这种格式，可以导入包下所有的成员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特性二: 与java不同，scala在任何地方都可以使用import，比如类内、方法内：&lt;/p
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>下划线的作用</title>
    <link href="http://scala.chobit.com/wiki/20180505/b008-usageOfUnderscore/"/>
    <id>http://scala.chobit.com/wiki/20180505/b008-usageOfUnderscore/</id>
    <published>2018-05-05T10:22:46.000Z</published>
    <updated>2018-05-05T11:31:33.231Z</updated>
    
    <content type="html"><![CDATA[<p>相关概念暂未能了解，提供两个参考文档：</p><blockquote><p><a href="https://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala" rel="external nofollow noopener noreferrer" target="_blank">Usage of Underscore In Scala</a><br><a href="https://www.zhihu.com/question/21622725" rel="external nofollow noopener noreferrer" target="_blank">Scala中下划线的应用场景</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相关概念暂未能了解，提供两个参考文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-sc
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>package的使用</title>
    <link href="http://scala.chobit.com/wiki/20180505/a16-usingOfPackage/"/>
    <id>http://scala.chobit.com/wiki/20180505/a16-usingOfPackage/</id>
    <published>2018-05-05T10:16:34.000Z</published>
    <updated>2018-05-05T15:12:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>这一节介绍一些关于package的内容。本来不想写关于package的内容的，因为一开始觉得没啥好写的。这次写因为发现了点儿可以写的内容。</p><h2 id="package定义"><a href="#package定义" class="headerlink" title="package定义"></a>package定义</h2><p>scala中package定义有如下几种方式：</p><h3 id="在文件顶部定义。"><a href="#在文件顶部定义。" class="headerlink" title="在文件顶部定义。"></a>在文件顶部定义。</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea.robin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br></pre></td></tr></table></figure><p>这种方式和java相同。  </p><h3 id="多层级package定义"><a href="#多层级package定义" class="headerlink" title="多层级package定义"></a>多层级package定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com&#123;</span><br><span class="line">    <span class="keyword">package</span> zhyea&#123;</span><br><span class="line">        <span class="keyword">package</span> robin&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这种定义方式比较繁琐，通常都不会采用。</p><h3 id="串联式package定义"><a href="#串联式package定义" class="headerlink" title="串联式package定义"></a>串联式package定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea&#123;</span><br><span class="line">    <span class="keyword">package</span> robin&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">package</span> <span class="title">tom</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方式算是上一种方式的优化版。  </p><p>有的时候我们需要定义几个结构比较简单的class，又不可以将之放在同一个package下，就可以采用这种方案。</p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h3><p>定义package的时候还可以把第一种方式和第二或第三种方式组合起来使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> robin&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">tom</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="package特性"><a href="#package特性" class="headerlink" title="package特性"></a>package特性</h2><p>比较起Java来，scala的package定义有许多特别的地方：</p><ol><li>scala的包定义不受源文件所在目录结构的限制；</li><li>同一个包的定义是可以在不同的源文件中的；</li><li>同一个源文件中是可以存在多个包的。</li></ol><p>java的包声明和文件系统关联比较紧密，比如java的一个public类com.zhyea.Test，我们就可以判断出这个类的源文件是在类路径的com/zhyea路径下。</p><p>scala的包声明不受文件系统的限制，比如一个位于com/zhyea路径下的scala源文件，其顶端的包声明完全可以是“package org.chobit”。另外scala也并不要求源文件的名称要与类名相同。</p><p>根据前面说到的第三种和第四种包定义方式，一个文件中存在多个包是没有问题的。另外一个源文件中定义的多个包可以互相没有任何关系，比如下面这样的定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">org</span>.<span class="title">chobit</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这里定义的两个package不必一定要有相同的父级包。</p><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><p>先来看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> scala &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">      <span class="keyword">val</span> list = <span class="keyword">new</span> scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] <span class="comment">//会在此处报错，使用了相对路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码会在标明的位置报错。因为scala默认会在当前位置向上的相对路径中去找相关的类。在标明会报错的那一行的父级包正好是scala，所以实际上声明的list是这样的类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> com.zhyea.scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure></p><p>编译器会从com.zhyea.scala中去找声明的类，找不到自然就会报错。</p><p>在编程的时候应当尽量避免出现问题。如果是在无法避免可以使用“_root_”声明通过绝对路径去寻找相关的类。如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> scala &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">      <span class="keyword">val</span> list = <span class="keyword">new</span> _root_.scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] <span class="comment">//通过绝对路径查找，不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Scala 定义<em>root</em>包为用户可创建的包之外的包，也就是说任何顶层包都被当作是<em>root</em>包的成员。</p><h2 id="package可见性"><a href="#package可见性" class="headerlink" title="package可见性"></a>package可见性</h2><p>关于scala可见性的内容<a href="wiki/20180429/a11-accessModifier/">前面的一篇文</a>已经说了许多了。<br>这里仅提一点：scala子包中的类可以访问父包中的类。</p><p>不多说，直接看个例子好了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">package</span> <span class="title">male</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(fruit: <span class="type">Fruit</span>) = println(<span class="string">s"<span class="subst">$name</span> is eating <span class="subst">$&#123;fruit.name&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="package对象"><a href="#package对象" class="headerlink" title="package对象"></a>package对象</h2><p>package对象或者说package object是一种特殊的object。它的定义方式为：</p><blockquote><p>package object packageName{<br>    valueOrVariant<br>    methods<br>}</p></blockquote><p>package对象的名称需要与package的名称一致，否则就没有意义。package下面的类和对象可以直接访问同名package对象中定义的值或方法。</p><p>看个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> job: <span class="type">String</span> = <span class="string">"Student"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duty</span></span>: <span class="type">String</span> = <span class="string">"Study"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> student &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span>'s job is <span class="subst">$job</span>, and his/her duty is <span class="subst">$&#123;duty&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    println(<span class="keyword">new</span> student.<span class="type">Student</span>(<span class="string">"robin"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过例子可以看出，scala通过package对象在package这一层对功能又做了一次聚合。通过package对象，scala可以解决一些功能增强及版本兼容相关的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节介绍一些关于package的内容。本来不想写关于package的内容的，因为一开始觉得没啥好写的。这次写因为发现了点儿可以写的内容。&lt;/p&gt;
&lt;h2 id=&quot;package定义&quot;&gt;&lt;a href=&quot;#package定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>方法的点和括号是可选的</title>
    <link href="http://scala.chobit.com/wiki/20180503/b007-pointlessMethod/"/>
    <id>http://scala.chobit.com/wiki/20180503/b007-pointlessMethod/</id>
    <published>2018-05-03T14:04:13.000Z</published>
    <updated>2018-05-05T02:38:36.572Z</updated>
    
    <content type="html"><![CDATA[<p>在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。   </p><p>比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。  </p><p>这样做的优势也很明显：代码读起来更加自然，在展现上不至于显得杂乱。</p><p>下面是一段示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(subject: <span class="type">String</span>) = println(<span class="string">s"<span class="subst">$name</span> teaches <span class="subst">$subject</span>."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teach</span></span>(subject: <span class="type">String</span>, student: <span class="type">String</span>*) = println(<span class="string">s"<span class="subst">$name</span> teaches <span class="subst">$&#123;student.mkString(",")&#125;</span> to learn <span class="subst">$subject</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>(<span class="string">"Mr.Chang"</span>)</span><br><span class="line"></span><br><span class="line">teacher teach <span class="string">"Mathematics"</span></span><br><span class="line"></span><br><span class="line">teacher teach (<span class="string">"Mathematics"</span>, <span class="string">"robin"</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mr.Chang teaches Mathematics.</span><br><span class="line">Mr.Chang teaches robin to learn Mathematics</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。   &lt;/p&gt;
&lt;p&gt;比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。  &lt;/p&gt;
&lt;p&gt;这样做的优势也很明显：代码读起来更加自然，在展现
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>可变长度参数</title>
    <link href="http://scala.chobit.com/wiki/20180502/b006-variableLengthParams/"/>
    <id>http://scala.chobit.com/wiki/20180502/b006-variableLengthParams/</id>
    <published>2018-05-02T13:53:46.000Z</published>
    <updated>2018-05-05T04:50:18.868Z</updated>
    
    <content type="html"><![CDATA[<p>scala支持可变长度参数。在scala中，可变长度参数的特征如下：</p><ul><li>在参数列表中处于最后面；</li><li>标识方法为在参数类型后放一个星号。</li></ul><p>在scala解释器中写了一个示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(str:String*) = str.foreach&#123;println&#125;</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)</span><br><span class="line">com</span><br><span class="line">zhyea</span><br><span class="line">robin</span><br></pre></td></tr></table></figure></p><p>在代码中定义了一个foo方法，它的参数长度就是可变的，方法体的定义是逐行输出每个参数。在随后的验证代码中可以看到结果和预期是一致的。  </p><p>我们知道，在java中，变长参数是被作为数组来处理的。至于在scala中是否也是一样，则需要进行验证。  </p><p>对刚才的示例代码做了些调整来进行验证：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(str: String*) = println(str.getClass)</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"zhyea"</span>)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofRef</span></span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofRef</span></span><br><span class="line"></span><br><span class="line">scala&gt; def foo(nums:Int*) = println(nums.getClass)</span><br><span class="line">foo: (nums: Int*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(1, 2, 3)</span><br><span class="line">class scala.collection.mutable.WrappedArray<span class="variable">$ofInt</span></span><br></pre></td></tr></table></figure></p><p>可以看到，在scala中变长参数的类型是scala.collection.mutable.WrappedArray的ofXXX子类，并不是一个数组结构。</p><p>再来看看给变长参数的方法传递一个数组结构会有什么样的反应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  def foo(str: String*) = println(str.getClass)</span><br><span class="line">foo: (str: String*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(Array(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>))</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Array[String]</span><br><span class="line"> required: String</span><br><span class="line">       foo(Array(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>))</span><br></pre></td></tr></table></figure></p><p>可以看到报错了：类型不匹配，需要的是String，传递是String数组。  </p><p>如果我们确实需要把一个类型匹配的数组传递给这个方法，此时我们可以使用“:_<em>”标识符。“:_</em>”作为一个整体，告诉编译器你希望将某个参数当作参数序列处理。  </p><p>看下演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def foo(nums:Int*) = nums.foreach(println)</span><br><span class="line">foo: (nums: Int*)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; foo(Array(1,2,3) :_*)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>注意一下，“:_*”不只是能标识数组，还可以标识其他的集合，比如List、Seq、Range等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; foo(1 to 3 :_\*)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>“1 to 3”是一个Range结果，使用“:_*”标识后依然可以被变长参数方法调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala支持可变长度参数。在scala中，可变长度参数的特征如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在参数列表中处于最后面；&lt;/li&gt;
&lt;li&gt;标识方法为在参数类型后放一个星号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在scala解释器中写了一个示例：&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>for循环详述</title>
    <link href="http://scala.chobit.com/wiki/20180501/a14-forLoopDetail/"/>
    <id>http://scala.chobit.com/wiki/20180501/a14-forLoopDetail/</id>
    <published>2018-05-01T05:12:49.000Z</published>
    <updated>2018-05-01T10:52:10.527Z</updated>
    
    <content type="html"><![CDATA[<p>scala的for循环能做的事情很多，这里简单介绍下。</p><h2 id="遍历集合元素"><a href="#遍历集合元素" class="headerlink" title="遍历集合元素"></a>遍历集合元素</h2><p>示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (e &lt;- list) &#123;</span><br><span class="line">  println(<span class="string">s"Current value is: <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有些类似于java中的增强循环。代码中先创建了一个List集合，而后使用for循环遍历输出集合中的元素。  </p><p>代码中的“e&lt;-list”结构被称为“生成器”，在每次迭代时，变量e会被初始化为List集合中的一个元素。e为val变量。  </p><p>scala的for表达式支持所有的集合类型，比如数组、Range、List、Seq等。  </p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>在遍历集合元素时，如不想处理某些元素，可以使用if语句（if语句也被称为卫述语句）来执行过滤。</p><p>示例代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e &lt;- <span class="number">0</span> to <span class="number">6</span>; <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Current value is: <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中使用生成器“e &lt;- 0 to 6”生成了一个0~6的整型Range；在遍历过程中，使用if语句筛选出了整形序列中所有值为偶数的元素。看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Current value is: 0</span><br><span class="line">Current value is: 2</span><br><span class="line">Current value is: 4</span><br><span class="line">Current value is: 6</span><br></pre></td></tr></table></figure></p><p>如果有必要的话，可以添加多个过滤器，只需要再添加一个if语句即可。比如下面的代码过滤出了整型序列中值为偶数，且大于3的元素：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e &lt;- <span class="number">0</span> to <span class="number">6</span></span><br><span class="line">     <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">     <span class="keyword">if</span> e &gt; <span class="number">3</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Current value is: <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Current value is: 4</span><br><span class="line">Current value is: 6</span><br></pre></td></tr></table></figure></p><h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>for表达式支持多重循环。下面是个实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (e &lt;- list; c &lt;- e) &#123;</span><br><span class="line">  println(<span class="string">s"<span class="subst">$c</span> of <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码一重循环遍历了字符串集合中的每个元素，而后在二重循环中遍历了一个字符串元素的每个字符。看下执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c of com</span><br><span class="line">o of com</span><br><span class="line">m of com</span><br><span class="line">z of zhyea</span><br><span class="line">h of zhyea</span><br><span class="line">y of zhyea</span><br><span class="line">e of zhyea</span><br><span class="line">a of zhyea</span><br></pre></td></tr></table></figure></p><p>上面代码中的两个循环间使用“;”做了分隔，因为下面这种写法在scala中是不被允许的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e &lt;- list</span><br><span class="line">  c &lt;- e) &#123;</span><br><span class="line">  println(<span class="string">s"<span class="subst">$c</span> of <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为scala编译器不会推断在小括号内省略掉的“;”号。要想省略两个生成器中的“;”，可以使用花括号替换for循环的小括号：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;e &lt;- list</span><br><span class="line">     c &lt;- e&#125; &#123;</span><br><span class="line">  println(<span class="string">s"<span class="subst">$c</span> of <span class="subst">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用花括号和使用小括号是等价的，处理逻辑上并无不同。</p><h2 id="绑定中间变量"><a href="#绑定中间变量" class="headerlink" title="绑定中间变量"></a>绑定中间变量</h2><p>在for循环表达式中，scala允许创建一个变量保存中间值。看下示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"com"</span>, <span class="string">"zhyea"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;e &lt;- list</span><br><span class="line">     c &lt;- e</span><br><span class="line">     index = e.indexOf(c)&#125; &#123;</span><br><span class="line">  println(<span class="string">s"Index of <span class="subst">$c</span> in <span class="subst">$e</span> is <span class="subst">$index</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的for循环表达式中创建了一个index变量保存每个字符在字符串的索引位置。这里的index是val变量，只是不需要使用val声明。  </p><p>如果将index变量移动到for循环的循环体中，则val声明不可省略。</p><h2 id="生成新集合"><a href="#生成新集合" class="headerlink" title="生成新集合"></a>生成新集合</h2><p>在for循环中可以使用yield关键字返回一个新的集合。通常新的集合的类型和循环的集合类型一致。</p><p>这个实例在scala解释器中写比较直观些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nums = <span class="keyword">for</span>(i&lt;-List(<span class="string">"com"</span>, <span class="string">"zhyea"</span>, <span class="string">"robin"</span>)) yield i</span><br><span class="line">nums: List[String] = List(com, zhyea, robin)</span><br></pre></td></tr></table></figure></p><p>下面是一个返回值和循环的集合类型不严格一致的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nums = 0 to 6</span><br><span class="line">nums: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; val nums = <span class="keyword">for</span>(i&lt;- 0 to 6)yield i</span><br><span class="line">nums: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的for循环能做的事情很多，这里简单介绍下。&lt;/p&gt;
&lt;h2 id=&quot;遍历集合元素&quot;&gt;&lt;a href=&quot;#遍历集合元素&quot; class=&quot;headerlink&quot; title=&quot;遍历集合元素&quot;&gt;&lt;/a&gt;遍历集合元素&lt;/h2&gt;&lt;p&gt;示例代码如下：&lt;br&gt;&lt;figure 
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>方法VS函数</title>
    <link href="http://scala.chobit.com/wiki/20180501/a15-methodVsFunction/"/>
    <id>http://scala.chobit.com/wiki/20180501/a15-methodVsFunction/</id>
    <published>2018-05-01T02:23:25.000Z</published>
    <updated>2018-05-05T02:51:53.954Z</updated>
    
    <content type="html"><![CDATA[<p>在scala中，我们可以认为函数和方法是两个不同的概念——尽管很多时候它们是通用的。这一节简单介绍下二者之间的关系。</p><h2 id="方法和函数的不同"><a href="#方法和函数的不同" class="headerlink" title="方法和函数的不同"></a>方法和函数的不同</h2><p>函数在定义和调用等方面有着不同。先来看一下。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>scala中的方法是类的一部分，方法不能脱离类独立存在。</p><p>scala中的函数是一个对象。scala用22个trait（包括Function1~Function22，以下简称FunctionN）抽象出了函数的概念。scala中的函数就是实现了这些trait的对象。它的表现形式通常为“(T1, …, Tn) =&gt; U”。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是一个方法的声明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个相同功能的函数的声明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multi = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">  x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到声明函数声明方法存在着明显的不同：</p><ul><li>声明方法使用的是def关键字，声明函数使用的是val关键字</li><li>函数不需要(不可以)显式注明返回值的类型，方法的返回值类型是可选的</li><li>函数的表现形式为：(T1, …, Tn) =&gt; U</li></ul><p>函数本质上是一个值（也称函数值），我们定义的multi函数其意义等同于下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multi = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>]()&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里代码中的multi实际上就是依赖trait Function2实现的一个匿名类实例。Function2有三个类型参数[Int, Int, Int]，前两个是apply方法的参数类型，最后一个是apply返回值类型。</p><p>apply是scala提供的一个语法糖，比如对object A调用A()，scala编译器会自动将之转换为A.apply()。对一个class B调用B()，就是在调用B的伴生对象的apply方法。</p><p>应该能注意到Function2对应的函数有两个参数。scala就是这样设计的：FunctionN对应的函数有N个参数。所以scala的函数的参数长度是有限的。</p><p>既然函数本质上是一个对象，那么声明函数也可以使用关键字var：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multi = (x:<span class="type">Int</span>, y:<span class="type">Int</span>) =&gt; x * y</span><br></pre></td></tr></table></figure></p><p>在为var函数值变量重新赋值时遇到了一个问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var multi = (x: Int, y: Int) =&gt; x * y</span><br><span class="line">multi: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; multi = (x:Int) =&gt; x * 1</span><br><span class="line">&lt;console&gt;:12: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Int =&gt; Int</span><br><span class="line"> required: (Int, Int) =&gt; Int</span><br><span class="line">       multi = (x:Int) =&gt; x * 1</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure></p><p>重新赋值时要求新的函数值的参数列表与原函数值一致。这是因为scala的类型推断能力，在初始化multi函数值时就将multi的类型推断为Function2[Int, Int, Int]。当为multi重新赋值时，就只能赋值为Function2[Int, Int, Int]的实例，也就是只能赋值为相同参数类型且相同返回值类型的函数。</p><h3 id="方法和函数的调用"><a href="#方法和函数的调用" class="headerlink" title="方法和函数的调用"></a>方法和函数的调用</h3><p>方法名就意味着方法的调用。而函数因为本身是一个值，函数名只能代表函数自身。</p><p>我们定义一个无参的方法和一个无参的函数来做一下演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def m() = 100</span><br><span class="line">m: ()Int</span><br><span class="line"></span><br><span class="line">scala&gt; val f = ()=&gt;100</span><br><span class="line">f: () =&gt; Int = &lt;function0&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; m</span><br><span class="line">res1: Int = 100</span><br><span class="line"></span><br><span class="line">scala&gt; f</span><br><span class="line">res2: () =&gt; Int = &lt;function0&gt;</span><br></pre></td></tr></table></figure></p><p>使用方法名时可以看到是调用了方法，使用函数名时则与声明函数时返回的信息相同。</p><p>如果要调用一个函数，可以在函数名后面加上()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; f()</span><br><span class="line">res3: Int = 100</span><br></pre></td></tr></table></figure></p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>方法和函数都有参数列表，它们的参数列表的长度都可以为0。  </p><p>方法可以没有参数列表，比如“def m=100”就是正确的。  </p><p>函数则不能没有参数列表，如“val f = =&gt;100”就一定会报错。函数的参数列表长度可以为0，比如“()=&gt;100”</p><h3 id="最终表达式"><a href="#最终表达式" class="headerlink" title="最终表达式"></a>最终表达式</h3><p>因为函数本质上是一个值，所以函数可以作为最终表达式使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val multi = (x:Int, y:Int) =&gt; x*y</span><br><span class="line">multi: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; multi</span><br><span class="line">res5: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>方法不能作为最终表达式使用。当方法有参数时或者说参数长度大于0时，直接使用方法名就会报错。当方法参数长度为0时，直接使用方法名等同于调用方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def add(x:Int, y:Int) = x+y</span><br><span class="line">add: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; add</span><br><span class="line">&lt;console&gt;:13: error: missing argument list <span class="keyword">for</span> method add</span><br><span class="line">Unapplied methods are only converted to <span class="built_in">functions</span> when a <span class="keyword">function</span> <span class="built_in">type</span> is expected.</span><br><span class="line">You can make this conversion explicit by writing `add _` or `add(_,_)` instead of `add`.</span><br><span class="line">       add</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure></p><h2 id="方法和函数的转换"><a href="#方法和函数的转换" class="headerlink" title="方法和函数的转换"></a>方法和函数的转换</h2><p>在本文一开始我们提到过scala的函数和方法很多时候是通用的，这里是指scala中的函数和方法是可以互相转换的。这种转换很多时候还是隐式的。</p><h3 id="将方法转换为函数"><a href="#将方法转换为函数" class="headerlink" title="将方法转换为函数"></a>将方法转换为函数</h3><p>scala的一些高级函数比如map()、filter()、foreach()等，需要传递一个函数值作为参数。我们可以直接传递一个方法给这些高级函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(1,2,3,4)</span><br><span class="line">list: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; val f = (n:Int)=&gt;<span class="built_in">print</span>(n)</span><br><span class="line">f: Int =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; list.foreach(f)</span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">scala&gt; def m(n:Int) = <span class="built_in">print</span>(n)</span><br><span class="line">m: (n: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; list.foreach(m)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure></p><p>在代码中我们定义了一个List实例，我们主要调用了list的foreach方法。foreach方法的参数是一个函数值。通过foreach方法我们可以遍历List实例，并在函数值中调用List实例的每个值。  </p><p>我们先为foreach方法提供了一个函数值f。函数值的功能很简单，就是打印出当前遍历的值。然后又为foreach方法提供了一个方法m作为参数，方法m和函数f提供的能力是相同的，我们可以看到执行结果也是相同的。</p><p>这种在期望出现函数的地方提供了一个方法，方法被自动转换成函数的行为被称为ETA展开。</p><p>注意，虽然scala提供了ETA展开的能力，但是不能直接将方法赋值给变量作为函数值。</p><p>刚才我们说的是一种隐式转换的例子。我们还可以显式地将方法转为函数，做法很简单，就是在方法名后面加一个下划线：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def add(x:Int, y:Int) = x +y</span><br><span class="line">add: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; add _</span><br><span class="line">res12: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br></pre></td></tr></table></figure></p><p>注意方法名后的下划线和方法名中间需要存在一个空格。</p><p>scala还有一种特殊的参数叫做传名参数，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delayed</span></span>( t: =&gt; <span class="type">Long</span> ) = &#123;</span><br><span class="line">      println(<span class="string">"参数： "</span> + t)</span><br><span class="line">      t</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time</span></span>() = <span class="type">System</span>.currentTimeMillis</span><br><span class="line"></span><br><span class="line">delayed(time())</span><br></pre></td></tr></table></figure></p><p>看起来有点儿像是函数值的使用，但是传名参数实质是一个没有参数列表的方法，因此使用参数名字的时候是调用了对应的方法。</p><h3 id="将函数转换为方法"><a href="#将函数转换为方法" class="headerlink" title="将函数转换为方法"></a>将函数转换为方法</h3><p>将函数转换为方法的做法前面提到过：在函数名后面添加()和参数即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val multi = (x:Int, y:Int) =&gt; x*y</span><br><span class="line">multi: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; multi(1,2)</span><br><span class="line">res13: Int = 2</span><br></pre></td></tr></table></figure></p><p>这一节就先介绍这些内容。如果想深入了解可以参考下<a href="/download/ScalaSpecification.pdf">Scala 语言规范</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在scala中，我们可以认为函数和方法是两个不同的概念——尽管很多时候它们是通用的。这一节简单介绍下二者之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;方法和函数的不同&quot;&gt;&lt;a href=&quot;#方法和函数的不同&quot; class=&quot;headerlink&quot; title=&quot;方法和函数的不同&quot;&gt;
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala中的自适应做法</title>
    <link href="http://scala.chobit.com/wiki/20180501/b005-adaptivePractice/"/>
    <id>http://scala.chobit.com/wiki/20180501/b005-adaptivePractice/</id>
    <published>2018-04-30T23:21:13.000Z</published>
    <updated>2018-05-01T04:31:43.481Z</updated>
    
    <content type="html"><![CDATA[<p>scala有一些默认做法，会让代码更简洁、更易读写，下面列出了这样几个特性：</p><ol><li><p>支持脚本。scala支持脚本，因此无须将所有的代码都放到类里。如果脚本可以满足需求，就将代码放到一个脚本里，无须再创建一个冗余的类。</p></li><li><p>return是可选的。如果没有写return关键字，方法调用会自动返回最后一个求值的表达式——如果它符合方法声明的返回值类型。</p></li><li><p>分号“；”是可选的。不必在每个语句的后面都写上分号，这样会使代码更简洁。如果语句太长或者包含多行的话可以换行继续写，scala能够识别语句是否完整。通常使用分号的场景就是一行内有多条语句。</p></li><li><p>类和方法默认是public的，不必显式使用public关键字。</p></li><li><p>Scala提供了轻量级的语法创建JavaBean——用更少的代码创建变量和final属性。 </p></li><li><p>Scala不会强制捕获一些不关心的异常，降低了代码规模，也避免了不恰当的异常处理。  </p></li></ol><p>另外，默认情况下，scala会导入两个包和一个对象。导入顺序如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">scala</span><br><span class="line">scala.<span class="type">Predef</span></span><br></pre></td></tr></table></figure></p><p>两个包是：java.lang和scala，一个对象是scala.Predef。  </p><p>因为有这个默认导入的机制，使用这两个包中的类不需要使用全限定类名。比如使用String类时，就不需要使用java.lang.String，也不必显式导入。因为默认导入了scala包中的全部内容，所以可以很容易的使用scala中的类型。  </p><p>Predef对象（是对象不是类哦）包含了类型、隐式转换以及一些常用的方法。因为已经默认导入了，所以使用时无需导入也不需要任何前缀即可使用这些方法和转换。这些操作非常便捷，以至于在刚开始使用时会将之视为scala语言的一部分，实际上他们是scala程序库的一部分。  </p><p>Predef对象也为诸如scala.collection.immutable.Set和scala.collection. immutable.Map这样的东西提供了别名。比如，引用Set或Map，实际上引用的是他们在Predef中的定义，它们会依次转换为其在scala.collection.immutable包里的定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala有一些默认做法，会让代码更简洁、更易读写，下面列出了这样几个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;支持脚本。scala支持脚本，因此无须将所有的代码都放到类里。如果脚本可以满足需求，就将代码放到一个脚本里，无须再创建一个冗余的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>object中的main方法</title>
    <link href="http://scala.chobit.com/wiki/20180501/b004-objectMainMethod/"/>
    <id>http://scala.chobit.com/wiki/20180501/b004-objectMainMethod/</id>
    <published>2018-04-30T23:20:48.000Z</published>
    <updated>2018-05-01T05:11:55.393Z</updated>
    
    <content type="html"><![CDATA[<p>scala对象的main方法可以作为应用或脚本的入口。  </p><p>来看一个简单的实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"Hello World!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以通过混入trait App来避免使用main方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"Hello World!"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是因为在trait App中实现了main方法。类定义中的初始化代码块内容在编译时都被写入了一个函数对象缓存，直到在调用App的main方法时才会从缓存中取出初始化函数来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala对象的main方法可以作为应用或脚本的入口。  &lt;/p&gt;
&lt;p&gt;来看一个简单的实例：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>方法的定义</title>
    <link href="http://scala.chobit.com/wiki/20180430/a12-defineMethod/"/>
    <id>http://scala.chobit.com/wiki/20180430/a12-defineMethod/</id>
    <published>2018-04-30T09:23:00.000Z</published>
    <updated>2018-05-01T13:42:09.971Z</updated>
    
    <content type="html"><![CDATA[<p>scala的方法关键字def声明开始。大致结构如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">methodName</span> </span>([list of parameters]) : [<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>] </span>= &#123;</span><br><span class="line">   method body</span><br><span class="line">   [<span class="keyword">return</span> [expr]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>scala方法名可以包含字符、数字以及各种符号。方法名不能以数字开头。虽然scala的方法名不能以数字开头，但是可以以特殊字符开头。可用的特殊字符如：+，++，~，&amp;，- ， – ，\，/，:等。  </p><p>scala的方法参数都是val类型，而不是var类型，因此在函数体内不可以修改参数的值。  </p><p>关于scala的返回值有如下几个特点：</p><ul><li>scala的方法是一定有返回值的，看起来返回值为空时返回的是值类型Unit；</li><li>方法定义时返回值类型可以省略掉，scala会根据方法体中的内容推断出返回值类型；</li><li>显式声明了返回值类型时，方法定义中的“等号”不可以省略掉；</li><li>没有显式声明返回值类型时，则默认方法返回值为Unit，此时方法定义中的“=”也可省略掉；</li><li>使用return可以显式返回，但是不推荐这样做；</li><li>方法中的return关键字是可以省略掉的，默认方法中的最后一行就是函数的值；</li><li>对于递归方法，必须显式指明返回值类型。</li></ul><p>多提一点：在scala中分号也是可选的，不必在每个语句的后面都写上分号，这样会使代码更简洁。如果语句太长或者包含多行的话可以换行继续写，scala能够识别语句是否完整。通常使用分号的场景就是一行内有多条语句。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的方法关键字def声明开始。大致结构如下：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>循环和循环控制</title>
    <link href="http://scala.chobit.com/wiki/20180429/a13-loopAndLoopControl/"/>
    <id>http://scala.chobit.com/wiki/20180429/a13-loopAndLoopControl/</id>
    <published>2018-04-29T01:40:46.000Z</published>
    <updated>2018-05-01T09:06:20.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>scala中的循环类型和java差不多，大体上有三种：  </p><ul><li>while循环</li><li>do{}while循环</li><li>for循环</li></ul><p>每样循环都写一段示例代码来看一下。  </p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 0</span><br><span class="line">Value of i: 1</span><br><span class="line">Value of i: 2</span><br><span class="line">Value of i: 3</span><br><span class="line">Value of i: 4</span><br><span class="line">Value of i: 5</span><br></pre></td></tr></table></figure></p><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do{}while循环"></a>do{}while循环</h3><p>代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">  println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 0</span><br><span class="line">Value of i: 1</span><br><span class="line">Value of i: 2</span><br><span class="line">Value of i: 3</span><br><span class="line">Value of i: 4</span><br><span class="line">Value of i: 5</span><br></pre></td></tr></table></figure></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>看一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">5</span>) &#123;</span><br><span class="line">  println(<span class="string">s"Value of i <span class="subst">$i</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value of i 1</span><br><span class="line">Value of i 2</span><br><span class="line">Value of i 3</span><br><span class="line">Value of i 4</span><br><span class="line">Value of i 5</span><br></pre></td></tr></table></figure></p><p>在上面代码中的循环结构里，”i &lt;- 0 to 5”是一个生成器表达式。在这里的每次循环中都会创建一个新的val变量i（而非是给i赋值），用生成器表达式产生出来的连续值进行初始化。  </p><p>生成器表达式“1 to 3”生成的连续值包含了下界[1]和上界[3]，如果用until方法替换to方法后，就可以排除上界。to和until都是scala的RichInt类的方法。</p><p>这里使用1 to 3等价于1.to(3)，即数字1调用了整型的to方法。在scala中，如果方法有0或1个参数，点和括号是可以丢掉的。如果方法的参数多于一个，那么就必须保留括号，但是点仍是可选的。以一个非常常见的表达式为例：1 + 2在scala中实际上就是1.+(2)，+也是一个方法而非是简单的符号。</p><p>我们已经知道1 to 3返回的使一个连续值(Range)，那么也可以考虑使用Range的foreach方法来实现循环。代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">3</span>).foreach(i =&gt; println(<span class="string">s"Value of i <span class="subst">$i</span>"</span>))</span><br></pre></td></tr></table></figure></p><p>for循环的功能非常丰富，值得多多解释一下，所以会另写一篇进行说明。</p><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>通常的循环控制语句就是<strong>continue</strong>和<strong>break</strong>。但是这两个关键字在scala中是不存在的。不过我们可以使用一些技巧来实现这两种控制语句。  </p><p>先来看一个Java的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Value of i:"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码要做的事情非常简单，不需要多做解释。  </p><p>要用scala实现这个逻辑，简单点儿的思路是用if判断句来替换continue，用一个bool变量控制循环来替换break。代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">break</span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">6</span> &amp;&amp; !<span class="keyword">break</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码实现了前面那段Java代码的功能。期间我们还是使用了两个var变量。这两个var变量一个用来提供循环值，一个用来实现break功能中止循环。scala不鼓励使用var变量。我们尝试去掉这两个var变量。  </p><p>要去掉循环值变量可以考虑将所有的循环值放入一个集合，然后使用for循环来处理。<br>要去掉break控制变量，可以考虑主动抛出异常来中止当前代码块。</p><p>根据这个思路来做一下实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123;</span><br><span class="line">    i <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> =&gt;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在修改后的代码里使用模式匹配替换了if判断，并且演示了scala处理异常的方案。<br>这里用抛出异常来实现break的方式scala中有提供具体的实现方案，即在scala.util.control包中定义的break控制结构，用法如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b = <span class="keyword">new</span> scala.util.control.<span class="type">Breaks</span></span><br><span class="line"></span><br><span class="line">b.breakable &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123;</span><br><span class="line">    i <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> =&gt;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span> =&gt; b.<span class="keyword">break</span>()</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路还可以继续展开，比如用递归来替换循环：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myLoop</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">6</span>) ()</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) myLoop(i + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">4</span>) &#123;</span><br><span class="line">    println(<span class="string">s"Value of i: <span class="subst">$i</span>"</span>);</span><br><span class="line">    myLoop(i + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLoop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>在函数化编程中使用递归函数来实现循环是非常常见的一种方法，并且这样做很函数式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;循环类型&quot;&gt;&lt;a href=&quot;#循环类型&quot; class=&quot;headerlink&quot; title=&quot;循环类型&quot;&gt;&lt;/a&gt;循环类型&lt;/h2&gt;&lt;p&gt;scala中的循环类型和java差不多，大体上有三种：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;while循环&lt;/li&gt;
&lt;li&gt;do
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>scala等于符号“==”</title>
    <link href="http://scala.chobit.com/wiki/20180429/b003-equalitySymbol/"/>
    <id>http://scala.chobit.com/wiki/20180429/b003-equalitySymbol/</id>
    <published>2018-04-29T01:27:28.000Z</published>
    <updated>2018-04-29T07:17:21.350Z</updated>
    
    <content type="html"><![CDATA[<p>在java中，基本类型和引用类型对==运算有着不同的解释方式：</p><ul><li>对于基本类型来说，==运算比较的就是两边表达式的值；</li><li>对于引用类型来说，==运算比较的是两边对象的引用而非是对象的值；在Java中比较对象的值使用的是equals方法。</li></ul><p>在scala中没有对象，不论类型如何，==运算都是面向值的。这一点由scala的Any类（scala中所有的类都是由它派生而来）提供了保证：它将==()方法实现为final的方法。因此在scala中进行值的比较就可以简单使用==运算，如果还有一些特殊化的比较，就需要改写equals方法了。在scala中如果想执行对于引用的比较可以使用eq()方法。看一下下面这段程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> str2 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> str3 = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">println(str1 == str2) <span class="comment">// Equivalent to Java's str1.equals(str2)</span></span><br><span class="line">println(str1 eq str2) <span class="comment">// Equivalent to Java's str1 == str2</span></span><br><span class="line">println(str1 == str3)</span><br><span class="line">println(str1 eq str3)</span><br></pre></td></tr></table></figure><p>程序的执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>结果很清楚了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java中，基本类型和引用类型对==运算有着不同的解释方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于基本类型来说，==运算比较的就是两边表达式的值；&lt;/li&gt;
&lt;li&gt;对于引用类型来说，==运算比较的是两边对象的引用而非是对象的值；在Java中比较对象的值使用的是equals方法
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>scala赋值符号“=”</title>
    <link href="http://scala.chobit.com/wiki/20180429/b002-assignmentSymbol/"/>
    <id>http://scala.chobit.com/wiki/20180429/b002-assignmentSymbol/</id>
    <published>2018-04-29T01:15:04.000Z</published>
    <updated>2018-04-29T07:17:09.512Z</updated>
    
    <content type="html"><![CDATA[<p>scala的赋值运算和java的赋值运算有着很大的不同。如a=b这样的赋值运算，在Java中的返回值是a的值，在scala中返回的则是Unit。Unit是值类型，全局只存在唯一的值，即()，通常Unit只用来声明函数或方法的返回值，其他场景基本是没有意义的。这样就很容易导致一些错误地使用，比如a=b=c这样的赋值运算在java中是绝对可以的，但是在scala中使用就会报错。  </p><p>看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span></span><br><span class="line">a =  b=c</span><br><span class="line">println(a)</span><br></pre></td></tr></table></figure></p><p>上面这段代码还没有执行就在IDE中提示错误了，勉强执行下看看会报什么错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error:(6, 9) type mismatch;</span><br><span class="line"> found   : Unit</span><br><span class="line"> required: Int</span><br><span class="line">  a = b = c</span><br></pre></td></tr></table></figure><p>报了类型不匹配的错误，因为在第一行代码中scala推断出a是一个Int型的变量，后又将b=c的运算结果——一个Unit值——赋值给它，所以会报错了。</p><p>即使只在scala中看赋值运算符“=”号也是一个比较奇怪的东西：scala中的大部分运算符都是方法，但“=”不是方法，在默认情况下不可以这样使用：a.=(1)。对于这个问题，有心人可以深究下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scala的赋值运算和java的赋值运算有着很大的不同。如a=b这样的赋值运算，在Java中的返回值是a的值，在scala中返回的则是Unit。Unit是值类型，全局只存在唯一的值，即()，通常Unit只用来声明函数或方法的返回值，其他场景基本是没有意义的。这样就很容易导致
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>访问修饰符</title>
    <link href="http://scala.chobit.com/wiki/20180429/a11-accessModifier/"/>
    <id>http://scala.chobit.com/wiki/20180429/a11-accessModifier/</id>
    <published>2018-04-28T22:38:56.000Z</published>
    <updated>2018-04-29T01:12:35.993Z</updated>
    
    <content type="html"><![CDATA[<p>先简单介绍下scala访问修饰符的几个特性，稍后再详细解释：  </p><ul><li>如果不指定访问修饰符，默认为public；</li><li>较之Java，scala对protected的定义更加严格；</li><li>scala可以对可见性进行细粒度的控制。</li></ul><h2 id="默认访问修饰符"><a href="#默认访问修饰符" class="headerlink" title="默认访问修饰符"></a>默认访问修饰符</h2><p>如果没有修饰符，scala会默认把类、字段、方法的访问修饰符当做public。如果要将之调整为private或protected，只需在前面添加对应的修饰符关键字即可。就如下面的程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Microwave</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() = println(<span class="string">"started"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>() = println(<span class="string">"stopped"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">turnTable</span></span>() = println(<span class="string">"turning table"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> microwave = <span class="keyword">new</span> <span class="type">Microwave</span></span><br><span class="line">microwave.start()</span><br><span class="line"></span><br><span class="line">microwave.turnTable()<span class="comment">//这里错了</span></span><br></pre></td></tr></table></figure><p>在上面的代码里start和stop两个方法默认为public类型，可以通过任意Microwave实例访问。turnTable被显示定义为private，这样就不能在Microwave类外部访问它。执行这段代码，就会如注释处声明的一样，会在该处报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method turnTable in class Microwave cannot be accessed in com.zhyea.MyApp.Microwave</span><br><span class="line"> microwave.turnTable()</span><br></pre></td></tr></table></figure></p><h2 id="protected修饰符"><a href="#protected修饰符" class="headerlink" title="protected修饰符"></a>protected修饰符</h2><p>在scala里，用protected修饰的成员只对本类和派生类可见，同一个包内的其他的类不可见。而且派生类只可以访问本类实例的protected成员。<br>可以通过一个例子看一下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhyea.auto</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">checkEngine</span></span>() = println(<span class="string">"checked engine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    checkEngine()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tow</span></span>(car: <span class="type">Car</span>) &#123;</span><br><span class="line">    car.checkEngine()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tow</span></span>(vehicle: <span class="type">Vehicle</span>) &#123;</span><br><span class="line">    vehicle.checkEngine() <span class="comment">//会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GasStation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fillGas</span></span>(vehicle: <span class="type">Vehicle</span>) &#123;</span><br><span class="line">    vehicle.checkEngine() <span class="comment">//会报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fillGas</span></span>(car: <span class="type">Car</span>) &#123;</span><br><span class="line">    car.checkEngine() <span class="comment">//会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，Vehicle的checkEngine()方法是protected型的，Car是Vehicle类的派生类。</p><p>根据scala对protected修饰符的要求：</p><ul><li>在Car类自定义方法start()中访问父类Vehicle的checkEngine()方法不会报错；</li><li>在Car类自定义方法tow()中通过Car类实例访问父类Vehicle的checkEngine()方法不会报错；</li><li>在Car类自定义方法tow()中通过Vehicle类实例访问Vehicle的checkEngine()方法会报错；</li><li>在同一个包内的GasStation类中通过Car或Vehicle实例访问checkEngine()方法会报错</li></ul><p>这些错误在编译期就会报出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Vehicle</span><br><span class="line"> Access to protected method checkEngine not permitted because </span><br><span class="line"> prefix type com.zhyea.auto.Vehicle does not conform to class Car in package auto where the access take place</span><br><span class="line">    vehicle.checkEngine() //会报错</span><br><span class="line">    </span><br><span class="line">method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Vehicle</span><br><span class="line"> Access to protected method checkEngine not permitted because</span><br><span class="line"> enclosing class GasStation in package auto is not a subclass of </span><br><span class="line"> class Vehicle in package auto where target is defined</span><br><span class="line">    vehicle.checkEngine() //会报错</span><br><span class="line"></span><br><span class="line">method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Car</span><br><span class="line"> Access to protected method checkEngine not permitted because</span><br><span class="line"> enclosing class GasStation in package auto is not a subclass of </span><br><span class="line"> class Vehicle in package auto where target is defined</span><br><span class="line">    car.checkEngine() //会报错</span><br></pre></td></tr></table></figure><h2 id="细粒度访问控制"><a href="#细粒度访问控制" class="headerlink" title="细粒度访问控制"></a>细粒度访问控制</h2><p>scala对待protected比Java更加严格，但另一方面它提供了更多的灵活性和更细粒度的访问规则。</p><p>使用private和protected时可以指定额外的参数，使用方式如：private[AccessQualifier]。AccessQualifier可以是this，也可以是其它的类名或包名。<br>对于修饰符private[AccessQualifier]可以这样理解：除了自己和AccessQualifier所表示范围内的类，该修饰符修饰的成员对其他所有类的可见性都是private。并且这个概念也是可以递推的，也就是说，如果AccessQualifier是一个类，那么private成员对于AccessQualifier的AccessQualifier也是可见的。</p><p>看一个细粒度访问控制的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> society &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> professional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span>[professional] <span class="keyword">var</span> workDetails = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">private</span>[society] <span class="keyword">var</span> friends = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> secret = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">help</span></span>(another: <span class="type">Executive</span>) &#123;</span><br><span class="line">        println(another.workDetails)</span><br><span class="line">        println(<span class="keyword">this</span>.secret)</span><br><span class="line">        println(another.secret) <span class="comment">//会报错</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">package</span> social &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acquaintance</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">socialize</span></span>(person: professional.<span class="type">Executive</span>) &#123;</span><br><span class="line">        println(person.friends)</span><br><span class="line">        println(person.workDetails) <span class="comment">//会报错</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码里面有一个嵌套包的使用：可以看到，在society包里又声明了professional和social两个包。而且使用包的方式也和常见的不一样：一般的包声明是点号分隔，文件头声明的方式。</p><p>在类Executive的定义中，三个私有成员变量有着不同的作用范围。workDetails对包professional内的类可见，friends对society包内的类可见，而secret只对当前实例可见。</p><p>所以编译这段代码，在标记报错的地方会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value secret is not a member of com.zhyea.society.professional.Executive</span><br><span class="line">        println(another.secret) //会报错</span><br><span class="line"></span><br><span class="line">value workDetails in class Executive cannot be accessed in com.zhyea.society.professional.Executive</span><br><span class="line">        println(person.workDetails) //会报错</span><br></pre></td></tr></table></figure></p><p>Executive的成员secret只对当前实例（this）可见，对Executive的其他实例不可见。workDetails对包professional内的类可见，对society包内的类不可见。因此会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先简单介绍下scala访问修饰符的几个特性，稍后再详细解释：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不指定访问修饰符，默认为public；&lt;/li&gt;
&lt;li&gt;较之Java，scala对protected的定义更加严格；&lt;/li&gt;
&lt;li&gt;scala可以对可见性进行细粒度的控制。
      
    
    </summary>
    
      <category term="scala学习" scheme="http://scala.chobit.com/categories/scala%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用变长参数</title>
    <link href="http://scala.chobit.com/wiki/20180428/b001-useVeriableArguments/"/>
    <id>http://scala.chobit.com/wiki/20180428/b001-useVeriableArguments/</id>
    <published>2018-04-28T13:37:35.000Z</published>
    <updated>2018-04-29T07:16:57.718Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中是可以使用变长参数的，如下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String tmp : args) &#123;</span><br><span class="line">        System.out.println(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在scala中也可以使用变长参数。和java一样，也是只有最后一个参数可以接收可变长度的参数。使用方式是在参数类型后使用特殊符号“*”，如下面的max()方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(values: <span class="type">Int</span>*) = values.foldLeft(<span class="number">0</span>) &#123;</span><br><span class="line">    java.lang.<span class="type">Math</span>.max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>foldLeft是TraversableOnce类的方法。上面的代码实现了一个从一组整型数值中获取最大值的方法。  </p><p>不过和java不同的是，我们不能将一个数组中的元素当做变长参数直接传递给方法，来个测试案例看看：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def max(values: Int*) = values.foldLeft(0) &#123;Math.max&#125;</span><br><span class="line">max: (values: Int*)Int</span><br><span class="line"></span><br><span class="line">scala&gt; println(max(2, 5, 3, 7, 1, 6))</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">scala&gt; println(max( Array(2, 5, 3, 7, 1, 6)))</span><br><span class="line">&lt;console&gt;:13: error: <span class="built_in">type</span> mismatch;</span><br><span class="line"> found   : Array[Int]</span><br><span class="line"> required: Int</span><br><span class="line">       println(max( Array(2, 5, 3, 7, 1, 6)))</span><br></pre></td></tr></table></figure><p>可以看到在给max方法传递多个整型值作为参数时可以正常执行。但是将一个整型数组作为参数就报错了。  </p><p>如果想使用数组中的元素作为变长参数，可以将数组展开成为离散值：这里需要使用“:_*”符号组合。测试看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; println(max( Array(2, 5, 3, 7, 1, 6):_*))</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p><p>这次执行成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java中是可以使用变长参数的，如下面的方法：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="scala技巧" scheme="http://scala.chobit.com/categories/scala%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
