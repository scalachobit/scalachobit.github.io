{"pages":[{"title":"Tags","date":"2018-04-17T15:04:45.229Z","path":"tags/index.html","text":""},{"title":"About","date":"2018-04-17T15:04:45.226Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-04-17T15:04:45.227Z","path":"categories/index.html","text":""}],"posts":[{"title":"调用方法点和括号是可选的","date":"2018-05-03T14:04:13.000Z","path":"wiki/20180503/b007-pointlessMethod/","text":"在scala中，如果方法只有0或1个参数，点和括号就是可选的；如果方法的参数多于1个，就必须使用括号，但是点仍然是可选的。 比如我们常见的 1 + 2，实际上就是在执行 1.+(2) 。 这样做的优势也很明显：代码读起来更加自然，在展现上不至于显得杂乱。 下面是一段示例代码：12345678910111213class Teacher(val name: String) &#123; def teach(subject: String) = println(s\"$name teaches $subject.\") def teach(subject: String, student: String*) = println(s\"$name teaches $&#123;student.mkString(\",\")&#125; to learn $subject\")&#125;val teacher = new Teacher(\"Mr.Chang\")teacher teach \"Mathematics\"teacher teach (\"Mathematics\", \"robin\") 执行结果如下：12Mr.Chang teaches Mathematics.Mr.Chang teaches robin to learn Mathematics","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"可变长度参数","date":"2018-05-02T13:53:46.000Z","path":"wiki/20180502/b006-variableLengthParams/","text":"scala支持可变长度参数。在scala中，可变长度参数的特征如下： 在参数列表中处于最后面； 标识方法为在参数类型后放一个分号。 在scala解释器中写了一个示例：1234567scala&gt; def foo(str:String*) = str.foreach&#123;println&#125;foo: (str: String*)Unitscala&gt; foo(\"com\", \"zhyea\", \"robin\")comzhyearobin 在代码中定义了一个foo方法，它的参数长度就是可变的，方法体的定义是逐行输出每个参数。在随后的验证代码中可以看到结果和预期是一致的。 我们知道，在java中，变长参数是被作为数组来处理的。至于在scala中是否也是一样，则需要进行验证。对刚才的示例代码做了些调整来做一下验证：1234567891011121314scala&gt; def foo(str: String*) = println(str.getClass)foo: (str: String*)Unitscala&gt; foo(\"zhyea\")class scala.collection.mutable.WrappedArray$ofRefscala&gt; foo(\"com\", \"zhyea\")class scala.collection.mutable.WrappedArray$ofRefscala&gt; def foo(nums:Int*) = println(nums.getClass)foo: (nums: Int*)Unitscala&gt; foo(1, 2, 3)class scala.collection.mutable.WrappedArray$ofInt 可以看到，在scala中变长参数的类型是scala.collection.mutable.WrappedArray。WrappedArray和数组有什么关系呢？先搁置这个问题，来看一下一个真正的数组调用getClass方法会返回什么样的信息：12scala&gt; println(Array(1, 2, 3).getClass)class [I 输出的内容和上面的截然不同。这里输出的“[I”是一个Java描述符，表示int数组类型。可见scala的变长参数至少不是简单的数组结构。再来给带变长参数的方法传递一个数组结构会有什么样的反应：12345678scala&gt; def foo(str: String*) = println(str.getClass)foo: (str: String*)Unitscala&gt; foo(Array(\"com\", \"zhyea\", \"robin\"))&lt;console&gt;:13: error: type mismatch; found : Array[String] required: String foo(Array(\"com\", \"zhyea\", \"robin\")) 可以看到报错了：类型不匹配，需要的是String，传递是String数组。 如果我们确实需要把一个类型匹配的数组传递给这个方法，此时我们可以使用“:_”标识符。“:_”作为一个整体，告诉编译器你希望将某个参数当作参数序列处理。 看下演示：1234567scala&gt; def foo(nums:Int*) = nums.foreach(println)foo: (nums: Int*)Unitscala&gt; foo(Array(1,2,3) :_*)123 注意一下，“:_*”不只是能标识数组，还可以标识其他的集合，比如：1234scala&gt; foo(1 to 3 :_*)123 “1 to 3”是一个Range结果，使用“:_*”标识后依然可以被变长参数方法调用。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"","date":"2018-05-01T12:37:50.199Z","path":"wiki/20180501/a15-functionAndMethod/","text":"title: 方法VS函数toc: truedate: 2018-05-01 20:37:50tags: categories: scala学习在scala中，我们可以认为函数和方法是两个不同的概念——尽管很多时候它们是通用的。这一节简单介绍下二者之间的关系。 方法和函数的不同函数在定义和调用等方面有着不同。先来看一下。 定义scala中的方法是类的一部分，方法不能脱离类独立存在。 scala中的函数是一个对象。scala用22个trait（包括Function1~Function22，以下简称FunctionN）抽象出了函数的概念。scala中的函数就是实现了这些trait的对象。它的表现形式通常为“(T1, …, Tn) =&gt; U”。 声明下面是一个方法的声明：123def add(x: Int, y: Int): Int = &#123; x + y&#125; 下面是一个相同功能的函数的声明：123val multi = (x: Int, y: Int) =&gt; &#123; x * y&#125; 可以看到声明函数声明方法存在着明显的不同： 声明方法使用的是def关键字，声明函数使用的是val关键字 函数不需要(不可以)显式注明返回值的类型，方法的返回值类型是可选的 函数的表现形式为：(T1, …, Tn) =&gt; U 函数本质上是一个值（也称函数值），我们定义的multi函数其意义等同于下面的代码：123val multi = new Function2[Int, Int, Int]()&#123; override def apply(x: Int, y: Int): Int = x * y&#125; 这里代码中的multi实际上就是依赖trait Function2实现的一个匿名类实例。Function2有三个类型参数[Int, Int, Int]，前两个是apply方法的参数类型，最后一个是apply返回值类型。 apply是scala提供的一个语法糖，比如对object A调用A()，scala编译器会自动将之转换为A.apply()。对一个class B调用B()，就是在调用B的伴生对象的apply方法。 应该能注意到Function2有对应的函数有两个参数。scala就是这样设计的：FunctionN对应的函数有N个参数。所以scala的函数的参数长度是有限的。 既然函数本质上是一个对象，那么声明函数也可以使用关键字var：1var multi = (x:Int, y:Int) =&gt; x * y 在为var函数值变量重新赋值时遇到了一个问题：123456789scala&gt; var multi = (x: Int, y: Int) =&gt; x * ymulti: (Int, Int) =&gt; Int = &lt;function2&gt;scala&gt; multi = (x:Int) =&gt; x * 1&lt;console&gt;:12: error: type mismatch; found : Int =&gt; Int required: (Int, Int) =&gt; Int multi = (x:Int) =&gt; x * 1 ^ 重新赋值时要求新的函数值的参数列表与原函数值一致。这是因为scala的类型推断能力，在初始化multi函数值时就将multi的类型推断为Function2[Int, Int, Int]。当为multi重新赋值时，就只能赋值为Function2的实例[Int, Int, Int]，也就是只能赋值为相同参数类型且相同返回值类型的函数。 方法和函数的调用方法名就意味着方法的调用。而函数因为本身是一个值，函数名只能代表函数自身。 我们定义一个无参的方法和一个无参的函数来做一下演示：1234567891011scala&gt; def m() = 100m: ()Intscala&gt; val f = ()=&gt;100f: () =&gt; Int = &lt;function0&gt;scala&gt; mres1: Int = 100scala&gt; fres2: () =&gt; Int = &lt;function0&gt; 如果要调用一个函数，可以在函数名后面加上()：12scala&gt; f()res3: Int = 100 参数列表方法和函数都有参数列表，它们的参数列表的长度都可以为0。 方法可以没有参数列表，比如“def m=100”就是正确的。 函数则不能没有参数列表，如“val f = =&gt;100”就一定会报错。函数的参数列表长度可以为0，比如“()=&gt;100” 最终表达式因为函数本质上是一个值，所以函数可以作为最终表达式使用。12345scala&gt; val multi = (x:Int, y:Int) =&gt; x*ymulti: (Int, Int) =&gt; Int = &lt;function2&gt;scala&gt; multires5: (Int, Int) =&gt; Int = &lt;function2&gt; 方法不能作为最终表达式使用。当方法有参数时或者说参数长度大于0时，直接使用方法名就会报错。当方法参数长度为0时，直接使用方法名等同于调用方法。123456789scala&gt; def add(x:Int, y:Int) = x+yadd: (x: Int, y: Int)Intscala&gt; add&lt;console&gt;:13: error: missing argument list for method addUnapplied methods are only converted to functions when a function type is expected.You can make this conversion explicit by writing `add _` or `add(_,_)` instead of `add`. add ^ 方法和函数的转换在本文一开始我们提到过scala的函数和方法很多时候是通用的，这里是指scala中的函数和方法是可以互相转换的。有的时候这种转换甚至是隐式的。 将方法转换为函数scala的一些高级函数比如map()、filter()、foreach()等，需要传递一个函数值作为参数。我们可以直接传递一个方法给这些高级函数：1234567891011121314scala&gt; val list = List(1,2,3,4)list: List[Int] = List(1, 2, 3, 4)scala&gt; val f = (n:Int)=&gt;print(n)f: Int =&gt; Unit = &lt;function1&gt;scala&gt; list.foreach(f)1234scala&gt; def m(n:Int) = print(n)m: (n: Int)Unitscala&gt; list.foreach(m)1234 在代码中我们定义了一个List实例，我们主要调用了list的foreach方法。foreach方法的参数是一个函数值。通过foreach方法我们可以遍历List实例，并在函数值中调用List实例的每个值。 我们先为foreach方法提供了一个函数值f。函数值的功能很简单，就是打印出当前遍历的值。然后又为foreach方法提供了一个方法m作为参数，方法m和函数f提供的能力是相同的，我们可以看到执行结果也是相同的。 这种在期望出现函数的地方提供了一个方法，方法被自动转换成函数的行为被称为ETA展开。 注意，虽然scala提供了ETA展开的能力，但是不能直接将方法赋值给变量作为函数值。 刚才我们说的是一种隐式转换的例子。我们还可以显式地将方法转为函数，做法很简单，就是在方法名后面加一个下划线：12345scala&gt; def add(x:Int, y:Int) = x +yadd: (x: Int, y: Int)Intscala&gt; add _res12: (Int, Int) =&gt; Int = &lt;function2&gt; 注意方法名后的下划线和方法名中间需要存在一个空格。 scala还有一种特殊的参数叫做传名参数，如下：12345678def delayed( t: =&gt; Long ) = &#123; println(\"参数： \" + t) t &#125;def time() = System.currentTimeMillisdelayed(time()) 看起来有点儿像是函数值的使用，但是传名参数实质是一个没有参数列表的方法，因此使用参数名字的时候是调用了对应的方法。 将函数转换为方法将函数转换为方法的做法前面提到过：在函数名后面添加()和参数即可。12345scala&gt; val multi = (x:Int, y:Int) =&gt; x*ymulti: (Int, Int) =&gt; Int = &lt;function2&gt;scala&gt; multi(1,2)res13: Int = 2","tags":[],"categories":[]},{"title":"for循环详述","date":"2018-05-01T05:12:49.000Z","path":"wiki/20180501/a14-forLoopDetail/","text":"scala的for循环能做的事情很多，这里简单介绍下。 遍历集合元素示例代码如下：12345val list = List(1, 2, 3)for (e &lt;- list) &#123; println(s\"Current value is: $e\")&#125; 这里有些类似于java中的增强循环。代码中先创建了一个List集合，而后使用for循环遍历输出集合中的元素。 代码中的“e&lt;-list”结构被称为“生成器”，在每次迭代时，变量e会被初始化为List集合中的一个元素。e为val变量。 scala的for表达式支持所有的集合类型，比如数组、Range、List、Seq等。 过滤在遍历集合元素时，如不想处理某些元素，可以使用if语句（if语句也被称为卫述语句）来执行过滤。 示例代码如下：123for (e &lt;- 0 to 6; if e % 2 == 0) &#123; println(s\"Current value is: $e\")&#125; 代码中使用生成器“e &lt;- 0 to 6”生成了一个0~6的整型Range；在遍历过程中，使用if语句筛选出了整形序列中所有值为偶数的元素。看下执行结果：1234Current value is: 0Current value is: 2Current value is: 4Current value is: 6 如果有必要的话，可以添加多个过滤器，只需要再添加一个if语句即可。比如下面的代码过滤出了整型序列中值为偶数，且大于3的元素：12345for (e &lt;- 0 to 6 if e % 2 == 0 if e &gt; 3) &#123; println(s\"Current value is: $e\")&#125; 结果如下：12Current value is: 4Current value is: 6 多重循环for表达式支持多重循环。下面是个实例：12345val list = List(\"com\", \"zhyea\")for (e &lt;- list; c &lt;- e) &#123; println(s\"$c of $e\")&#125; 这段代码一重循环遍历了字符串集合中的每个元素，而后在二重循环中遍历了一个字符串元素的每个字符。看下执行结果：12345678c of como of comm of comz of zhyeah of zhyeay of zhyeae of zhyeaa of zhyea 上面代码中的两个循环间使用“;”做了分隔，因为下面这种写法在scala中是不被允许的：1234for (e &lt;- list c &lt;- e) &#123; println(s\"$c of $e\")&#125; 因为scala编译器不会推断在小括号内省略掉的“;”号。要想省略两个生成器中的“;”，可以使用花括号替换for循环的小括号：1234for &#123;e &lt;- list c &lt;- e&#125; &#123; println(s\"$c of $e\")&#125; 使用花括号和使用小括号是等价的，处理逻辑上并无不同。 绑定中间变量在for循环表达式中，scala允许创建一个变量保存中间值。看下示例代码：123456val list = List(\"com\", \"zhyea\")for &#123;e &lt;- list c &lt;- e index = e.indexOf(c)&#125; &#123; println(s\"Index of $c in $e is $index\")&#125; 在上面的for循环表达式中创建了一个index变量保存每个字符在字符串的索引位置。这里的index是val变量，只是不需要使用val声明。 如果将index变量移动到for循环的循环体中，则val声明不可省略。 生成新集合在for循环中可以使用yield关键字返回一个新的集合。通常新的集合的类型和循环的集合类型一致。 这个实例在scala解释器中写比较直观些：12scala&gt; val nums = for(i&lt;-List(\"com\", \"zhyea\", \"robin\")) yield inums: List[String] = List(com, zhyea, robin) 下面是一个返回值和循环的集合类型不严格一致的例子：12345scala&gt; val nums = 0 to 6nums: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5, 6)scala&gt; val nums = for(i&lt;- 0 to 6)yield inums: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6)","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"方法VS函数","date":"2018-05-01T02:23:25.000Z","path":"wiki/20180501/a15-methodVsFunction/","text":"在scala中，我们可以认为函数和方法是两个不同的概念——尽管很多时候它们是通用的。这一节简单介绍下二者之间的关系。 方法和函数的不同函数在定义和调用等方面有着不同。先来看一下。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"scala中的自适应做法","date":"2018-04-30T23:21:13.000Z","path":"wiki/20180501/b005-adaptivePractice/","text":"scala有一些默认做法，会让代码更简洁、更易读写，下面列出了这样几个特性： 支持脚本。scala支持脚本，因此无须将所有的代码都放到类里。如果脚本可以满足需求，就将代码放到一个脚本里，无须再创建一个冗余的类。 return是可选的。如果没有写return关键字，方法调用会自动返回最后一个求值的表达式——如果它符合方法声明的返回值类型。 分号“；”是可选的。不必在每个语句的后面都写上分号，这样会使代码更简洁。如果语句太长或者包含多行的话可以换行继续写，scala能够识别语句是否完整。通常使用分号的场景就是一行内有多条语句。 类和方法默认是public的，不必显式使用public关键字。 Scala提供了轻量级的语法创建JavaBean——用更少的代码创建变量和final属性。 Scala不会强制捕获一些不关心的异常，降低了代码规模，也避免了不恰当的异常处理。 另外，默认情况下，scala会导入两个包和一个对象。导入顺序如下：123java.langscalascala.Predef 两个包是：java.lang和scala，一个对象是scala.Predef。 因为有这个默认导入的机制，使用这两个包中的类不需要使用全限定类名。比如使用String类时，就不需要使用java.lang.String，也不必显式导入。因为默认导入了scala包中的全部内容，所以可以很容易的使用scala中的类型。 Predef对象（是对象不是类哦）包含了类型、隐式转换以及一些常用的方法。因为已经默认导入了，所以使用时无需导入也不需要任何前缀即可使用这些方法和转换。这些操作非常便捷，以至于在刚开始使用时会将之视为scala语言的一部分，实际上他们是scala程序库的一部分。 Predef对象也为诸如scala.collection.immutable.Set和scala.collection. immutable.Map这样的东西提供了别名。比如，引用Set或Map，实际上引用的是他们在Predef中的定义，它们会依次转换为其在scala.collection.immutable包里的定义。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"object中的main方法","date":"2018-04-30T23:20:48.000Z","path":"wiki/20180501/b004-objectMainMethod/","text":"scala对象的main方法可以作为应用或脚本的入口。 来看一个简单的实例：123456object MyApp &#123; def main(args: Array[String]): Unit = &#123; println(\"Hello World!\") &#125;&#125; 我们也可以通过混入trait App来避免使用main方法：12345object MyApp extends App &#123; println(\"Hello World!\")&#125; 这是因为在trait App中实现了main方法。类定义中的初始化代码块内容在编译时都被写入了一个函数对象缓存，直到在调用App的main方法时才会从缓存中取出初始化函数来执行。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"方法的定义","date":"2018-04-30T09:23:00.000Z","path":"wiki/20180430/a12-defineMethod/","text":"scala的方法关键字def声明开始。大致结构如下：1234def methodName ([list of parameters]) : [return type] = &#123; method body [return [expr]]&#125; scala方法名可以包含字符、数字以及各种符号。方法名不能以数字开头。虽然scala的方法名不能以数字开头，但是可以以特殊字符开头。可用的特殊字符如：+，++，~，&amp;，- ， – ，\\，/，:等。 scala的方法参数都是val类型，而不是var类型，因此在函数体内不可以修改参数的值。 关于scala的返回值有如下几个特点： scala的方法是一定有返回值的，看起来返回值为空时返回的是值类型Unit； 方法定义时返回值类型可以省略掉，scala会根据方法体中的内容推断出返回值类型； 显式声明了返回值类型时，方法定义中的“等号”不可以省略掉； 没有显式声明返回值类型时，则默认方法返回值为Unit，此时方法定义中的“=”也可省略掉； 使用return可以显式返回，但是不推荐这样做； 方法中的return关键字是可以省略掉的，默认方法中的最后一行就是函数的值； 对于递归方法，必须显式指明返回值类型。 多提一点：在scala中分号也是可选的，不必在每个语句的后面都写上分号，这样会使代码更简洁。如果语句太长或者包含多行的话可以换行继续写，scala能够识别语句是否完整。通常使用分号的场景就是一行内有多条语句。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"循环和循环控制","date":"2018-04-29T01:40:46.000Z","path":"wiki/20180429/a13-loopAndLoopControl/","text":"循环类型scala中的循环类型和java差不多，大体上有三种： while循环 do{}while循环 for循环 每样循环都写一段示例代码来看一下。 while循环代码如下：12345var i = 0while (i &lt; 6) &#123; println(s\"Value of i: $i\") i += 1&#125; 执行结果如下：123456Value of i: 0Value of i: 1Value of i: 2Value of i: 3Value of i: 4Value of i: 5 do{}while循环代码：12345var i = 0do &#123; println(s\"Value of i: $i\") i += 1&#125; while (i &lt; 6) 执行结果123456Value of i: 0Value of i: 1Value of i: 2Value of i: 3Value of i: 4Value of i: 5 for循环看一个示例：123for (i &lt;- 0 to 5) &#123; println(s\"Value of i $i\")&#125; 执行结果：12345Value of i 1Value of i 2Value of i 3Value of i 4Value of i 5 在上面代码中的循环结构里，”i &lt;- 0 to 5”是一个生成器表达式。在这里的每次循环中都会创建一个新的val变量i（而非是给i赋值），用生成器表达式产生出来的连续值进行初始化。 生成器表达式“1 to 3”生成的连续值包含了下界[1]和上界[3]，如果用until方法替换to方法后，就可以排除上界。to和until都是scala的RichInt类的方法。 这里使用1 to 3等价于1.to(3)，即数字1调用了整型的to方法。在scala中，如果方法有0或1个参数，点和括号是可以丢掉的。如果方法的参数多于一个，那么就必须保留括号，但是点仍是可选的。以一个非常常见的表达式为例：1 + 2在scala中实际上就是1.+(2)，+也是一个方法而非是简单的符号。 我们已经知道1 to 3返回的使一个连续值(Range)，那么也可以考虑使用Range的foreach方法来实现循环。代码如下：1(1 to 3).foreach(i =&gt; println(s\"Value of i $i\")) for循环的功能非常丰富，值得多多解释一下，所以会另写一篇进行说明。 循环控制通常的循环控制语句就是continue和break。但是这两个关键字在scala中是不存在的。不过我们可以使用一些技巧来实现这两种控制语句。 先来看一个Java的例子：123456789for(int i=0; i&lt;6; i++)&#123; if(i==2)&#123; continue; &#125; if(i==4)&#123; break; &#125; System.out.println(\"Value of i:\" + i);&#125; 代码要做的事情非常简单，不需要多做解释。 要用scala实现这个逻辑，简单点儿的思路是用if判断句来替换continue，用一个bool变量控制循环来替换break。代码如下：1234567891011var i: Int = 0var break: Boolean = falsewhile (i &lt; 6 &amp;&amp; !break) &#123; if (i != 2) &#123; if (i == 4) &#123; break = true &#125; println(s\"Value of i: $i\") &#125; i += 1&#125; 这段代码实现了前面那段Java代码的功能。期间我们还是使用了两个var变量。这两个var变量一个用来提供循环值，一个用来实现break功能中止循环。scala不鼓励使用var变量。我们尝试去掉这两个var变量。 要去掉循环值变量可以考虑将所有的循环值放入一个集合，然后使用for循环来处理。要去掉break控制变量，可以考虑主动抛出异常来中止当前代码块。 根据这个思路来做一下实现：1234567891011try &#123; for (i &lt;- 0 to 6) &#123; i match &#123; case 2 =&gt; case 4 =&gt; throw new RuntimeException case _ =&gt; println(s\"Value of i: $i\"); &#125; &#125;&#125; catch &#123; case e: RuntimeException =&gt;&#125; 在修改后的代码里使用模式匹配替换了if判断，并且演示了scala处理异常的方案。这里用抛出异常来实现break的方式scala中有提供具体的实现方案，即在scala.util.control包中定义的break控制结构，用法如下：1234567891011val b = new scala.util.control.Breaksb.breakable &#123; for (i &lt;- 0 to 6) &#123; i match &#123; case 2 =&gt; case 4 =&gt; b.break() case _ =&gt; println(s\"Value of i: $i\"); &#125; &#125;&#125; 思路还可以继续展开，比如用递归来替换循环：12345678910def myLoop(i: Int): Unit = &#123; if (i &gt; 6) () else if (i == 2) myLoop(i + 1) else if (i != 4) &#123; println(s\"Value of i: $i\"); myLoop(i + 1) &#125;&#125;myLoop(0) 在函数化编程中使用递归函数来实现循环是非常常见的一种方法，并且这样做很函数式。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"scala等于符号“==”","date":"2018-04-29T01:27:28.000Z","path":"wiki/20180429/b003-equalitySymbol/","text":"在java中，基本类型和引用类型对==运算有着不同的解释方式： 对于基本类型来说，==运算比较的就是两边表达式的值； 对于引用类型来说，==运算比较的是两边对象的引用而非是对象的值；在Java中比较对象的值使用的是equals方法。 在scala中没有对象，不论类型如何，==运算都是面向值的。这一点由scala的Any类（scala中所有的类都是由它派生而来）提供了保证：它将==()方法实现为final的方法。因此在scala中进行值的比较就可以简单使用==运算，如果还有一些特殊化的比较，就需要改写equals方法了。在scala中如果想执行对于引用的比较可以使用eq()方法。看一下下面这段程序： 12345678val str1 = \"hello\"val str2 = \"hello\"val str3 = new String(\"hello\")println(str1 == str2) // Equivalent to Java's str1.equals(str2)println(str1 eq str2) // Equivalent to Java's str1 == str2println(str1 == str3)println(str1 eq str3) 程序的执行结果： 1234truetruetruefalse 结果很清楚了。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"scala赋值符号“=”","date":"2018-04-29T01:15:04.000Z","path":"wiki/20180429/b002-assignmentSymbol/","text":"scala的赋值运算和java的赋值运算有着很大的不同。如a=b这样的赋值运算，在Java中的返回值是a的值，在scala中返回的则是Unit。Unit是值类型，全局只存在唯一的值，即()，通常Unit只用来声明函数或方法的返回值，其他场景基本是没有意义的。这样就很容易导致一些错误地使用，比如a=b=c这样的赋值运算在java中是绝对可以的，但是在scala中使用就会报错。 看一段代码：123var a, b, c = 1a = b=cprintln(a) 上面这段代码还没有执行就在IDE中提示错误了，勉强执行下看看会报什么错： 1234Error:(6, 9) type mismatch; found : Unit required: Int a = b = c 报了类型不匹配的错误，因为在第一行代码中scala推断出a是一个Int型的变量，后又将b=c的运算结果——一个Unit值——赋值给它，所以会报错了。 即使只在scala中看赋值运算符“=”号也是一个比较奇怪的东西：scala中的大部分运算符都是方法，但“=”不是方法，在默认情况下不可以这样使用：a.=(1)。对于这个问题，有心人可以深究下。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"访问修饰符","date":"2018-04-28T22:38:56.000Z","path":"wiki/20180429/a11-accessModifier/","text":"先简单介绍下scala访问修饰符的几个特性，稍后再详细解释： 如果不指定访问修饰符，默认为public； 较之Java，scala对protected的定义更加严格； scala可以对可见性进行细粒度的控制。 默认访问修饰符如果没有修饰符，scala会默认把类、字段、方法的访问修饰符当做public。如果要将之调整为private或protected，只需在前面添加对应的修饰符关键字即可。就如下面的程序： 123456789class Microwave&#123; def start() = println(\"started\") def stop() = println(\"stopped\") private def turnTable() = println(\"turning table\")&#125;val microwave = new Microwavemicrowave.start()microwave.turnTable()//这里错了 在上面的代码里start和stop两个方法默认为public类型，可以通过任意Microwave实例访问。turnTable被显示定义为private，这样就不能在Microwave类外部访问它。执行这段代码，就会如注释处声明的一样，会在该处报错：12method turnTable in class Microwave cannot be accessed in com.zhyea.MyApp.Microwave microwave.turnTable() protected修饰符在scala里，用protected修饰的成员只对本类和派生类可见，同一个包内的其他的类不可见。而且派生类只可以访问本类实例的protected成员。可以通过一个例子看一下： 1234567891011121314151617181920212223242526272829303132package com.zhyea.autoclass Vehicle &#123; protected def checkEngine() = println(\"checked engine\")&#125;class Car extends Vehicle &#123; def start() &#123; checkEngine() &#125; def tow(car: Car) &#123; car.checkEngine() &#125; def tow(vehicle: Vehicle) &#123; vehicle.checkEngine() //会报错 &#125;&#125;class GasStation &#123; def fillGas(vehicle: Vehicle) &#123; vehicle.checkEngine() //会报错 &#125; def fillGas(car: Car) &#123; car.checkEngine() //会报错 &#125;&#125; 在这段代码里，Vehicle的checkEngine()方法是protected型的，Car是Vehicle类的派生类。 根据scala对protected修饰符的要求： 在Car类自定义方法start()中访问父类Vehicle的checkEngine()方法不会报错； 在Car类自定义方法tow()中通过Car类实例访问父类Vehicle的checkEngine()方法不会报错； 在Car类自定义方法tow()中通过Vehicle类实例访问Vehicle的checkEngine()方法会报错； 在同一个包内的GasStation类中通过Car或Vehicle实例访问checkEngine()方法会报错 这些错误在编译期就会报出： 12345678910111213141516method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Vehicle Access to protected method checkEngine not permitted because prefix type com.zhyea.auto.Vehicle does not conform to class Car in package auto where the access take place vehicle.checkEngine() //会报错 method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Vehicle Access to protected method checkEngine not permitted because enclosing class GasStation in package auto is not a subclass of class Vehicle in package auto where target is defined vehicle.checkEngine() //会报错method checkEngine in class Vehicle cannot be accessed in com.zhyea.auto.Car Access to protected method checkEngine not permitted because enclosing class GasStation in package auto is not a subclass of class Vehicle in package auto where target is defined car.checkEngine() //会报错 细粒度访问控制scala对待protected比Java更加严格，但另一方面它提供了更多的灵活性和更细粒度的访问规则。 使用private和protected时可以指定额外的参数，使用方式如：private[AccessQualifier]。AccessQualifier可以是this，也可以是其它的类名或包名。对于修饰符private[AccessQualifier]可以这样理解：除了自己和AccessQualifier所表示范围内的类，该修饰符修饰的成员对其他所有类的可见性都是private。并且这个概念也是可以递推的，也就是说，如果AccessQualifier是一个类，那么private成员对于AccessQualifier的AccessQualifier也是可见的。 看一个细粒度访问控制的例子：1234567891011121314151617181920212223242526272829package society &#123; package professional &#123; class Executive &#123; private[professional] var workDetails = null private[society] var friends = null private[this] var secret = null def help(another: Executive) &#123; println(another.workDetails) println(this.secret) println(another.secret) //会报错 &#125; &#125; &#125; package social &#123; class Acquaintance &#123; def socialize(person: professional.Executive) &#123; println(person.friends) println(person.workDetails) //会报错 &#125; &#125; &#125;&#125; 这段代码里面有一个嵌套包的使用：可以看到，在society包里又声明了professional和social两个包。而且使用包的方式也和常见的不一样：一般的包声明是点号分隔，文件头声明的方式。 在类Executive的定义中，三个私有成员变量有着不同的作用范围。workDetails对包professional内的类可见，friends对society包内的类可见，而secret只对当前实例可见。 所以编译这段代码，在标记报错的地方会报错：12345value secret is not a member of com.zhyea.society.professional.Executive println(another.secret) //会报错value workDetails in class Executive cannot be accessed in com.zhyea.society.professional.Executive println(person.workDetails) //会报错 Executive的成员secret只对当前实例（this）可见，对Executive的其他实例不可见。workDetails对包professional内的类可见，对society包内的类不可见。因此会报错。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"使用变长参数","date":"2018-04-28T13:37:35.000Z","path":"wiki/20180428/b001-useVeriableArguments/","text":"在Java中是可以使用变长参数的，如下面的方法：12345public void check(String... args) &#123; for (String tmp : args) &#123; System.out.println(tmp); &#125;&#125; 在scala中也可以使用变长参数。和java一样，也是只有最后一个参数可以接收可变长度的参数。使用方式是在参数类型后使用特殊符号“*”，如下面的max()方法：123def max(values: Int*) = values.foldLeft(0) &#123; java.lang.Math.max&#125; foldLeft是TraversableOnce类的方法。上面的代码实现了一个从一组整型数值中获取最大值的方法。 不过和java不同的是，我们不能将一个数组中的元素当做变长参数直接传递给方法，来个测试案例看看： 1234567891011scala&gt; def max(values: Int*) = values.foldLeft(0) &#123;Math.max&#125;max: (values: Int*)Intscala&gt; println(max(2, 5, 3, 7, 1, 6))7scala&gt; println(max( Array(2, 5, 3, 7, 1, 6)))&lt;console&gt;:13: error: type mismatch; found : Array[Int] required: Int println(max( Array(2, 5, 3, 7, 1, 6))) 可以看到在给max方法传递多个整型值作为参数时可以正常执行。但是将一个整型数组作为参数就报错了。 如果想使用数组中的元素作为变长参数，可以将数组展开成为离散值：这里需要使用“:_*”符号组合。测试看看：12scala&gt; println(max( Array(2, 5, 3, 7, 1, 6):_*))7 这次执行成功了。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"使用yield关键字","date":"2018-04-28T13:36:56.000Z","path":"wiki/20180428/b000-useYield/","text":"基础用法使用yield关键字可以存储for循环返回值。每次循环时，返回值都会存储到一个结构中。在循环完成后，会将结构中的所有值一起返回。存储返回值的结构，和循环值的结构一致。也就是说如果循环的是一个数组返回的就是数组，循环的是一个List返回的就是一个List，循环的是一个Map返回的就是Map。 来看一个例子：12345scala&gt; val result = for &#123;i &lt;- List(1, 2, 3, 4)&#125; yield iresult: List[Int] = List(1, 2, 3, 4)scala&gt; val result = for &#123;i &lt;- Array(1, 2, 3, 4)&#125; yield iresult: Array[Int] = Array(1, 2, 3, 4) 在示例中，我们先后循环了一个List和一个整型数组。循环的返回值也分别是List和整型数组。 使用yield关键字还可以对返回值做进一步的加工：12scala&gt; val result = for &#123;i &lt;- Array(1, 2, 3, 4)&#125; yield i*2result: Array[Int] = Array(2, 4, 6, 8) 在使用yield关键字的同时，对每个返回值都做了乘以2的处理。所以最后返回的数组中的每个值都是循环值的2倍。 使用yield关键字还可以修改集合中值的类型，如下：12scala&gt; val result = for &#123;i &lt;- Array(1, 2, 3, 4)&#125; yield i*2.0result: Array[Double] = Array(2.0, 4.0, 6.0, 8.0) 原来循环的是一个整型数值数组，返回的则是Double值数组。 这里yield的用法有些类似于集合的map方法，所不同的是map方法是修改集合的原始值，yield则是返回一个新集合。 结合卫述语句在scala中if语句常被作为卫述语句。卫述语句是指被用来检查关键的先决条件的合法性并在检查未通过的情况下立即终止当前代码块的执行的语句。 yield结合卫述语句可以对循环值进行过滤处理。看一下示例代码：12scala&gt; val result = for &#123;i &lt;- Array(1, 2, 3, 4) if(i%2==0)&#125; yield iresult: Array[Int] = Array(2, 4) 这里使用if语句筛选出了循环的数组中所有的偶数。","tags":[],"categories":[{"name":"scala技巧","slug":"scala技巧","permalink":"http://scala.chobit.com/categories/scala技巧/"}]},{"title":"单例、独立对象和伴生对象","date":"2018-04-27T13:37:43.000Z","path":"wiki/20180427/a10-independentAndCompanionObject/","text":"scala单例单例模式大家都很熟悉了，简单地说就是使用单例模式的类一个类只能有一个实例。 在scala中创建单例对象非常简单，创建类时使用object关键字替换class即可。使用object声明的单例类无法初始化，所以不能向它的主构造函数传递参数。 使用object的时候可以直接用“object名.方法名”这样的形式来调用object中定义的方法。因此感觉着scala的单例类从某种意义上更像Java中只提供静态方法的工具类。 再来用Scala实现一个工具类Math，在这个类中提供一个计算绝对值的方法abs()：1234567object Math &#123; def abs(num: Int): Int = &#123; if (num &lt; 0) -num else num &#125;&#125; 使用时确实很像java的静态方法：1Math.abs(-1) 接下来将这个Math类生成的class文件转译为Java类，看看否和猜想的一样：对应的Java类是一个只提供静态方法的类。 编译Math类后看到生成了两个文件Math$.class和Math.class。看样子scala一个object类对应着两个Java类。用jd-gui反编译查看生成的Math$.class：12345678910111213141516public final class Math$&#123; public static final MODULE$; static&#123; new (); &#125; public int abs(int num)&#123; return num &lt; 0 ? -num : num; &#125; private Math$()&#123; MODULE$ = this; &#125;&#125; 可以看出这里就是一个常见的单例类的定义。再来看看Math.class反编译出来的内容：12345public final class Math&#123; public static int abs(int paramInt)&#123; return Math..MODULE$.abs(paramInt); &#125;&#125; 这里倒是一个工具类了，在这个工具类中是调用了Math$类的单例提供具体方法的实现。 从反编译出来的内容看来：scala的object中包含了一个单例对象，而不仅仅是一个提供了静态方法的工具类定义。 既然提到了静态方法就不妨多说两句：scala中没有静态方法和静态成员，静态成员会破坏scala所支持的完整的面向对象模型；static也不是scala中的关键字。所以在scala中定义一个名为static的变量是完全没问题的：12scala&gt; val static:Int=1static: Int = 1 独立对象前面我们演示的scala object对象Math，无需绑定其他类就可以独立使用，所以这样定义的object也被称为独立对象。 注意，这里说的是无需绑定其他类，而不是无需引用（import）其他类。绑定的概念产生在伴生对象中。 换句话说就是scala使用object声明的对象分为两种：独立对象和伴生对象。 伴生对象scala伴生对象是绑定到指定类上的对象。伴生对象和绑定的类共享同一个名字，绑定的类也被称为伴生类。在scala里，伴生类和伴生对象没有界限，它们互相可以访问彼此的private 方法和private 属性。 每个类都可以有伴生对象。伴生对象和伴生类写在同一个文件中，伴生对象在scala中很常见，它们提供了在类一级进行操作的便捷方法。从某种方面来说，伴生对象还可以作为scala缺少静态成员的变通措施。 下面用伴生对象的概念修改下前面定义的Math类：1234567891011121314class Math private() &#123; def abs(num: Int): Int = &#123; if (num &lt; 0) -num else num &#125;&#125;object Math &#123; private val m = new Math def abs(num: Int) = m.abs(num)&#125; 在修改后的代码中有同时名为Math的一个类和一个object。为了保证Math类的单例特性，还使用private修饰了Math类的主构造函数，这样只能由伴生对象创建Math类的实例（不使用private来修饰主构造函数也可以，这里只是为了保证单例的严密性）。 使用伴生对象还有另外一点好处：可以不使用new关键字就能创建伴生类的实例。再来修改Math类来看看：12345678910111213141516171819class Math private() &#123; def abs(num: Int): Int = &#123; if (num &lt; 0) -num else num &#125;&#125;object Math &#123; def apply() = new Math&#125;object Client &#123; def main(args: Array[String]): Unit = &#123; Math().abs(-1) &#125;&#125; 在Client的main方法中使用“Math()”这样的方式创建了一个Math类的对象。这里主要依赖了apply方法，它是scala提供的语法糖。上面的代码在调用Math()的时候，其实就是在调用object Math.apply()方法。通过这种方式可以让实例的创建和获取更加容易。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"类继承","date":"2018-04-26T21:57:16.000Z","path":"wiki/20180427/a09-classExtends/","text":"在scala里，类继承有两点限制： 重写方法需要使用override关键字； 只有主构造函数才能往父类构造函数中传参数。 在java1.5中引入了override注解，但不强制使用。不过在scala中要想重写方法必须使用override关键字。如果确实重写了父类的方法又不使用override关键字的话，则会在编译时报错，提示没有使用override修饰符。 scala的副构造函数必须调用主构造函数或是另一个副构造函数。只有在主构造函数中才能向父类的构造函数中传递数据。可以看出来主构造函数如同父类和子类中间的一道关卡：它既负责完成子类的初始化，也负责与父类的沟通。 下面的这段代码演示了下上述内容： 1234567class Vehicle(val id: Int, val year: Int) &#123; override def toString(): String = \"ID: \" + id + \" Year: \" + year&#125;class Car(override val id: Int, override val year: Int, var fuelLevel: Int) extends Vehicle(id, year) &#123; override def toString(): String = super.toString() + \" Fuel Level: \" + fuelLevel&#125; 在代码中定义了两个类：Vehicle和Car。Car继承了Vehicle。在继承的时候要向父类传递参数，所以Car类主构造函数的一部分必须能匹配父类的构造函数。Car类构造函数中的id和year两个成员变量源自父类Vehicle，所以需要使用override关键字修饰。此外，这两个类都重写了java.lang.Object的toString方法，所以需要使用override关键字修饰toString方法。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"类定义和构造器","date":"2018-04-25T22:05:15.000Z","path":"wiki/20180426/a08-classDefine/","text":"这次会通过与Java比较的方式来说明scala是如何创建类的。 类定义假设我们要定义一个学生类，先来看一下使用Java是如何定义的：123456789101112131415161718192021222324252627public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 很基础的一个Bean定义，大概用了27行代码。 再来看一下如何用scala定义这个学生类：1class Student(val name: String, val age: Int) 是的，只用一行就完成了类的定义，连大括号都不需要。并且在类定义的时候就完成了类构造器的创建。这里和类定义一起实现的构造器也叫作主构造器。 构造器除了主构造器，我们也可以在类的内部添加新的构造器。 现在我们为Student类新增一个类成员变量gender，并添加一个新的构造函数： 123456789class Student(val name: String, val age: Int) &#123; var gender: Short = _ def this(name: String, age: Int, gender: Short) &#123; this(name, age) this.gender = gender &#125;&#125; 区别于主构造函数，在类内部新定义的构造函数被称为副构造函数。 稍稍关注下副构造函数的实现：如果有主构造函数的话，那么副构造函数的第一行必须是主构造函数或者其它副构造函数的调用。这一点和java继承父类时有点相似。 此外还值得注意的就是成员变量gender的声明，把这一行单独拎出来看看吧：1var gender: Short = _ 这里比较有趣的是初始化赋值，赋的值是一个“_”——下划线。在这里“_”代表相应类型的默认值。对于Int，它的值是0；对于Double，它的值是0.0；对于String，它的值就是null。通过使用“_”，可以很方便地为var成员变量设置初始默认值。 不过不能为val成员使用“_”，因为val成员不允许修改，所以必须显式指定初始值。 如果构造器中的成员变量没有使用var或val修饰，将被视为类内部私有的val变量。 另外，放到类定义中的所有可执行语句或表达式都会被视为类的构造器的组成部分。如下面的代码：1234567class Student(val name: String, val age: Int) &#123; println(\"Create a new student instance.\") &#125;new Student(\"robin\", 20) 这段代码在定义Student类以后，又创建了一个Student实例。看下执行结果：123Create a new student instance.Process finished with exit code 0 在创建实例的时候输出了类定义中的print语句，因为这段print语句是构造器的一部分。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"字符串和多行字符串","date":"2018-04-24T22:38:43.000Z","path":"wiki/20180425/a07-stringAndMultiLineString/","text":"scala中的字符串类就是java中的java.lang.String类。不过scala也为String提供了一个富封装类：scala.runtime.RichString。 scala可以将java.lang.String类自动转换为scala.runtime.RichString类。这样就可以非常方便地使用capitalize()、lines()和reverse()等方法相对较便捷的方法。 在scala里，对于字符串的支持中最显著的一个特性是对于heredoc的支持，也就是对多行文本的支持。在scala里创建多行字符串非常容易，只要将多行字符串放在三个双引号里就行。在下面的代码里创建了一个四行的字符串：123456789var info = \"\"\" 这里是robin的信息： robin的姓名：robin zhang； robin的年龄：29； robin的个人主页：zhyea.com \"\"\"println(info) scala会将三个双引号间的内容保持原样输出。所以这样声明的字符串也被称为原始字符串。需要注意一点：在原始字符串中使用转义字符也不会被转义，仍然会原样输出。在scala解释器中演示一下：123456789101112131415scala&gt; val info = | \"\"\" | My name is \"robin\" \\n | Hello World! | \"\"\"info: String =\" My name is \"robin\" \\nHello World!\"scala&gt; println(info) My name is \"robin\" \\nHello World! 我在原始字符串中使用了空格缩进、双引号和转义字符“\\n”，在输出的时候这些都原样保留下来了。 RichString提供的方法中比较常用的是stripMargin。这个方法需要配合管道符“|”一起使用。如果管道符用在多行字符串每行的起始位置，stripMargin()方法会去掉先导管道符“|”前所有的空白或控制字符。如果出现在其他地方，而不是每行的开始，就会保留管道符。看个实例：123456789101112scala&gt; val info = | \"\"\" | |I'm trying to use method stripMargin. | \"\"\"info: String =\"I'm trying to use method stripMargin.\"scala&gt; println(info.stripMargin)I'm trying to use method stripMargin. 如果出于某种原因，管道符号“|”有特殊的用途，可以用stripMargin的重载方法来选择其他字符作为每行字符串的先导字符","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"var和val变量","date":"2018-04-24T14:06:20.000Z","path":"wiki/20180424/a06-varAndVal/","text":"变量声明前面我们提过，在scala中声明变量使用var和val都是可行的。其中val是value（值）的简写，var指的是variant（变量）。 用val声明的变量是不可变的，被初始化后值就固定下来，不可以再被修改（这类似于java中的final关键字）。用var声明的变量是可变的，可以任意修改。 在scala解释器中声明变量实例如下： 123456789101112scala&gt; var myVar:String = \"my var string\"myVar: String = my var stringscala&gt; myVar = \"update my var\"myVar: String = update my varscala&gt; val myVal:String = \"my val string\"myVal: String = my val stringscala&gt; myVal = \"update my val\"&lt;console&gt;:12: error: reassignment to val myVal = \"update my val\" 可以看到修改var变量是没有问题的。修改val变量时报错了，因为val变量是不可变的。 仍然要注意这里说的不可变是针对变量本身而言，而非变量所指向的实例。比如说如果定义了一个StringBuffer的val变量如val buffer = new StringBuffer()，那么变量buffer再执行诸如buffer.append(“robin”)这样的操作来修改buffer实例也是可行的。 在scala编程中应尽量优先使用val。这可以提升不变性和函数式风格。 变量类型声明前面我们在声明变量时都指定了变量类型： 1val myVal:String = \"my val string\" 不过在声明变量时，变量类型不是必需要指定的，像下面这样的写法也是完全没问题的： 12val myVal = \"my val string\"var myInt = 10 声明变量时，如没有指定变量类型，scala也可以根据变量的初始值来推断出变量的类型。因此，声明变量时如没有指定变量类型，就必须为其指定初始值，不然就会报错： 123scala&gt; var myVar;&lt;console&gt;:1: error: '=' expected but ';' found.var myVar; 声明多个变量scala也支持一次声明多个变量，像下面这样：123scala&gt; var a, b = 100a: Int = 100b: Int = 100 示例代码中同时声明了a， b两个变量，并为这两个变量同时赋值为100。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"运算符和优先级","date":"2018-04-23T13:42:01.000Z","path":"wiki/20180423/a05-operatorsInScala/","text":"运算符从语法上来说scala是没有运算符的。scala的运算符实际上是方法名，如1 + 2实际上就是1.+(2)。这些方法之所以能像运算符一样使用，是因为scala的一个特性： 如果方法的参数小于等于1个的话，那么“.”和括号就都是可选的 既然scala的运算符本质上是一个方法，那就说明我们可以自己实现或者重载这些所谓的运算符。下面的代码是一个复数做加法运算的示例，复数有实部和虚部，计算时需要分别处理：123456789101112131415class Complex(val real: Int, val imaginary: Int) &#123; def +(operand: Complex): Complex = &#123; new Complex(real + operand.real, imaginary + operand.imaginary) &#125; override def toString(): String = &#123; real + (if (imaginary &lt; 0) \"\" else \"+\") + imaginary + \"i\" &#125;&#125;val c1 = new Complex(1, 2)val c2 = new Complex(2, -3)val sum = c1 + c2println(\"(\" + c1+ \")+ (\" + c2 + \")=\" + sum) 在代码的第一行创建了一个名为Complex的类、定义了一个有两个参数的构造器。 在+方法里创建了一个新的Complex实例作为计算结果。结果的实部和虚部分别对应两个运算数实部和虚部之和。计算时c1+c2实际上就是c1.+(c2)。 看下上面程序的执行结果：1(1+2i)+ (2-3i)=3-1i 运算符的优先级既然scala中看起来像运算符的东西都是方法，那么和运算符相关的一些内容，比如算数优先级，scala是怎样处理的呢？ scala中确实没有算数优先级、但是它定义了方法优先级：方法的优先级由方法名的第一个字符决定，如果表达式里有两个相同优先级的方法，那么左边的方法优先级更高。下面从低到高列出了scala中方法名首字符的优先级： 123456789|^&amp;&lt; &gt;= !: + - * / % 所有其他特殊字符 我们在之前的Complex类中再添加一个乘法运算来演示下scala运算符的优先级：1234def *(operand: Complex): Complex = &#123; println(\"Calling *\") new Complex(real * operand.real - imaginary * operand.imaginary, real * operand.imaginary + imaginary * operand.real)&#125; 调用代码：12345val c1 = new Complex(1, 4)val c2 = new Complex(2, -3)val c3 = new Complex(2, 2)println(c1 + c2 * c3) 执行结果：123Calling *Calling +11+2i 可以看到*()方法先被执行了。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"基本类型","date":"2018-04-22T22:46:39.000Z","path":"wiki/20180423/a04-basicType/","text":"先声明一点，scala中是没有基本数据类型的。在scala中一切都是对象。 在Java中数据类型分为基本类型和引用类型。虽然在JDK1.5以后引入了自动装箱和自动拆箱机制，简化了一些基本类型和引用类型的转换问题。但是我们仍然会遇到一些问题： 默认值的问题，“Intege i”和“int i”声明的整型数值的默认值是不同的； 泛型的问题，List&lt;int&gt;这样的写法在Java中是不允许的； 直接量是不可以调用对象方法的，如1.toString()在Java中就会报错。 在scala中不会有这样的问题。一开始就提过了：在scala中一切都是对象。比如1.toString()这样的写法在scala中是完全可以的。对应着Java的每个基本类型，scala都有一个封装类，包括Byte、Char、Short、Int、Long、Float、Double和Boolean。scala的封装类和Java的基本类型是可以直接转换的，比如下面这段代码：1234567class ScalaInt &#123; def playWithInt() &#123; val capacity: Int = 10 val list = new java.util.ArrayList[String] list.ensureCapacity(capacity) &#125;&#125; 在这段代码中首先声明了一个scala.Int类型的值capacity，而后调用java API创建了一个ArrayList实例。ArrayList实例的ensureCapacity方法参数类型是一个Java的整型值。但是，我们直接将scala.Int类型的值capacity传递过去也并没有报错。在这里scala.Int变量capacity被隐式转换为java直接类型的变量。 值得一提的是，在封装类之外，scala还有一种富封装类。比如，稍后我们用到循环的时候，通常会有这样的写法：123for(i &lt;- 1 to 3&gt;)&#123; print(i)&#125; 代码里有“1 to 3”或者说“1.to(3)”，其中的to方法不是scala.Int类型的方法，而是其对应的富封装类scala.runtime.RichInt中的方法。当scala推断出Int型的值1无法满足要求时就会调用它的intWrapper方法将其转为scala.runtime.RichInt类型，而后再调用它的to方法。 在scala中直接量的封装类提供了算术运算方法，富封装类则封装了一些更常用的方法以方便开发使用。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"使用注释","date":"2018-04-22T13:53:24.000Z","path":"wiki/20180422/a03-comment/","text":"简单说下scala中的注释。scala的注释和java的注释是一样的，同样有多行注释和单行注释，使用方法也是一样的。 这里是一段示例代码：12345678910111213object HelloWorld &#123; /** * 这里是多行注释 * * 这里是main方法 */ def main(args: Array[String]): Unit = &#123; // 这里是单行注释 print(\"Hello World!\") &#125; &#125; 就是这样，没有什么需要解释的地方。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"快速体验Scala - 交互式编程","date":"2018-04-21T12:14:21.000Z","path":"wiki/20180421/a02-ineractiveCoding/","text":"scala提供的交互式解释器也是一种快速体验scala的一种方式。 使用交互式解释器在安装好scala开发环境后，打开命令行工具，输入scala就可以进入scala解释器：123456robin@robin-PC MINGW64 ~$ scalaWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_25).Type in expressions for evaluation. Or try :help.scala&gt; 输入“:quit”或“:q”可以退出scala解释器。接下来我们使用scala的交互式解释器来了解一些scala的基础概念。 定义变量scala的变量有两种类型：var和val。其中，val变量也可以称为常量，val定义的变量赋值后不可修改，类似于Java中final标记的变量。var变量可以随意赋值修改。12scala&gt; val msg = \"Hello World!\"msg: String = Hello World! 代码中声明了一个val变量msg。声明变量时没有显式指明类型，但是解释器也没有报错。scala是可以根据变量的值推断出变量的类型的。当然也可以显式指明变量类型，像下面这样：12scala&gt; val msg:String = \"Hello World!\"msg: String = Hello World! 定义函数在上一节我们已经在HelloWorld类中定义过一个main方法了，现在我们在交互式解释器中再定义一个新的函数:1234scala&gt; def hello(name:String)&#123; | println(s\"Hello $name!\") | println(\"End\") | &#125; 这里是在上一节定义的main函数：1def main(args: Array[String]) = println(\"Hello World!\") 我们比较一下这两个函数，可以看出scala函数定义的一些规则： scala函数以def关键字定义 函数的参数列表中，参数名称和参数类型以“:”分隔 方法体需要用花括号括起来，但是只有一行时，可以不使用花括号 方法的返回类型可以不必声明 等号不是必需的 大体上就是这样。scala函数定义的规则还有很多，这里只是管中窥豹，简单说下。 另外，在上面的代码中我们可以看到每一行语句末尾都没有使用分号，这是scala和java一个很大的不同。在scala中，分号是可选的。若一行中只有一个语句，分号可以不填；若一行中有多个语句，分号则是必填。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"快速体验Scala - Scasite","date":"2018-04-21T08:06:42.000Z","path":"wiki/20180421/a01-quickStart/","text":"前面一节简略说了Scala开发环境的准备工作。如果还没有安装Scala的开发环境，也可以快速在Scasite上快速体验一下。 还是按传统，来一个HelloWorld：123object HelloWorld &#123; def main(args: Array[String]) = println(\"Hello World!\")&#125; 这段代码中我们使用object关键字声明了一个结构：HelloWorld。之所以用“结构”这个词，是因为在没有上下文的情况下要描述清楚scala的object需要费些力气。不过可以用Java的一些概念来勉强描述下：scala的object相当于Java中的一个没有构造器，只有静态方法的final类。 再来看一下这个object里定义方法的形式：声明方法使用了def关键字，然后是方法名，方法名之后的括号中是参数列表，参数列表后一个等号紧跟着方法体。因为方法体只有一行，所以就没有用花括号括起来。参数列表中参数名和参数类型用冒号分隔，参数名在前。 打开Scasite。将这段代码放在Scasite的编辑框里，点击Run按钮执行。可以看到在下方的Console中输出了Hello Word！。不过同时还出现了一行提示：1You don&apos;t need a main method (or extends Scastie) in Worksheet Mode 说实话，我不太清楚Scasite的Worksheet Mode是什么意思。不过这提醒我了：Scala也是一种脚本语言。所以我们可以直接在Scasite的编辑框里输入下面的代码：1println(\"Hello World!\") 点击Run按钮执行，结果与之前一样。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"scala手账 - 主页","date":"2018-04-21T03:45:57.000Z","path":"wiki/20180421/index/","text":"scala学习： 准备开发环境 快速体验scala - Scasite 快速体验scala - 交互式编程 使用注释 基本类型 运算符和优先级 val和var变量 字符串和多行字符串 类定义和构造器 类继承 单例、独立对象和伴生对象 访问修饰符 循环和循环控制 方法的定义 for循环详述 scala杂技： 使用yield关键字 使用变长参数 scala赋值符号“=” scala等于符号“==” object中的main方法 scala中的自适应做法 This is Home Page. Hosted by Coding Pages","tags":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/tags/scala学习/"}],"categories":[]},{"title":"准备开发环境","date":"2018-04-19T14:04:33.000Z","path":"wiki/20180419/a00-prepareEnv/","text":"Scala开发环境准备步骤如下： 安装JDK环境，建议选择JDK8版本 安装Scala开发环境，选择最新版就行 聊作解释：建议JDK选择1.8是因为稍后会用到Gradle，Gradle对JDK9的兼容性目前并不好。不过，稍后许有调整也未可知。 IDE可以选择IntelliJ Idea， Eclipse的Scala IDE也未尝不可。我是颜控党，所以选择了IDEA。 关于环境就简单说这点儿。简单说下这次的学习计划：争取每天学习一个Scala的特性，间或会引入一些java的内容。 在这里立一个Flag。","tags":[{"name":"准备","slug":"准备","permalink":"http://scala.chobit.com/tags/准备/"}],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]}]}