{"pages":[{"title":"Categories","date":"2018-04-17T15:04:45.227Z","path":"categories/index.html","text":""},{"title":"About","date":"2018-04-17T15:04:45.226Z","path":"about/index.html","text":""},{"title":"Tags","date":"2018-04-17T15:04:45.229Z","path":"tags/index.html","text":""}],"posts":[{"title":"字符串和多行字符串","date":"2018-04-24T22:38:43.000Z","path":"wiki/20180425/a07-stringAndMultiLineString/","text":"scala中的字符串类就是java中的java.lang.String类。不过scala也为String提供了一个富封装类：scala.runtime.RichString。 scala可以将java.lang.String类自动转换为scala.runtime.RichString类。这样就可以非常方便地使用capitalize()、lines()和reverse()等方法相对较便捷的方法。 在scala里，对于字符串的支持中最显著的一个特性是对于heredoc的支持，也就是对多行文本的支持。在scala里创建多行字符串非常容易，只要将多行字符串放在三个双引号里就行。在下面的代码里创建了一个四行的字符串：123456789var info = \"\"\" 这里是robin的信息： robin的姓名：robin zhang； robin的年龄：29； robin的个人主页：zhyea.com \"\"\"println(info) scala会将三个双引号间的内容保持原样输出。所以这样声明的字符串也被称为原始字符串。需要注意一点：在原始字符串中使用转义字符也不会被转义，仍然会原样输出。在scala解释器中演示一下：123456789101112131415scala&gt; val info = | \"\"\" | My name is \"robin\" \\n | Hello World! | \"\"\"info: String =\" My name is \"robin\" \\nHello World!\"scala&gt; println(info) My name is \"robin\" \\nHello World! 我在原始字符串中使用了空格缩进、双引号和转义字符“\\n”，在输出的时候这些都原样保留下来了。 RichString提供的方法中比较常用的是stripMargin。这个方法需要配合管道符“|”一起使用。如果管道符用在多行字符串每行的起始位置，stripMargin()方法会去掉先导管道符“|”前所有的空白或控制字符。如果出现在其他地方，而不是每行的开始，就会保留管道符。看个实例：123456789101112scala&gt; val info = | \"\"\" | |I'm trying to use method stripMargin. | \"\"\"info: String =\"I'm trying to use method stripMargin.\"scala&gt; println(info.stripMargin)I'm trying to use method stripMargin. 如果出于某种原因，管道符号“|”有特殊的用途，可以用stripMargin的重载方法来选择其他字符作为每行字符串的先导字符","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"var和val变量","date":"2018-04-24T14:06:20.000Z","path":"wiki/20180424/a06-varAndVal/","text":"变量声明前面我们提过，在scala中声明变量使用var和val都是可行的。 用val声明的变量是不可变的，被初始化后值就固定下来，不可以再被修改（这类似于java中的final关键字）。用var声明的变量是可变的，可以任意修改。 在scala解释器中声明变量实例如下： 123456789101112scala&gt; var myVar:String = \"my var string\"myVar: String = my var stringscala&gt; myVar = \"update my var\"myVar: String = update my varscala&gt; val myVal:String = \"my val string\"myVal: String = my val stringscala&gt; myVal = \"update my val\"&lt;console&gt;:12: error: reassignment to val myVal = \"update my val\" 可以看到修改var变量是没有问题的。修改val变量时报错了，因为val变量是不可变的。 仍然要注意这里说的不可变是针对变量本身而言，而非变量所指向的实例。比如说如果定义了一个StringBuffer的val变量如val buffer = new StringBuffer()，那么变量buffer再执行诸如buffer.append(“robin”)这样的操作来修改buffer实例也是可行的。 在scala编程中应尽量优先使用val。这可以提升不变性和函数式风格。 变量类型声明前面我们在声明变量时都指定了变量类型： 1val myVal:String = \"my val string\" 不过在声明变量时，变量类型不是必需要指定的，像下面这样的写法也是完全没问题的： 12val myVal = \"my val string\"var myInt = 10 声明变量时，如没有指定变量类型，scala也可以根据变量的初始值来推断出变量的类型。因此，声明变量时如没有指定变量类型，就必须为其指定初始值，不然就会报错： 123scala&gt; var myVar;&lt;console&gt;:1: error: '=' expected but ';' found.var myVar; 声明多个变量scala也支持一次声明多个变量，像下面这样：123scala&gt; var a, b = 100a: Int = 100b: Int = 100 示例代码中同时声明了a， b两个变量，并为这两个变量同时赋值为100。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"Scala中的运算符","date":"2018-04-23T13:42:01.000Z","path":"wiki/20180423/a05-operatorsInScala/","text":"运算符从语法上来说scala是没有运算符的。scala的运算符实际上是方法名，如1 + 2实际上就是1.+(2)。这些方法之所以能像运算符一样使用，是因为scala的一个特性： 如果方法的参数小于等于1个的话，那么“.”和括号就都是可选的 既然scala的运算符本质上是一个方法，那就说明我们可以自己实现或者重载这些所谓的运算符。下面的代码是一个复数做加法运算的示例，复数有实部和虚部，计算时需要分别处理：123456789101112131415class Complex(val real: Int, val imaginary: Int) &#123; def +(operand: Complex): Complex = &#123; new Complex(real + operand.real, imaginary + operand.imaginary) &#125; override def toString(): String = &#123; real + (if (imaginary &lt; 0) \"\" else \"+\") + imaginary + \"i\" &#125;&#125;val c1 = new Complex(1, 2)val c2 = new Complex(2, -3)val sum = c1 + c2println(\"(\" + c1+ \")+ (\" + c2 + \")=\" + sum) 在代码的第一行创建了一个名为Complex的类、定义了一个有两个参数的构造器。 在+方法里创建了一个新的Complex实例作为计算结果。结果的实部和虚部分别对应两个运算数实部和虚部之和。计算时c1+c2实际上就是c1.+(c2)。 看下上面程序的执行结果：1(1+2i)+ (2-3i)=3-1i 运算符的优先级既然scala中看起来像运算符的东西都是方法，那么和运算符相关的一些内容，比如算数优先级，scala是怎样处理的呢？ scala中确实没有算数优先级、但是它定义了方法优先级：方法的优先级由方法名的第一个字符决定，如果表达式里有两个相同优先级的方法，那么左边的方法优先级更高。下面从低到高列出了scala中方法名首字符的优先级： 123456789|^&amp;&lt; &gt;= !: + - * / % 所有其他特殊字符 我们在之前的Complex类中再添加一个乘法运算来演示下scala运算符的优先级：1234def *(operand: Complex): Complex = &#123; println(\"Calling *\") new Complex(real * operand.real - imaginary * operand.imaginary, real * operand.imaginary + imaginary * operand.real)&#125; 调用代码：12345val c1 = new Complex(1, 4)val c2 = new Complex(2, -3)val c3 = new Complex(2, 2)println(c1 + c2 * c3) 执行结果：123Calling *Calling +11+2i 可以看到*()方法先被执行了。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"基本类型","date":"2018-04-22T22:46:39.000Z","path":"wiki/20180423/a04-basicType/","text":"先声明一点，scala中是没有基本数据类型的。在scala中一切都是对象。 在Java中数据类型分为基本类型和引用类型。虽然在JDK1.5以后引入了自动装箱和自动拆箱机制，简化了一些基本类型和引用类型的转换问题。但是我们仍然会遇到一些问题： 默认值的问题，“Intege i”和“int i”声明的整型数值的默认值是不同的； 泛型的问题，List&lt;int&gt;这样的写法在Java中是不允许的； 直接量是不可以调用对象方法的，如1.toString()在Java中就会报错。 在scala中不会有这样的问题。一开始就提过了：在scala中一切都是对象。比如1.toString()这样的写法在scala中是完全可以的。对应着Java的每个基本类型，scala都有一个封装类，包括Byte、Char、Short、Int、Long、Float、Double和Boolean。scala的封装类和Java的基本类型是可以直接转换的，比如下面这段代码：1234567class ScalaInt &#123; def playWithInt() &#123; val capacity: Int = 10 val list = new java.util.ArrayList[String] list.ensureCapacity(capacity) &#125;&#125; 在这段代码中首先声明了一个scala.Int类型的值capacity，而后调用java API创建了一个ArrayList实例。ArrayList实例的ensureCapacity方法参数类型是一个Java的整型值。但是，我们直接将scala.Int类型的值capacity传递过去也并没有报错。在这里scala.Int变量capacity被隐式转换为java直接类型的变量。 值得一提的是，在封装类之外，scala还有一种富封装类。比如，稍后我们用到循环的时候，通常会有这样的写法：123for(i &lt;- 1 to 3&gt;)&#123; print(i)&#125; 代码里有“1 to 3”或者说“1.to(3)”，其中的to方法不是scala.Int类型的方法，而是其对应的富封装类scala.runtime.RichInt中的方法。当scala推断出Int型的值1无法满足要求时就会调用它的intWrapper方法将其转为scala.runtime.RichInt类型，而后再调用它的to方法。 在scala中直接量的封装类提供了算术运算方法，富封装类则封装了一些更常用的方法以方便开发使用。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"使用注释","date":"2018-04-22T13:53:24.000Z","path":"wiki/20180422/a03-comment/","text":"简单说下scala中的注释。scala的注释和java的注释是一样的，同样有多行注释和单行注释，使用方法也是一样的。 这里是一段示例代码：12345678910111213object HelloWorld &#123; /** * 这里是多行注释 * * 这里是main方法 */ def main(args: Array[String]): Unit = &#123; // 这里是单行注释 print(\"Hello World!\") &#125; &#125; 就是这样，没有什么需要解释的地方。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"快速体验Scala - 交互式编程","date":"2018-04-21T12:14:21.000Z","path":"wiki/20180421/a02-ineractiveCoding/","text":"scala提供的交互式解释器也是一种快速体验scala的一种方式。 使用交互式解释器在安装好scala开发环境后，打开命令行工具，输入scala就可以进入scala解释器：123456robin@robin-PC MINGW64 ~$ scalaWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_25).Type in expressions for evaluation. Or try :help.scala&gt; 输入“:quit”或“:q”可以退出scala解释器。接下来我们使用scala的交互式解释器来了解一些scala的基础概念。 定义变量scala的变量有两种类型：var和val。其中，val变量也可以称为常量，val定义的变量赋值后不可修改，类似于Java中final标记的变量。var变量可以随意赋值修改。12scala&gt; val msg = \"Hello World!\"msg: String = Hello World! 代码中声明了一个val变量msg。声明变量时没有显式指明类型，但是解释器也没有报错。scala是可以根据变量的值推断出变量的类型的。当然也可以显式指明变量类型，像下面这样：12scala&gt; val msg:String = \"Hello World!\"msg: String = Hello World! 定义函数在上一节我们已经在HelloWorld类中定义过一个main方法了，现在我们在交互式解释器中再定义一个新的函数:1234scala&gt; def hello(name:String)&#123; | println(s\"Hello $name!\") | println(\"End\") | &#125; 这里是在上一节定义的main函数：1def main(args: Array[String]) = println(\"Hello World!\") 我们比较一下这两个函数，可以看出scala函数定义的一些规则： scala函数以def关键字定义 函数的参数列表中，参数名称和参数类型以“:”分隔 方法体需要用花括号括起来，但是只有一行时，可以不使用花括号 方法的返回类型可以不必声明 等号不是必需的 大体上就是这样。scala函数定义的规则还有很多，这里只是管中窥豹，简单说下。 另外，在上面的代码中我们可以看到每一行语句末尾都没有使用分号，这是scala和java一个很大的不同。在scala中，分号是可选的。若一行中只有一个语句，分号可以不填；若一行中有多个语句，分号则是必填。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"快速体验Scala - Scasite","date":"2018-04-21T08:06:42.000Z","path":"wiki/20180421/a01-quickStart/","text":"前面一节简略说了Scala开发环境的准备工作。如果还没有安装Scala的开发环境，也可以快速在Scasite上快速体验一下。 还是按传统，来一个HelloWorld：123object HelloWorld &#123; def main(args: Array[String]) = println(\"Hello World!\")&#125; 这段代码中我们使用object关键字声明了一个结构：HelloWorld。之所以用“结构”这个词，是因为在没有上下文的情况下要描述清楚scala的object需要费些力气。不过可以用Java的一些概念来勉强描述下：scala的object相当于Java中的一个没有构造器，只有静态方法的final类。 再来看一下这个object里定义方法的形式：声明方法使用了def关键字，然后是方法名，方法名之后的括号中是参数列表，参数列表后一个等号紧跟着方法体。因为方法体只有一行，所以就没有用花括号括起来。参数列表中参数名和参数类型用冒号分隔，参数名在前。 打开Scasite。将这段代码放在Scasite的编辑框里，点击Run按钮执行。可以看到在下方的Console中输出了Hello Word！。不过同时还出现了一行提示：1You don&apos;t need a main method (or extends Scastie) in Worksheet Mode 说实话，我不太清楚Scasite的Worksheet Mode是什么意思。不过这提醒我了：Scala也是一种脚本语言。所以我们可以直接在Scasite的编辑框里输入下面的代码：1println(\"Hello World!\") 点击Run按钮执行，结果与之前一样。","tags":[],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]},{"title":"scala手账 - 主页","date":"2018-04-21T03:45:57.000Z","path":"wiki/20180421/index/","text":"scala学习： 准备开发环境 快速体验scala - Scasite 快速体验scala - 交互式编程 使用注释 基本类型 val和var变量 字符串和多行字符串 This is Home Page.","tags":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/tags/scala学习/"}],"categories":[]},{"title":"准备开发环境","date":"2018-04-19T14:04:33.000Z","path":"wiki/20180419/a00-prepareEnv/","text":"Scala开发环境准备步骤如下： 安装JDK环境，建议选择JDK8版本 安装Scala开发环境，选择最新版就行 聊作解释：建议JDK选择1.8是因为稍后会用到Gradle，Gradle对JDK9的兼容性目前并不好。不过，稍后许有调整也未可知。 IDE可以选择IntelliJ Idea， Eclipse的Scala IDE也未尝不可。我是颜控党，所以选择了IDEA。 关于环境就简单说这点儿。简单说下这次的学习计划：争取每天学习一个Scala的特性，间或会引入一些java的内容。 在这里立一个Flag。","tags":[{"name":"准备","slug":"准备","permalink":"http://scala.chobit.com/tags/准备/"}],"categories":[{"name":"scala学习","slug":"scala学习","permalink":"http://scala.chobit.com/categories/scala学习/"}]}]}